//
// Copyright (C) 2020, NinjaTrader LLC <www.ninjatrader.com>.
// NinjaTrader reserves the right to modify or overwrite this NinjaScript component with each release.
//
#region Using declarations
using System;
using System.Collections.Generic;
using System.Globalization;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Xml.Serialization;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Gui.Tools;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.Indicators;
using NinjaTrader.NinjaScript.DrawingTools;
using NinjaTrader.Code;
using System.Threading;
using System.Collections.Concurrent;
using System.IO;
using NinjaTrader.NinjaScript.Indicators.TickHunterTA.TH;
using NinjaTrader.NinjaScript.Indicators.TickHunterTA;


#endregion


// This namespace holds indicators in this folder and is required. Do not change it.
namespace NinjaTrader.NinjaScript.Indicators.TickHunterTA
{
    public enum TickHunterBreakEvenAutoTypes
    {
        Disabled = 0,
        HODL = 1,
        Enabled = 2,
        PlusTrail1Bar = 3,
        PlusTrail2Bar = 4,
        PlusTrail3Bar = 5,
        PlusTrail5Bar = 6,
        PlusTrailMix = 7,
        PlusTrailSpeedLine = 8,
        PlusTrailRushLine = 9,
        PlusTrailRiver1 = 10,
        PlusTrailRiver5 = 11,
        PlusTrailCreek1 = 12,
        PlusTrailCreek5 = 13,
        PlusTrailKLineDual = 14,
        PlusTrailZipLine2 = 15,
        PlusTrailZipLineDual = 16,
        PlusTrailKZ = 17,
        PlusTrailStingRay = 18,
        PlusTrailMonster = 19,
        PlusTrailDriftMonster = 20,
        PlusTrailDriftLine1 = 21,
        PlusTrailDriftLine2 = 22,
        PlusTrailDriftLine3 = 23,
        PlusTrailDriftLine4 = 24,
        PlusTrailMovingAverage1 = 25,
        PlusTrailMovingAverage2 = 26,
        PlusTrailMovingAverage3 = 27,
        PlusTrailMovingAverage4 = 28,
        CreeperZombieFlipTrail = 29,
        CreeperFlipTrail = 30,
        ZombieFlipResumeTrail = 31,
        ProfilePeppy = 32,
        ProfileSleepy = 33
    };

    public enum TickHunterBreakEvenAutoTrailNowTypes
    {
        Disabled = 0,
        TrailNowBeforeBE = 1,
        TrailNowAfterProfit = 2
    };

    public enum TickHunterProfitTargetTypes
    {
        Disabled = 0,
        EquityCloseAllTarget = 1,
        BogeyTarget = 2
    };

    public enum TickHunterCloseAutoTypes
    {
        Disabled = 0,
        ZombieFlip = 1,
        ZombieStackedFlip = 2,
        ZombieBoostedFlip = 3,
        CreeperFlip = 4,
        KLineDualFlip = 5,
        ZLineDualFlip = 6,
        KZFlip = 7,
        MovingAverage1Slope = 8,
        MovingAverage2Slope = 9,
        MovingAverage3Slope = 10,
        MovingAverage4Break = 11,
        DriftLine4Break = 12,
        ProfilePeppy = 13,
        ProfileSleepy = 14
    };

    public enum TickHunterTradeSignalTypes
    {
        Disabled = 0,
        BuySellAll = 1,
        BuySellFiltered = 2,
        BuyOnly = 3,
        SellOnly = 4
    };

    public enum TickHunterAutoPilotProfileTypes
    {
        Disabled = 0,
        Peppy = 1,
        Sleepy = 2
    };

    public enum TickHunterPopTypes
    {
        PopPlus = 1,
        PopMinus = 2
    };

    public enum TickHunterAutoPilotProfileSetupTypes
    {
        CreeperOnly = 0,
        ZombieOnly = 1,
        SliderOnly = 2,
        CreeperOrSliderCombo = 3,
        ZombieOrSliderCombo = 4,
        ZombieOrCreeperCombo = 5,
        ZombieOrCreeperOrSliderCombo = 6
    };

    public enum TickHunterAutoPilotLiteTypes
    {
        Disabled = 0,
        NextSetup = 1,
        NextFilteredSetup = 2,
        BuySetup = 3,
        SellSetup = 4,
        AlertSetup = 5
    };

    public enum TickHunterAutoPilotSetupTypes
    {
        CreeperOnly = 0,
        ZombieOnly = 1,
        WalkerOnly = 2,
        CreeperOrCZCombo = 3,
        ZombieBoostedOnly = 4,
        ZombieStackedOnly = 5,
        ZombieBoostedOrStackedCombo = 6,
        ZombieOrCreeperCombo = 7,
        ZombieOrRiverBreakCombo = 8,
        ZombieOrDriftBreakCombo = 9,
        CreeperOrDriftBreakCombo = 10,
        CreeperOrRiverBreakCombo = 11,
        StingRayBreakOnly = 12,
        PeppySetupCombo = 13,
        SleepySetupCombo = 16
    };

    public enum TickHunterAutoPilotTypes
    {
        Disabled = 0,
        TradeCount1 = 1,
        TradeCount2 = 2,
        TradeCount3 = 3,
        TradeCount4 = 4,
        TradeCount5 = 5,
        TradeCount6 = 6,
        TradeCount7 = 7,
        TradeCount8 = 8,
        TradeCount9 = 9,
        TradeCount10 = 10
    };

    public enum TickHunterPopDelayedTypes
    {
        Disabled = 0,
        TradeCount1 = 1,
        TradeCount2 = 2,
        TradeCount3 = 3,
        TradeCount4 = 4,
        TradeCount5 = 5
    };

    public enum TickHunterAutoAddOnTypes
    {
        Disabled = 0,
        Enabled = 1
    };
    public enum TickHunterStopLossSnapTypes
    {
        Disabled = 0,
        Snap1Bar = 1,
        Snap2Bar = 2,
        Snap3Bar = 3,
        Snap4Bar = 4,
        Snap5Bar = 5,
        Snap6Bar = 6,
        Snap7Bar = 7,
        Snap8Bar = 8,
        Snap9Bar = 9,
        Snap10Bar = 10,
        Snap11Bar = 11,
        Snap12Bar = 12,
        Snap13Bar = 13,
        Snap14Bar = 14,
        Snap15Bar = 15,
        Snap16Bar = 16,
        Snap17Bar = 17,
        Snap18Bar = 18,
        Snap19Bar = 19,
        Snap20Bar = 20,
        SnapSpeedLine = 21,
        SnapRushLine = 22,
        SnapZipLine1 = 23,
        SnapZipLine2 = 24,
        SnapDriftLine1 = 25,
        SnapDriftLine2 = 26,
        SnapDriftLine3 = 27,
        SnapDriftLine4 = 28,
        SnapKineticLine1 = 29,
        SnapKineticLine2 = 30,
        SnapRiver1 = 31,
        SnapRiver5 = 32,
        SnapCreek1 = 33,
        SnapCreek5 = 34,
        SnapKeltnerInnerRing = 35,
        SnapStingRayLevel1 = 36,
        SnapStingRayLevel2 = 37,
        SnapStingRayLevel3 = 38,
        SnapStingRayLevel4 = 39,
        SnapStingRayLevel5 = 40,
        SnapStingRayXLevel = 41,
        SnapPBLevel = 42,
        SnapPBLevel10 = 43,
        SnapPBLevel20 = 44,
        SnapPBLevel30 = 45,
        SnapPBLevel40 = 46,
        SnapPBLevel50 = 47,
        SnapProfilePeppy = 48,
        SnapProfileSleepy = 49
    }

    public enum TickHunterAutoPilotOrderTypes
    {
        Market = 0,
        MarketPop = 1
    }

    public enum TickHunterEntryVolumeAutoTypes
    {
        Option1 = 0,
        Option2 = 1,
        Option3 = 2,
        Option4 = 3,
        Option5 = 4
    }

    public enum TickHunterEntryVolumeMaxTypes
    {
        Option1 = 0,
        Option2 = 1,
        Option3 = 2,
        Option4 = 3,
        Option5 = 4
    }

    /// <summary>
    /// Tick Hunter
    /// </summary>
    public partial class TickHunter : Indicator
    {
        private const string SystemVersion = "v1.451";
        private const string SystemName = "TickHunter";
        private const string FullSystemName = SystemName + " - " + SystemVersion;
        private const string SystemDescription = "Use TickHunter at your own risk.  None of the authors, contributors, administrators, or anyone else connected with TickHunter, in any way whatsoever, can be responsible or held liable for using this trading tool.";
        private const string SignalName = "TickHunter";
        private const string ObjectPrefix = "th_";
        private const string InfoLink = "https://discord.gg/HUt7dQrBYc";
        //private const string TickHunterSessionStateFileName = "TickHunterSessionState.csv";

        private const string CloseAlertMessageTitle = SystemName + " - Close Alert";
        private const string CloseAlertAltMessageTitle = CloseAlertMessageTitle + " (Alt)";
        private const string BuyZombieAlertMessageTitle = SystemName + " - Buy Zombie Alert";
        private const string BuyZombieAlertAltMessageTitle = BuyZombieAlertMessageTitle + " (Alt)";
        private const string BuyCreeperAlertMessageTitle = SystemName + " - Buy Creeper Alert";
        private const string BuyCreeperAlertAltMessageTitle = BuyCreeperAlertMessageTitle + " (Alt)";
        private const string SellZombieAlertMessageTitle = SystemName + " - Sell Zombie Alert";
        private const string SellZombieAlertAltMessageTitle = SellZombieAlertMessageTitle + " (Alt)";
        private const string SellCreeperAlertMessageTitle = SystemName + " - Sell Creeper Alert";
        private const string SellCreeperAlertAltMessageTitle = SellCreeperAlertMessageTitle + " (Alt)";

        private const string BuySliderAlertMessageTitle = SystemName + " - Buy Slider Alert";
        private const string SellSliderAlertMessageTitle = SystemName + " - Sell Slider Alert";

        private const int ZombieSetupBuyCode = 1;
        private const int ZombieSetupSellCode = -1;
        private const int ZombieSetupNoCode = 0;
        private const int StingRayHigherHighCode = 1;
        private const int StingRayLowerLowCode = -1;
        private const int StingRayNoChangeCode = 0;

        private const int AveragePriceLineZOrder = 50000;

        private Account account = null;
        private string atmStrategyName = string.Empty;
        private NinjaTrader.Gui.Tools.AccountSelector accountSelector = null;
        private System.Windows.Threading.DispatcherTimer timer;
        private double lastAccountBalance = 0;
        private DateTime lastOrderOutputTime = DateTime.MinValue;
        private bool hasRanOnceFirstCycle = false;
        private bool hasDrawnButtons = false;
        private bool accountHadPositions = false;
        private RealLogger RealLogger = new RealLogger(SystemName);
        private RealInstrumentService RealInstrumentService = new RealInstrumentService();
        private RealTradeService RealTradeService = new RealTradeService();
        private RealPositionService RealPositionService = new RealPositionService();
        private RealOrderService RealOrderService = new RealOrderService();
        private Dictionary<long, Order> ninjaTraderOrders = new Dictionary<long, Order>();
        private List<RealSessionState> accountSessionState = new List<RealSessionState>();
        private bool IsNinjaTraderOrdersAlreadyLoaded = false;
        private bool isIndicatorSuspended = false;

        private RealRunOncePerBar AutoPilotRunOncePerBar = new RealRunOncePerBar();
        private RealRunOncePerBar AutoAddOnRunOncePerBar = new RealRunOncePerBar();
        private RealRunOncePerBar AutoCloseRunOncePerBar = new RealRunOncePerBar();
        private RealRunOncePerBar AutoBreakEvenRunOncePerBar = new RealRunOncePerBar();
        private RealRunOncePerBar PopDelayedEntryRunOncePerBar = new RealRunOncePerBar();

        private readonly object ThreadManagerLock = new object();
        private readonly object AccountLock = new object();
        private readonly object ClosePositionLock = new object();
        private readonly object FlattenEverythingLock = new object();
        private readonly object NewPositionLock = new object();
        private readonly object MarketOrderLock = new object();
        private readonly object PositionTPSLOrderDelayLock = new object();
        private readonly object RefreshTPSLLock = new object();
        private readonly object RefreshPositionInfoLock = new object();
        private readonly object PopAutoJumpToSnapLock = new object();
        private readonly object DropAutoJumpToSnapLock = new object();
        private readonly object ClosePositionsInProfitLock = new object();
        private readonly object ClosePositionsInLossLock = new object();
        private readonly object RealTimePipelineLock = new object();
        private readonly object DelayedPipelineLock = new object();
        private DateTime lastPositionQuantityChange = DateTime.MinValue;
        private string lastATMStopLossStrategyName = string.Empty;
        private string lastATMTakeProfitStrategyName = string.Empty;

        private System.Windows.Controls.Grid thLayoutGrid = null;
        private System.Windows.Controls.Grid buttonGrid = null;
        private System.Windows.Controls.Grid labelGrid = null;
        private System.Windows.Controls.Button toggleAutoBEButton = null;
        private System.Windows.Controls.Button closeAllButton = null;
        private System.Windows.Controls.Button toggleAutoCloseButton = null;
        private System.Windows.Controls.Button BEButton = null;
        private System.Windows.Controls.Button SLButton = null;
        private System.Windows.Controls.Button TPButton = null;
        private System.Windows.Controls.Button revButton = null;
        private System.Windows.Controls.Button BuyDropButton = null;
        private System.Windows.Controls.Button SellDropButton = null;
        private System.Windows.Controls.Button BuyPopButton = null;
        private System.Windows.Controls.Button SellPopButton = null;
        private System.Windows.Controls.Button BuyMarketButton = null;
        private System.Windows.Controls.Button SellMarketButton = null;
        private System.Windows.Controls.Button toggleProfitTargetButton = null;
        private System.Windows.Controls.Button toggleEntryVolumeMaxButton = null;
        private System.Windows.Controls.Button toggleEntryVolumeAutoButton = null;
        private System.Windows.Controls.Button toggleAutoAddOnButton = null;
        private System.Windows.Controls.Button toggleTradeSignalButton = null;
        private System.Windows.Controls.Button toggleAutoPilotProfileButton = null;
        private System.Windows.Controls.Button toggleAutoPilotButton = null;
        private System.Windows.Controls.Label riskInfoLabel = null;
        private System.Windows.Controls.Label profitInfoLabel = null;
        private System.Windows.Controls.Label bogeyTargetInfoLabel = null;
        private System.Windows.Controls.Label dayOverMaxLossInfoLabel = null;

        private const string ToggleReverseButtonText = "Rev";
        private const string ToggleReverseButtonToolTip = "Reverse Position";
        private const string ToggleReverseBButtonText = "RevB";
        private const string ToggleReverseBButtonToolTip = "Reverse Blended Positions";
        private const string ToggleCloseButtonText = "Close";
        private const string ToggleCloseButtonToolTip = "Close Position";
        private const string ToggleFlatButtonText = "Flat";
        private const string ToggleFlatButtonToolTip = "Flatten Everything";
        private const string ToggleCloseBButtonText = "CloseB";
        private const string ToggleCloseBButtonToolTip = "Close Blended Positions";
        private const string ToggleTPButtonText = "TP+";
        private const string ToggleTPButtonToolTip = "Take-Profit Jump";
        private const string ToggleBEButtonText = "BE+";
        private const string ToggleBEButtonToolTip = "Break-Even Jump";
        private const string ToggleSLButtonText = "SL+";
        private const string ToggleSLButtonToolTip = "Stop-Loss Jump";
        private const string ToggleBuyMarketButtonText = "Buy";
        private const string ToggleBuyMarketButtonToolTip = "Buy Market";
        private const string ToggleSellMarketButtonText = "Sell";
        private const string ToggleSellMarketButtonToolTip = "Sell Market";
        private const string TogglePopBuyButtonText = "Pop+ {0}";
        private const string TogglePopBuyButtonToolTip = "Pop+ Buy Stop{0}";
        private const string TogglePopSellButtonText = "Pop- {0}";
        private const string TogglePopSellButtonToolTip = "Pop- Sell Stop{0}";

        private const string TogglePopBuyDelayedButtonDisabledText = "Pop+ {0}";
        private const string TogglePopBuyDelayedButtonDisabledToolTip = "Pop+ Buy Stop Delayed Entry{0}";
        private const string TogglePopBuyDelayedButtonCount1Text = "Pop+(1) {0}";
        private const string TogglePopBuyDelayedButtonCount1ToolTip = "Pop+(1) Buy Stop Delayed Entry{0}";
        private const string TogglePopBuyDelayedButtonCount2Text = "Pop+(2) {0}";
        private const string TogglePopBuyDelayedButtonCount2ToolTip = "Pop+(2) Buy Stop Delayed Entry{0}";
        private const string TogglePopBuyDelayedButtonCount3Text = "Pop+(3) {0}";
        private const string TogglePopBuyDelayedButtonCount3ToolTip = "Pop+(3) Buy Stop Delayed Entry{0}";
        private const string TogglePopBuyDelayedButtonCount4Text = "Pop+(4) {0}";
        private const string TogglePopBuyDelayedButtonCount4ToolTip = "Pop+(4) Buy Stop Delayed Entry{0}";
        private const string TogglePopBuyDelayedButtonCount5Text = "Pop+(5) {0}";
        private const string TogglePopBuyDelayedButtonCount5ToolTip = "Pop+(5) Buy Stop Delayed Entry{0}";

        private const string TogglePopSellDelayedButtonDisabledText = "Pop- {0}";
        private const string TogglePopSellDelayedButtonDisabledToolTip = "Pop- Sell Stop Delayed Entry{0}";
        private const string TogglePopSellDelayedButtonCount1Text = "Pop-(1) {0}";
        private const string TogglePopSellDelayedButtonCount1ToolTip = "Pop-(1) Sell Stop Delayed Entry{0}";
        private const string TogglePopSellDelayedButtonCount2Text = "Pop-(2) {0}";
        private const string TogglePopSellDelayedButtonCount2ToolTip = "Pop-(2) Sell Stop Delayed Entry{0}";
        private const string TogglePopSellDelayedButtonCount3Text = "Pop-(3) {0}";
        private const string TogglePopSellDelayedButtonCount3ToolTip = "Pop-(3) Sell Stop Delayed Entry{0}";
        private const string TogglePopSellDelayedButtonCount4Text = "Pop-(4) {0}";
        private const string TogglePopSellDelayedButtonCount4ToolTip = "Pop-(4) Sell Stop Delayed Entry{0}";
        private const string TogglePopSellDelayedButtonCount5Text = "Pop-(5) {0}";
        private const string TogglePopSellDelayedButtonCount5ToolTip = "Pop-(5) Sell Stop Delayed Entry{0}";

        private const string ToggleDropBuyButtonText = "Drop+";
        private const string ToggleDropBuyButtonToolTip = "Drop+ Buy Limit";
        private const string ToggleDropSellButtonText = "Drop-";
        private const string ToggleDropSellButtonToolTip = "Drop- Sell Limit";

        private const string ToggleAutoPPButtonDisabledText = "APP.OFF";
        private const string ToggleAutoPPButtonDisabledToolTip = "Auto Pilot Profile Off";
        private const string ToggleAutoPPPButtonEnabledText = "PEPPY{0}";
        private const string ToggleAutoPPPButtonEnabledToolTip = "Auto Pilot Profile Peppy{0}";
        private const string ToggleAutoPPSButtonEnabledText = "SLEEPY{0}";
        private const string ToggleAutoPPSButtonEnabledToolTip = "Auto Pilot Profile Sleepy{0}";


        private const string ToggleAutoBEButtonDisabledText = "AB.OFF";
        private const string ToggleAutoBEButtonDisabledToolTip = "Auto Break-Even Off";
        private const string ToggleAutoBEButtonEnabledText = "AB.ON";
        private const string ToggleAutoBEButtonEnabledToolTip = "Auto Break-Even On";
        private const string ToggleAutoBEHDLButtonEnabledText = "HODL";
        private const string ToggleAutoBEHDLButtonEnabledToolTip = "HODL";
        private const string ToggleCZFTButtonEnabledText = "CZF+T";
        private const string ToggleCZFTButtonEnabledToolTip = "Creeper & Zombie Flip + Trail";
        private const string ToggleCFTButtonEnabledText = "CF+T";
        private const string ToggleCFTButtonEnabledToolTip = "Creeper Flip + Trail";
        private const string ToggleAutoBETZRButtonEnabledText = "ZF+RT";
        private const string ToggleAutoBETZRButtonEnabledToolTip = "Zombie Flip + Resume Trail";
        private const string ToggleAutoBET5BButtonEnabledText = "AB.T5B{0}";
        private const string ToggleAutoBET5BButtonEnabledToolTip = "Auto Break-Even + Trail 5 Bars{0}";
        private const string ToggleAutoBET3BButtonEnabledText = "AB.T3B{0}";
        private const string ToggleAutoBET3BButtonEnabledToolTip = "Auto Break-Even + Trail 3 Bars{0}";
        private const string ToggleAutoBET2BButtonEnabledText = "AB.T2B{0}";
        private const string ToggleAutoBET2BButtonEnabledToolTip = "Auto Break-Even + Trail 2 Bars{0}";
        private const string ToggleAutoBET1BButtonEnabledText = "AB.T1B{0}";
        private const string ToggleAutoBET1BButtonEnabledToolTip = "Auto Break-Even + Trail 1 Bar{0}";
        private const string ToggleAutoBETMXButtonEnabledText = "AB.TMX{0}";
        private const string ToggleAutoBETMXButtonEnabledToolTip = "Auto Break-Even + Trail Mix{0}";

        private const string ToggleAutoBETSLButtonEnabledText = "AB.TSL{0}";
        private const string ToggleAutoBETSLButtonEnabledToolTip = "Auto Break-Even + Trail SpeedLine ({1}){0}";
        private const string ToggleAutoBETRLButtonEnabledText = "AB.TRL{0}";
        private const string ToggleAutoBETRLButtonEnabledToolTip = "Auto Break-Even + Trail RushLine ({1}){0}";
        private const string ToggleAutoBETM4ButtonEnabledText = "AB.TM4{0}";
        private const string ToggleAutoBETM4ButtonEnabledToolTip = "Auto Break-Even + Trail EMA 4 ({1}){0}";
        private const string ToggleAutoBETM3ButtonEnabledText = "AB.TM3{0}";
        private const string ToggleAutoBETM3ButtonEnabledToolTip = "Auto Break-Even + Trail EMA 3 ({1}){0}";
        private const string ToggleAutoBETM2ButtonEnabledText = "AB.TM2{0}";
        private const string ToggleAutoBETM2ButtonEnabledToolTip = "Auto Break-Even + Trail EMA 2 ({1}){0}";
        private const string ToggleAutoBETM1ButtonEnabledText = "AB.TM1{0}";
        private const string ToggleAutoBETM1ButtonEnabledToolTip = "Auto Break-Even + Trail EMA 1 ({1}){0}";
        private const string ToggleAutoBETD4ButtonEnabledText = "AB.TD4{0}";
        private const string ToggleAutoBETD4ButtonEnabledToolTip = "Auto Break-Even + Trail SMA 4 ({1}){0}";
        private const string ToggleAutoBETD3ButtonEnabledText = "AB.TD3{0}";
        private const string ToggleAutoBETD3ButtonEnabledToolTip = "Auto Break-Even + Trail SMA 3 ({1}){0}";
        private const string ToggleAutoBETD2ButtonEnabledText = "AB.TD2{0}";
        private const string ToggleAutoBETD2ButtonEnabledToolTip = "Auto Break-Even + Trail SMA 2 ({1}){0}";
        private const string ToggleAutoBETD1ButtonEnabledText = "AB.TD1{0}";
        private const string ToggleAutoBETD1ButtonEnabledToolTip = "Auto Break-Even + Trail SMA 1 ({1}){0}";
        private const string ToggleAutoBETR1ButtonEnabledText = "AB.TR1{0}";
        private const string ToggleAutoBETR1ButtonEnabledToolTip = "Auto Break-Even + Trail River 1 ({1}){0}";
        private const string ToggleAutoBETR5ButtonEnabledText = "AB.TR5{0}";
        private const string ToggleAutoBETR5ButtonEnabledToolTip = "Auto Break-Even + Trail River 5 ({1}){0}";

        private const string ToggleAutoBETC1ButtonEnabledText = "AB.TC1{0}";
        private const string ToggleAutoBETC1ButtonEnabledToolTip = "Auto Break-Even + Trail Creek 1 ({1}){0}";
        private const string ToggleAutoBETC5ButtonEnabledText = "AB.TC5{0}";
        private const string ToggleAutoBETC5ButtonEnabledToolTip = "Auto Break-Even + Trail Creek 5 ({1}){0}";

        private const string ToggleAutoBETSButtonEnabledText = "AB.TSR{0}";
        private const string ToggleAutoBETSButtonEnabledToolTip = "Auto Break-Even + Trail Sting Ray{0}";
        private const string ToggleAutoBETXButtonEnabledText = "AB.TX{0}";
        private const string ToggleAutoBETXButtonEnabledToolTip = "Auto Break-Even + Trail X{0}";
        private const string ToggleAutoBETMButtonEnabledText = "AB.TM{0}";
        private const string ToggleAutoBETMButtonEnabledToolTip = "Auto Break-Even + Trail Monster{0}";
        private const string ToggleAutoBETDMButtonEnabledText = "AB.TDM{0}";
        private const string ToggleAutoBETDMButtonEnabledToolTip = "Auto Break-Even + Trail Drift Monster{0}";
        private const string ToggleAutoBETKLDButtonEnabledText = "AB.TKD{0}";
        private const string ToggleAutoBETKLDButtonEnabledToolTip = "Auto Break-Even + Trail KLine Dual ({1}){0}";
        private const string ToggleAutoBETZL2ButtonEnabledText = "AB.TZL{0}";
        private const string ToggleAutoBETZL2ButtonEnabledToolTip = "Auto Break-Even + Trail ZipLine 2 ({1}){0}";
        private const string ToggleAutoBETZLDButtonEnabledText = "AB.TZD{0}";
        private const string ToggleAutoBETZLDButtonEnabledToolTip = "Auto Break-Even + Trail ZipLine Dual ({1}){0}";
        private const string ToggleAutoBETKZDButtonEnabledText = "AB.TKZ{0}";
        private const string ToggleAutoBETKZDButtonEnabledToolTip = "Auto Break-Even + Trail KLine Dual + ZLine Dual ({1}){0}";

        private const string ToggleAutoBEPLButtonEnabledText = "AB.PL{0}";
        private const string ToggleAutoBEPLButtonEnabledToolTip = "Auto Break-Even + Profile Peppy{0}";
        private const string ToggleAutoBEPSButtonEnabledText = "AB.PS{0}";
        private const string ToggleAutoBEPSButtonEnabledToolTip = "Auto Break-Even + Profile Sleepy{0}";

        private const string ToggleAutoCloseButtonDisabledText = "AC.OFF";
        private const string ToggleAutoCloseButtonDisabledToolTip = "Auto Close Off";
        private const string ToggleAutoCloseM1SButtonEnabledText = "AC.M1S{0}";
        private const string ToggleAutoCloseM1SButtonEnabledToolTip = "Auto Close MA 1 Slope{0}";
        private const string ToggleAutoCloseM2SButtonEnabledText = "AC.M2S{0}";
        private const string ToggleAutoCloseM2SButtonEnabledToolTip = "Auto Close MA 2 Slope{0}";
        private const string ToggleAutoCloseM3SButtonEnabledText = "AC.M3S{0}";
        private const string ToggleAutoCloseM3SButtonEnabledToolTip = "Auto Close MA 3 Slope{0}";
        private const string ToggleAutoCloseM4BButtonEnabledText = "AC.M4B{0}";
        private const string ToggleAutoCloseM4BButtonEnabledToolTip = "Auto Close MA 4 Break{0}";
        private const string ToggleAutoCloseDL4BButtonEnabledText = "AC.D4B{0}";
        private const string ToggleAutoCloseDL4BButtonEnabledToolTip = "Auto Close DriftLine 4 Break{0}";
        private const string ToggleAutoCloseKLDFButtonEnabledText = "AC.KD{0}";
        private const string ToggleAutoCloseKLDFButtonEnabledToolTip = "Auto Close KLine Dual Flip{0}";
        private const string ToggleAutoCloseZFButtonEnabledText = "AC.ZF{0}";
        private const string ToggleAutoCloseZFButtonEnabledToolTip = "Auto Close Zombie Flip{0}";
        private const string ToggleAutoCloseZSFButtonEnabledText = "AC.ZSF{0}";
        private const string ToggleAutoCloseZSFButtonEnabledToolTip = "Auto Close Zombie Stacked Flip{0}";
        private const string ToggleAutoCloseZBFButtonEnabledText = "AC.ZBF{0}";
        private const string ToggleAutoCloseZBFButtonEnabledToolTip = "Auto Close Zombie Boosted Flip{0}";
        private const string ToggleAutoCloseCFButtonEnabledText = "AC.CF{0}";
        private const string ToggleAutoCloseCFButtonEnabledToolTip = "Auto Close Creeper Flip{0}";
        private const string ToggleAutoCloseZLDButtonEnabledText = "AC.ZD{0}";
        private const string ToggleAutoCloseZLDButtonEnabledToolTip = "Auto Close ZipLine Dual Flip{0}";
        private const string ToggleAutoCloseKZButtonEnabledText = "AC.KZ{0}";
        private const string ToggleAutoCloseKZButtonEnabledToolTip = "Auto Close KDual + ZDual Flip{0}";

        private const string ToggleAutoClosePLButtonEnabledText = "AC.PL{0}";
        private const string ToggleAutoClosePLButtonEnabledToolTip = "Auto Close Profile Peppy{0}";
        private const string ToggleAutoClosePSButtonEnabledText = "AC.PS{0}";
        private const string ToggleAutoClosePSButtonEnabledToolTip = "Auto Close Profile Sleepy{0}";

        private const string ToggleTradeSignalButtonDisabledText = "S.OFF";
        private const string ToggleTradeSignalButtonDisabledToolTip = "Trade Signal Off";
        private const string ToggleTradeSignalBSAButtonEnabledText = "S.BS.A";
        private const string ToggleTradeSignalBSAButtonEnabledTextToolTip = "Trade Signal All";
        private const string ToggleTradeSignalBSFButtonEnabledText = "S.BS.F";
        private const string ToggleTradeSignalBSFButtonEnabledTextToolTip = "Trade Signal Filtered";
        private const string ToggleTradeSignalBOButtonEnabledText = "S.BO";
        private const string ToggleTradeSignalBOButtonEnabledTextToolTip = "Trade Signal Buy Only";
        private const string ToggleTradeSignalSOButtonEnabledText = "S.SO";
        private const string ToggleTradeSignalSOButtonEnabledTextToolTip = "Trade Signal Sell Only";

        private string ToggleAutoEntryVolOption1ButtonEnabledText = "V(1)";
        private string ToggleAutoEntryVolOption1ButtonEnabledToolTip = "Volume (1)";
        private string ToggleAutoEntryVolOption2ButtonEnabledText = "V(2)";
        private string ToggleAutoEntryVolOption2ButtonEnabledToolTip = "Volume (2)";
        private string ToggleAutoEntryVolOption3ButtonEnabledText = "V(3)";
        private string ToggleAutoEntryVolOption3ButtonEnabledToolTip = "Volume (3)";
        private string ToggleAutoEntryVolOption4ButtonEnabledText = "V(4)";
        private string ToggleAutoEntryVolOption4ButtonEnabledToolTip = "Volume (4)";
        private string ToggleAutoEntryVolOption5ButtonEnabledText = "V(5)";
        private string ToggleAutoEntryVolOption5ButtonEnabledToolTip = "Volume (5)";

        private string ToggleEntryVolMaxOption1ButtonEnabledText = "VM(1)";
        private string ToggleEntryVolMaxOption1ButtonEnabledToolTip = "Volume Max (1)";
        private string ToggleEntryVolMaxOption2ButtonEnabledText = "VM(2)";
        private string ToggleEntryVolMaxOption2ButtonEnabledToolTip = "Volume Max (2)";
        private string ToggleEntryVolMaxOption3ButtonEnabledText = "VM(3)";
        private string ToggleEntryVolMaxOption3ButtonEnabledToolTip = "Volume Max (3)";
        private string ToggleEntryVolMaxOption4ButtonEnabledText = "VM(4)";
        private string ToggleEntryVolMaxOption4ButtonEnabledToolTip = "Volume Max (4)";
        private string ToggleEntryVolMaxOption5ButtonEnabledText = "VM(5)";
        private string ToggleEntryVolMaxOption5ButtonEnabledToolTip = "Volume Max (5)";

        private const string ToggleAutoPilotLiteButtonDisabledText = "APL.OFF";
        private const string ToggleAutoPilotLiteButtonDisabledToolTip = "Auto Pilot Lite Off";
        private const string ToggleAutoPilotLiteNext1ButtonEnabledText = "APL.N(1){0}";
        private const string ToggleAutoPilotLiteNext1ButtonEnabledToolTip = "Auto Pilot Lite Next Trade 1{0}";
        private const string ToggleAutoPilotLiteNextFiltered1ButtonEnabledText = "APL.F(1){0}";
        private const string ToggleAutoPilotLiteNextFiltered1ButtonEnabledToolTip = "Auto Pilot Lite Next Filtered Trade 1{0}";
        private const string ToggleAutoPilotLiteBuy1ButtonEnabledText = "APL.B(1){0}";
        private const string ToggleAutoPilotLiteBuy1ButtonEnabledToolTip = "Auto Pilot Lite Buy Trade 1{0}";
        private const string ToggleAutoPilotLiteSell1ButtonEnabledText = "APL.S(1){0}";
        private const string ToggleAutoPilotLiteSell1ButtonEnabledToolTip = "Auto Pilot Lite Sell Trade 1{0}";
        private const string ToggleAutoPilotLiteAlertButtonEnabledText = "APL.Alert{0}";
        private const string ToggleAutoPilotLiteAlertButtonEnabledToolTip = "Auto Pilot Lite Alert Setups{0}";

        private const string ToggleAutoPilotButtonDisabledText = "AP.OFF";
        private const string ToggleAutoPilotButtonDisabledToolTip = "Auto Pilot Off";
        private const string ToggleAutoPilotCount1ButtonEnabledText = "AP.T(1){0}";
        private const string ToggleAutoPilotCount1ButtonEnabledToolTip = "Auto Pilot Trade 1{0}";
        private const string ToggleAutoPilotCount2ButtonEnabledText = "AP.T(2){0}";
        private const string ToggleAutoPilotCount2ButtonEnabledToolTip = "Auto Pilot Trade 2{0}";
        private const string ToggleAutoPilotCount3ButtonEnabledText = "AP.T(3){0}";
        private const string ToggleAutoPilotCount3ButtonEnabledToolTip = "Auto Pilot Trade 3{0}";
        private const string ToggleAutoPilotCount4ButtonEnabledText = "AP.T(4){0}";
        private const string ToggleAutoPilotCount4ButtonEnabledToolTip = "Auto Pilot Trade 4{0}";
        private const string ToggleAutoPilotCount5ButtonEnabledText = "AP.T(5){0}";
        private const string ToggleAutoPilotCount5ButtonEnabledToolTip = "Auto Pilot Trade 5{0}";
        private const string ToggleAutoPilotCount6ButtonEnabledText = "AP.T(6){0}";
        private const string ToggleAutoPilotCount6ButtonEnabledToolTip = "Auto Pilot Trade 6{0}";
        private const string ToggleAutoPilotCount7ButtonEnabledText = "AP.T(7){0}";
        private const string ToggleAutoPilotCount7ButtonEnabledToolTip = "Auto Pilot Trade 7{0}";
        private const string ToggleAutoPilotCount8ButtonEnabledText = "AP.T(8){0}";
        private const string ToggleAutoPilotCount8ButtonEnabledToolTip = "Auto Pilot Trade 8{0}";
        private const string ToggleAutoPilotCount9ButtonEnabledText = "AP.T(9){0}";
        private const string ToggleAutoPilotCount9ButtonEnabledToolTip = "Auto Pilot Trade 9{0}";
        private const string ToggleAutoPilotCount10ButtonEnabledText = "AP.T(10){0}";
        private const string ToggleAutoPilotCount10ButtonEnabledToolTip = "Auto Pilot Trade 10{0}";

        private const string ToggleAutoAddOnButtonDisabledText = "AA.OFF";
        private const string ToggleAutoAddOnButtonDisabledToolTip = "Auto AddOn Off (${0})";
        private const string ToggleAutoAddOnButtonEnabledText = "AA.ON";
        private string ToggleAutoAddOnButtonEnabledToolTip = "Auto AddOn On (${0})";

        private const string ToggleProfitTargetButtonDisabledText = "PT.OFF";
        private const string ToggleProfitTargetButtonDisabledToolTip = "Profit Target Off";
        private const string ToggleProfitTargetECAButtonEnabledText = "ECAT";
        private const string ToggleProfitTargetECAButtonEnabledToolTip = "Equity Close All Target";
        private const string ToggleProfitTargetX0ButtonEnabledText = "BT.X{0}{1}";
        private const string ToggleProfitTargetX0ButtonEnabledToolTip = "Bogey Target X{0}{1}";

        private const string HHToggleAutoBEButtonName = "HHToggleAutoBEButton";
        private const string HHCloseAllButtonName = "HHCloseAllButton";
        private const string HHToggleAutoCloseButtonName = "HHToggleAutoCloseButton";
        private const string HHToggleEntryVolumeAutoButtonName = "HHToggleEntryVolumeAutoButton";
        private const string HHToggleEntryVolumeMaxButtonName = "HHToggleEntryVolumeMaxButton";
        private const string HHToggleTradeSignalButtonName = "HHToggleTradeSignalButton";
        private const string HHToggleAutoPilotButtonName = "HHToggleAutoPilotButton";
        private const string HHToggleAutoPilotProfileButtonName = "HHToggleAutoPilotProfileButton";
        private const string HHToggleAutoAddOnButtonName = "HHToggleAutoAddOnButton";
        private const string HHToggleProfitTargetButtonName = "HHToggleProfitTargetButton";
        private const string HHBEButtonName = "HHBEButton";
        private const string HHSLButtonName = "HHSLButton";
        private const string HHTPButtonName = "HHTPButton";
        private const string HHRevButtonName = "HHRevButton";
        private const string HHBuyDropButtonName = "HHBDropButton";
        private const string HHSellDropButtonName = "HHSDropButton";
        private const string HHBuyPopButtonName = "HHBPopButton";
        private const string HHSellPopButtonName = "HHSPopButton";
        private const string HHBuyMarketButtonName = "HHBMarketButton";
        private const string HHSellMarketButtonName = "HHSMarketButton";
        private const string HHRiskInfoLabelName = "HHRILabel";
        private const string HHProfitInfoLabelName = "HHPILabel";
        private const string HHBogeyTargetInfoLabelName = "HHBTILabel";
        private const string HHDayOverMaxLossInfoLabelName = "HHDOMLILabel";


        private const double MIN_EXCESS_MARGIN = 25;
        private const int MICRO_TO_EMINI_MULTIPLIER = 10;
        private const int DEFAULT_VOLUME_SIZE = 1;

        private DateTime lastFlattenEverythingCycleChangeTime = DateTime.MinValue;
        private const int FlattenEverythingThrottleSeconds = 1;

        private const int BogeyTargetLineChangePlotIndex = 0;
        private Brush bogeyTargetLineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetLineDashStyle;
        private int bogeyTargetLineWidth = 1;
        private double bogeyTargetMultiplier = 1;
        private bool bogeyTargetStartWithFullPnLFlag = true;
        private int maxInitialTrancheVolumeSize = DEFAULT_VOLUME_SIZE;

        private const int BogeyTargetBreakEvenLineChangePlotIndex = 1;
        private Brush bogeyTargetBreakEvenLineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetBreakEvenLineDashStyle;
        private int bogeyTargetBreakEvenLineWidth = 1;
        private bool bogeyTargetBreakEvenLineIsBrushTransparent = false;

        private const int BogeyTargetDaily1LineChangePlotIndex = 2;
        private Brush bogeyTargetDaily1LineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetDaily1LineDashStyle;
        private int bogeyTargetDaily1LineWidth = 1;
        private bool bogeyTargetDaily1LineIsBrushTransparent = false;

        private const int BogeyTargetDaily2LineChangePlotIndex = 3;
        private Brush bogeyTargetDaily2LineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetDaily2LineDashStyle;
        private int bogeyTargetDaily2LineWidth = 1;
        private bool bogeyTargetDaily2LineIsBrushTransparent = false;

        private const int BogeyTargetDaily3LineChangePlotIndex = 4;
        private Brush bogeyTargetDaily3LineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetDaily3LineDashStyle;
        private int bogeyTargetDaily3LineWidth = 1;
        private bool bogeyTargetDaily3LineIsBrushTransparent = false;

        private const int BogeyTargetDaily4LineChangePlotIndex = 5;
        private Brush bogeyTargetDaily4LineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetDaily4LineDashStyle;
        private int bogeyTargetDaily4LineWidth = 1;
        private bool bogeyTargetDaily4LineIsBrushTransparent = false;

        private const int BogeyTargetDaily5LineChangePlotIndex = 6;
        private Brush bogeyTargetDaily5LineBrush = Brushes.Transparent;
        private DashStyleHelper bogeyTargetDaily5LineDashStyle;
        private int bogeyTargetDaily5LineWidth = 1;
        private bool bogeyTargetDaily5LineIsBrushTransparent = false;

        private const int DayOverMaxLossLineChangePlotIndex = 7;
        private Brush dayOverMaxLossInfoTextColor = Brushes.Silver;
        private Brush dayOverMaxLossLineBrush = Brushes.Transparent;
        private DashStyleHelper dayOverMaxLossLineDashStyle;
        private int dayOverMaxLossLineWidth = 1;

        private const int DayOverAccountBalanceFloorLineChangePlotIndex = 8;
        private Brush dayOverAccountBalanceFloorLineBrush = Brushes.Transparent;
        private DashStyleHelper dayOverAccountBalanceFloorLineDashStyle;
        private int dayOverAccountBalanceFloorLineWidth = 1;

        private const int ECATakeProfitLineChangePlotIndex = 9;
        private Brush ecaTakeProfitLineBrush = Brushes.Transparent;
        private DashStyleHelper ecaTakeProfitLineDashStyle;
        private int ecaTakeProfitLineWidth = 1;

        private const int AveragePriceLineChangePlotIndex = 10;
        private Brush averagePriceLineBrush = Brushes.Transparent;
        private DashStyleHelper averagePriceLineDashStyle;
        private int averagePriceLineWidth = 1;
        private double averagePriceLevelHorizontalOffset = 50;
        private bool averagePriceLineIsBrushTransparent = false;

        private TickHunterEntryVolumeAutoTypes currentEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;
        private TickHunterEntryVolumeAutoTypes lastToggleEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;
        private TickHunterEntryVolumeAutoTypes nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;
        private DateTime lastEntryVolumeAutoChangeTime = DateTime.MinValue;
        private const int EntryVolumeAutoColorDelaySeconds = 1;

        private TickHunterEntryVolumeMaxTypes currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
        private TickHunterEntryVolumeMaxTypes lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
        private TickHunterEntryVolumeMaxTypes nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
        private DateTime lastEntryVolumeMaxChangeTime = DateTime.MinValue;
        private const int EntryVolumeMaxColorDelaySeconds = 1;

        private TickHunterTradeSignalTypes currentTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
        private TickHunterTradeSignalTypes lastToggleEntryTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
        private TickHunterTradeSignalTypes nextTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
        private DateTime lastTradeSignalChangeTime = DateTime.MinValue;
        private const int TradeSignalColorDelaySeconds = 5;

        private TickHunterAutoPilotTypes currentAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
        private TickHunterAutoPilotTypes lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
        private TickHunterAutoPilotTypes nextAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
        private DateTime lastAutoPilotChangeTime = DateTime.MinValue;
        private const int AutoPilotColorDelaySeconds = 1;
        private bool useAutoPilotAddOnFlag = true;

        private TickHunterAutoPilotOrderTypes currentAutoPilotOrderStatus = TickHunterAutoPilotOrderTypes.Market;

        private TickHunterAutoPilotLiteTypes currentAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
        private TickHunterAutoPilotLiteTypes lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
        private TickHunterAutoPilotLiteTypes nextAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
        private DateTime lastAutoPilotLiteChangeTime = DateTime.MinValue;
        private const int AutoPilotLiteColorDelaySeconds = 3;
        private bool isTradeAlertMessageBoxOpen = false;

        private TickHunterAutoAddOnTypes currentAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled;
        private TickHunterAutoAddOnTypes lastToggleEntryAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled;
        private TickHunterAutoAddOnTypes nextAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled;
        private DateTime lastAutoAddOnChangeTime = DateTime.MinValue;
        private const int AutoAddOnColorDelaySeconds = 3;
        private const int AutoAddOnInnerWindowDelaySeconds = 5;
        const double DEFAULT_ADDON_MAX_DOLLARS = 1;
        double autoAddOnMaxDollars = DEFAULT_ADDON_MAX_DOLLARS;

        private DateTime lastAddOnMaxCycleChangeTime = DateTime.MinValue;
        private const int AutoAddOnMaxCycleDelaySeconds = 5;

        private TickHunterCloseAutoTypes currentCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;
        private TickHunterCloseAutoTypes lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;
        private TickHunterCloseAutoTypes nextCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;
        private DateTime lastCloseAutoChangeTime = DateTime.MinValue;
        private const int CloseAutoColorDelaySeconds = 5;
        private bool closeAutoMinProfitFlag = false;
        private bool closeAutoAlertFlag = false;

        private TickHunterBreakEvenAutoTypes currentBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;
        private TickHunterBreakEvenAutoTypes lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;
        private TickHunterBreakEvenAutoTypes nextBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;
        private DateTime lastBreakEvenAutoChangeTime = DateTime.MinValue;
        private const int BeakEvenAutoColorDelaySeconds = 5;
        private bool breakEvenAutoHODLFlag = false;
        private TickHunterBreakEvenAutoTrailNowTypes breakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.Disabled;

        private TickHunterAutoPilotSetupTypes currentAutoPilotSetupStatus = TickHunterAutoPilotSetupTypes.ZombieOnly;

        private TickHunterAutoPilotProfileTypes currentAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Disabled;
        private TickHunterAutoPilotProfileTypes lastToggleAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Disabled;
        private TickHunterAutoPilotProfileTypes nextAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Disabled;
        private DateTime lastAutoPilotProfileChangeTime = DateTime.MinValue;
        private const int AutoPilotProfileColorDelaySeconds = 3;
        private bool autoPilotProfileAutoAdjustFlag = false;

        private TickHunterAutoPilotProfileSetupTypes currentAutoPilotProfileSetupStatus = TickHunterAutoPilotProfileSetupTypes.ZombieOrCreeperCombo;

        private TickHunterProfitTargetTypes currentProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;
        private TickHunterProfitTargetTypes lastToggleProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;
        private TickHunterProfitTargetTypes nextProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;
        private const int BogeyTargetMultiplierDisabled = 0;
        private int currentBogeyTargetMultiplier = BogeyTargetMultiplierDisabled;
        private int lastToggleEntryBogeyTargetMultiplier = BogeyTargetMultiplierDisabled;
        private int nextBogeyTargetMultiplier = BogeyTargetMultiplierDisabled;
        private DateTime lastProfitTargetChangeTime = DateTime.MinValue;
        private const int BogeyTargetColorDelaySeconds = 5;

        private bool useBuyPopActivateFlag = false;
        private DateTime lastBuyPopActivateChangeTime = DateTime.MinValue;
        private bool useSellPopActivateFlag = false;
        private DateTime lastSellPopActivateChangeTime = DateTime.MinValue;

        private bool popCTRLDelayedEntryFlag = true;
        private int popDelayedEntryMaxCountFlag = 1;

        private TickHunterPopDelayedTypes currentBuyPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
        private TickHunterPopDelayedTypes lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
        private TickHunterPopDelayedTypes nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
        private DateTime lastBuyPopDelayedChangeTime = DateTime.MinValue;

        private TickHunterPopDelayedTypes currentSellPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
        private TickHunterPopDelayedTypes lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
        private TickHunterPopDelayedTypes nextSellPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
        private DateTime lastSellPopDelayedChangeTime = DateTime.MinValue;

        private const int PopActivateColorDelaySeconds = 1;

        private TickHunterStopLossSnapTypes currentStopLossInitialSnapStatus = TickHunterStopLossSnapTypes.Disabled;

        //private string HedgehogEntrySymbol1FullName = "";
        //private string HedgehogEntrySymbol2FullName = "";

        private Instrument attachedInstrument = null;
        private bool attachedInstrumentIsEmini = false;
        private bool attachedInstrumentIsFuture = false;
        private bool attachedInstrumentServerSupported = false;
        private double attachedInstrumentTickSize = 0;
        private double attachedInstrumentTickValue = 0;
        private int attachedInstrumentTicksPerPoint = 0;
        private double attachedInstrumentCommissionPerSide = 0;
        private int attachedInstrumentPositionMaxVolume = 0;
        private double attachedInstrumentIntradayMarginDollars = 0;

        private EMA autoCloseAndTrailMA1Buffer;
        private EMA autoCloseAndTrailMA2Buffer;
        private EMA autoCloseAndTrailMA3Buffer;
        private EMA autoCloseAndTrailMA4Buffer;
        private EMA autoCloseAndTrailR1HBuffer;
        private EMA autoCloseAndTrailR1LBuffer;
        private EMA autoCloseAndTrailR5HBuffer;
        private EMA autoCloseAndTrailR5LBuffer;
        private HMA autoCloseAndTrailZL1Buffer;
        private HMA autoCloseAndTrailZL2Buffer;
        private SMA autoCloseAndTrailRLBuffer;
        private SMA autoCloseAndTrailDL1Buffer;
        private SMA autoCloseAndTrailDL2Buffer;
        private SMA autoCloseAndTrailDL3Buffer;
        private SMA autoCloseAndTrailDL4Buffer;

        private SMA autoCloseAndTrailDL3HBuffer;
        private SMA autoCloseAndTrailDL3LBuffer;
        private SMA autoCloseAndTrailDL4HBuffer;
        private SMA autoCloseAndTrailDL4LBuffer;

        private double autoPilotSetupCreeperValue;
        private double autoPilotSetupCreeperValue2;
        private double autoPilotSetupCreeperValue3;
        private double autoPilotSetupCreeperValue4;
        private double autoPilotSetupCreeperValue5;
        private double autoPilotSetupCreeperValue6;
        private double autoPilotSetupCreeperValue7;
        private double autoPilotSetupCreeperValue8;
        private double autoPilotSetupCreeperValue9;
        private double autoPilotSetupCreeperValue10;

        private double recentCreeperBuyHighPrice = 0;
        private double recentCreeperBuyLowPrice = 0;
        private double recentCreeperSellHighPrice = 0;
        private double recentCreeperSellLowPrice = 0;

        private bool autoPilotSetupCreeperBuyContinuation1;
        private bool autoPilotSetupCreeperSellContinuation1;

        private double autoCloseAndTrailMA1Value;
        private double autoCloseAndTrailMA1Value2;
        private double autoCloseAndTrailMA1Value3;

        private double autoCloseAndTrailMA2Value;
        private double autoCloseAndTrailMA2Value2;
        private double autoCloseAndTrailMA2Value3;

        private double autoCloseAndTrailMA3Value;
        private double autoCloseAndTrailMA3Value2;
        private double autoCloseAndTrailMA3Value3;

        private double autoCloseAndTrailMA4Value;
        private double autoCloseAndTrailMA4Value2;
        private double autoCloseAndTrailMA4Value3;
        private double autoCloseAndTrailMA4Value4;
        private double autoCloseAndTrailMA4Value5;
        private double autoCloseAndTrailMA4Value6;
        private double autoCloseAndTrailMA4Value7;
        private double autoCloseAndTrailMA4Value8;
        private double autoCloseAndTrailMA4Value9;
        private double autoCloseAndTrailMA4Value10;

        private double autoCloseAndTrailR1HValue;
        private double autoCloseAndTrailR1LValue;

        private double autoCloseAndTrailR5HValue;
        private double autoCloseAndTrailR5LValue;

        private double autoCloseAndTrailZL1Value;
        private double autoCloseAndTrailZL2Value;

        private double autoCloseAndTrailRLValue;
        private double autoCloseAndTrailRLValue2;
        private double autoCloseAndTrailRLValue3;
        private double autoCloseAndTrailRLValue4;

        private double autoCloseAndTrailDL1Value;
        private double autoCloseAndTrailDL2Value;
        private double autoCloseAndTrailDL3Value;

        private double autoCloseAndTrailDL4Value;
        private double autoCloseAndTrailDL4Value2;
        private double autoCloseAndTrailDL4Value3;
        private double autoCloseAndTrailDL4Value4;
        private double autoCloseAndTrailDL4Value5;
        private double autoCloseAndTrailDL4Value6;
        private double autoCloseAndTrailDL4Value7;
        private double autoCloseAndTrailDL4Value8;
        private double autoCloseAndTrailDL4Value9;
        private double autoCloseAndTrailDL4Value10;
        private double autoCloseAndTrailDL4Value11;
        private double autoCloseAndTrailDL4Value12;
        private double autoCloseAndTrailDL4Value13;
        private double autoCloseAndTrailDL4Value14;
        private double autoCloseAndTrailDL4Value15;

        private double autoCloseAndTrailDL3HValue;
        private double autoCloseAndTrailDL3LValue;

        private double autoCloseAndTrailDL4HValue;
        private double autoCloseAndTrailDL4LValue;

        private THStingRay stingRayBuffer;

        private double stingRayHighLevel1Value;
        private double stingRayHighLevel2Value;
        private double stingRayHighLevel3Value;
        private double stingRayHighLevel4Value;
        private double stingRayHighLevel5Value;

        private double stingRayLowLevel1Value;
        private double stingRayLowLevel2Value;
        private double stingRayLowLevel3Value;
        private double stingRayLowLevel4Value;
        private double stingRayLowLevel5Value;

        private double stingRayRecentHigherHighValue;
        private double stingRayRecentLowerLowValue;

        private double stingRayCreeperCycleCountValue;
        private double stingRaySurgeBarCountValue;
        private double stingRaySurgeBarCycleTickSpeedValue;
        private double stingRayGush1BarCountValue;
        private double stingRayGush1BarCycleTickSpeedValue;

        private double stingRayFlow1BarCountValue;
        private double stingRayFlow1BarCycleTickSpeedValue;
        private double stingRayFlow2BarCountValue;
        private double stingRayFlow2BarCycleTickSpeedValue;
        private double stingRayFlow3BarCountValue;
        private double stingRayFlow3BarCycleTickSpeedValue;
        private double stingRayFlow4BarCountValue;
        private double stingRayFlow4BarCycleTickSpeedValue;


        private THPowerBox snapPowerBoxBuffer;
        private double snapPowerBoxMiddleValue;
        private double snapPowerBoxUpperValue;
        private double snapPowerBoxUpperValue10;
        private double snapPowerBoxUpperValue20;
        private double snapPowerBoxUpperValue30;
        private double snapPowerBoxUpperValue40;
        private double snapPowerBoxUpperValue50;
        private double snapPowerBoxLowerValue;
        private double snapPowerBoxLowerValue10;
        private double snapPowerBoxLowerValue20;
        private double snapPowerBoxLowerValue30;
        private double snapPowerBoxLowerValue40;
        private double snapPowerBoxLowerValue50;

        private THKeltnerATR keltnerATRBuffer;

        private double keltnerUpperInnerRingValue;
        private double keltnerLowerInnerRingValue;

        private int KeltnerPeriod = 21;
        private int KeltnerATRPeriod = 21;
        private double KeltnerOffsetMultiplier1 = 2;
        private double KeltnerOffsetMultiplier2 = 3;
        private double KeltnerOffsetMultiplier3 = 2;
        private double KeltnerOffsetMultiplier4 = 3;

        private EMA autoPilotSetupWalkerBuffer;
        private double autoPilotSetupWalkerValue;
        private double autoPilotSetupWalkerValue2;

        private EMA autoPilotSpeedLineFilterBuffer;
        private double autoPilotSpeedLineFilterValue;
        private double autoPilotSpeedLineFilterValue2;
        private double autoPilotSpeedLineFilterValue3;
        private double autoPilotSpeedLineFilterValue4;
        private double autoPilotSpeedLineFilterValue5;
        private double autoPilotSpeedLineFilterValue6;
        private double autoPilotSpeedLineFilterValue7;
        private double autoPilotSpeedLineFilterValue8;
        private double autoPilotSpeedLineFilterValue9;
        private double autoPilotSpeedLineFilterValue10;

        private EMA autoPilotFilterBuffer;

        bool autoPilotBullishTrend = true;
        bool autoPilotBullishDriftTrend = true;
        bool autoPilotBullishRiverTrend = true;

        private THZombieSetup autoPilotSetupZombieBuffer;
        private THZombieSetup autoPilotSetupZombie2Buffer;
        private THCreeperSetup autoPilotSetupCreeperBuffer;

        private double autoPilotSetupZombieValue;
        private double autoPilotSetupZombieValue2;
        private double autoPilotSetupZombieValue3;
        private double autoPilotSetupZombieValue4;
        private double autoPilotSetupZombieValue5;
        private double autoPilotSetupZombieValue6;
        private double autoPilotSetupZombieValue7;
        private double autoPilotSetupZombieValue8;
        private double autoPilotSetupZombieValue9;
        private double autoPilotSetupZombieValue10;

        private bool autoPilotSetupZombieBuyContinuation1;
        private bool autoPilotSetupZombieBuyContinuation2;
        private bool autoPilotSetupZombieBuyContinuation3;
        private bool autoPilotSetupZombieBuyContinuation4;
        private bool autoPilotSetupZombieBuyContinuation5;
        private bool autoPilotSetupZombieBuyContinuation6;
        private bool autoPilotSetupZombieBuyContinuation7;
        private bool autoPilotSetupZombieBuyContinuation8;

        private bool autoPilotSetupZombieSellContinuation1;
        private bool autoPilotSetupZombieSellContinuation2;
        private bool autoPilotSetupZombieSellContinuation3;
        private bool autoPilotSetupZombieSellContinuation4;
        private bool autoPilotSetupZombieSellContinuation5;
        private bool autoPilotSetupZombieSellContinuation6;
        private bool autoPilotSetupZombieSellContinuation7;
        private bool autoPilotSetupZombieSellContinuation8;

        private bool autoPilotSetupZombie2BuyContinuation1;
        private bool autoPilotSetupZombie2SellContinuation1;

        private bool autoPilotSetupZombieBuySetup1;
        private bool autoPilotSetupZombieSellSetup1;
        private bool autoPilotSetupZombieBuySetup2;
        private bool autoPilotSetupZombieSellSetup2;
        private bool autoPilotSetupZombieBuySetup3;
        private bool autoPilotSetupZombieSellSetup3;
        private bool autoPilotSetupZombieBuySetup4;
        private bool autoPilotSetupZombieSellSetup4;
        private bool autoPilotSetupZombieBuySetup5;
        private bool autoPilotSetupZombieSellSetup5;
        private bool autoPilotSetupZombieBuySetup6;
        private bool autoPilotSetupZombieSellSetup6;
        private bool autoPilotSetupZombieBuySetup7;
        private bool autoPilotSetupZombieSellSetup7;
        private bool autoPilotSetupZombieBuySetup8;
        private bool autoPilotSetupZombieSellSetup8;
        private bool autoPilotSetupZombieBuySetup9;
        private bool autoPilotSetupZombieSellSetup9;

        private double recentZombieBuyHighPrice = 0;
        private double recentZombieBuyLowPrice = 0;
        private double recentZombieSellHighPrice = 0;
        private double recentZombieSellLowPrice = 0;

        private THZombieSetup autoCloseAndTrailKLine1Buffer;
        private double autoCloseAndTrailKLine1Value;

        private THZombieSetup autoCloseAndTrailKLine2Buffer;
        private double autoCloseAndTrailKLine2Value;


        private Instrument mnqInstrument = null;
        private Instrument mesInstrument = null;
        private Instrument mymInstrument = null;
        private Instrument m2kInstrument = null;
        private Instrument nqInstrument = null;
        private Instrument esInstrument = null;
        private Instrument ymInstrument = null;
        private Instrument rtyInstrument = null;
        private double mymLastAsk = 0;
        private double mymLastBid = 0;
        private double mesLastAsk = 0;
        private double mesLastBid = 0;
        private double m2kLastAsk = 0;
        private double m2kLastBid = 0;
        private double mnqLastAsk = 0;
        private double mnqLastBid = 0;
        private int marketDataBidAskPulseStatus = 0;
        private int marketDataBidAskChangeStatus = 0;
        private const string MNQPrefix = "MNQ";
        private const string MESPrefix = "MES";
        private const string MYMPrefix = "MYM";
        private const string M2KPrefix = "M2K";

        private double ymLastAsk = 0;
        private double ymLastBid = 0;
        private double esLastAsk = 0;
        private double esLastBid = 0;
        private double rtyLastAsk = 0;
        private double rtyLastBid = 0;
        private double nqLastAsk = 0;
        private double nqLastBid = 0;
        private const string NQPrefix = "NQ";
        private const string ESPrefix = "ES";
        private const string YMPrefix = "YM";
        private const string RTYPrefix = "RTY";

        private double maxDDInDollars = 0;
        private double lastAccountBalanceFloorDollars = 0;

        private bool validateAttachedPositionStopLossQuantityStage1 = false;
        private bool validateAttachedPositionTakeProfitQuantityStage1 = false;
        private bool validateBlendedPositionStopLossQuantityStage1 = false;
        private bool validateBlendedPositionTakeProfitQuantityStage1 = false;

        private bool validateAttachedPositionStopLossQuantity = false;
        private bool validateAttachedPositionTakeProfitQuantity = false;
        private bool validateBlendedPositionStopLossQuantity = false;
        private bool validateBlendedPositionTakeProfitQuantity = false;

        private bool riskInfoHasChanged = false;
        private MarketPosition riskInfoMarketPosition = MarketPosition.Flat;
        private int riskInfoQuantity = 0;
        private double riskInfoPositionPrice = 0;

        private bool profitInfoHasChanged = false;
        private MarketPosition profitInfoMarketPosition = MarketPosition.Flat;
        private int profitInfoQuantity = 0;
        private double profitInfoPositionPrice = 0;

        private double dayOverMaxLossDollars = 0;
        private bool dayOverMaxLossHasChanged = false;
        private MarketPosition dayOverMaxLossMarketPosition = MarketPosition.Flat;
        private int dayOverMaxLossPositionQuantity = 0;
        private double dayOverMaxLossPositionPrice = 0;
        private double dayOverMaxAccountPnLPeakDollars = 0;
        private double lastDayOverMaxLossAccountPnLPeakInfoDollars = 0;
        private string lastDayOverMaxAccountPnLPeakLabelText = "";
        //private DateTime lastDayOverMaxLossHighestPnLInSessionChangeDate = DateTime.MinValue;
        //private double lastDayOverMaxLossHighestPnLInSessionPnL = 0;
        private double lastDayOverMaxLossInfoDollars = 0;
        private string lastDayOverMaxLossLabelText = "";
        private double lastDayOverMaxLossDollars = 0;
        private MarketPosition lastDayOverMaxLossPositionType = MarketPosition.Flat;
        private double lastDayOverMaxLossClosedOrderProfit = 0;
        private double lastDayOverMaxLossPositionPrice = 0;
        private int lastDayOverMaxLossPositionQuantity = 0;
        private double lastDayOverMaxLossLinePrice = 0;
        private bool activeDayOverMaxLossAutoClose = false;
        private bool dayOverMaxLossLineVisible = false;

        private bool bogeyTargetHasChanged = false;
        private MarketPosition bogeyTargetMarketPosition = MarketPosition.Flat;
        private int bogeyTargetPositionQuantity = 0;
        private double bogeyTargetPositionPrice = 0;
        private double lastBogeyTargetInfoDollars = 0;
        private double lastBogeyTargetBaseDollars = 0;
        private MarketPosition lastBogeyTargetPositionType = MarketPosition.Flat;
        private double lastBogeyTargetClosedOrderProfit = 0;
        private double lastBogeyTargetPositionPrice = 0;
        private int lastBogeyTargetPositionQuantity = 0;
        private double lastBogeyTargetLinePrice = 0;
        private bool bogeyTargetLineVisible = false;

        private bool bogeyTargetBreakEvenLineVisible = false;
        private double lastBogeyTargetBreakEvenDollars = 0;
        private double lastBogeyTargetBreakEvenLinePrice = 0;

        private bool bogeyTargetDaily1LineVisible = false;
        private double lastBogeyTargetDaily1Dollars = 0;
        private double lastBogeyTargetDaily1LinePrice = 0;

        private bool bogeyTargetDaily2LineVisible = false;
        private double lastBogeyTargetDaily2Dollars = 0;
        private double lastBogeyTargetDaily2LinePrice = 0;

        private bool bogeyTargetDaily3LineVisible = false;
        private double lastBogeyTargetDaily3Dollars = 0;
        private double lastBogeyTargetDaily3LinePrice = 0;

        private bool bogeyTargetDaily4LineVisible = false;
        private double lastBogeyTargetDaily4Dollars = 0;
        private double lastBogeyTargetDaily4LinePrice = 0;

        private bool bogeyTargetDaily5LineVisible = false;
        private double lastBogeyTargetDaily5Dollars = 0;
        private double lastBogeyTargetDaily5LinePrice = 0;


        private bool dayOverAccountBalanceFloorHasChanged = false;
        private MarketPosition dayOverAccountBalanceFloorMarketPosition = MarketPosition.Flat;
        private int dayOverAccountBalanceFloorPositionQuantity = 0;
        private double dayOverAccountBalanceFloorPositionPrice = 0;
        private double lastDayOverAccountBalanceFloorInfoDollars = 0;
        private double lastDayOverAccountBalanceFloorDollars = 0;
        private MarketPosition lastDayOverAccountBalanceFloorPositionType = MarketPosition.Flat;
        private double lastDayOverAccountBalanceFloorPositionPrice = 0;
        private int lastDayOverAccountBalanceFloorPositionQuantity = 0;
        private double lastDayOverAccountBalanceFloorLinePrice = 0;
        private double lastDayOverAccountBalance = 0;
        private double lastDayOverAccountFloorInfoDollars = 0;
        private string lastDayOverAccountFloorLabelText = "";
        private DateTime lastDayOverAccountBalanceRefreshTime = DateTime.MinValue;
        private const int DayOverAccountBalanceRefreshDelaySeconds = 10;
        private bool dayOverAccountBalanceFloorLineVisible = false;

        private double cacheECATakeProfitDollars = 0;
        private bool ecaTakeProfitHasChanged = false;
        private MarketPosition ecaTakeProfitMarketPosition = MarketPosition.Flat;
        private int ecaTakeProfitPositionQuantity = 0;
        private double ecaTakeProfitPositionPrice = 0;
        private double lastECATakeProfitInfoDollars = 0;
        private double lastECATakeProfitDollars = 0;
        private MarketPosition lastECATakeProfitPositionType = MarketPosition.Flat;
        private double lastECATakeProfitClosedOrderProfit = 0;
        private double lastECATakeProfitPositionPrice = 0;
        private int lastECATakeProfitPositionQuantity = 0;
        private double lastECATakeProfitLinePrice = 0;
        private bool ecaTakeProfitLineVisible = false;

        private bool averagePriceHasChanged = false;
        private MarketPosition averagePriceMarketPosition = MarketPosition.Flat;
        private int averagePricePositionQuantity = 0;
        private double averagePricePositionPrice = 0;
        private double lastAveragePriceInfoDollars = 0;
        private double lastAveragePriceDollars = 0;
        private MarketPosition lastAveragePricePositionType = MarketPosition.Flat;
        private double lastAveragePriceClosedOrderProfit = 0;
        private double lastAveragePricePositionPrice = 0;
        private int lastAveragePricePositionQuantity = 0;
        private double lastAveragePriceLinePrice = 0;
        private bool averagePriceLineVisible = false;

        private bool attachedInstrumentHasChanged = false;
        private bool attachedInstrumentHasPosition = false;
        private int attachedInstrumentPositionBarCount = 0;
        private double attachedInstrumentPositionCreeperCycleCount = 0;
        private bool attachedInstrumentPositionCreeperSurging = false;
        private bool attachedInstrumentPositionCreeperGushing1 = false;
        private bool attachedInstrumentPositionFlowing1 = false;
        private bool attachedInstrumentPositionFlowing2 = false;
        private bool attachedInstrumentPositionFlowing3 = false;
        private bool attachedInstrumentPositionFlowing4 = false;
        private MarketPosition attachedInstrumentMarketPosition = MarketPosition.Flat;
        private double attachedInstrumentPositionPnL = 0;
        private int attachedInstrumentPositionQuantity = 0;
        private double attachedInstrumentPositionPrice = 0;
        private double attachedInstrumentPositionStopLossPrice = 0;
        private double attachedInstrumentPositionTakeProfitPrice = 0;
        private MarketPosition lastAttachedInstrumentPositionType = MarketPosition.Flat;
        private double lastAttachedInstrumentPositionPrice = 0;
        private int lastAttachedInstrumentPositionQuantity = 0;

        private bool blendedInstrumentHasChanged = false;
        private bool blendedInstrumentHasPosition = false;
        private double blendedInstrumentPositionCreeperCycleCount = 0;
        private bool blendedInstrumentPositionCreeperSurging = false;
        private Instrument blendedInstrument = null;
        private MarketPosition blendedInstrumentMarketPosition = MarketPosition.Flat;
        private int blendedInstrumentPositionQuantity = 0;
        private double blendedInstrumentPositionPrice = 0;
        private double blendedInstrumentPositionStopLossPrice = 0;
        private double blendedInstrumentPositionTakeProfitPrice = 0;
        private double lastBlendedInstrumentInfoDollars = 0;
        private double lastBlendedInstrumentDollars = 0;
        private MarketPosition lastBlendedInstrumentPositionType = MarketPosition.Flat;
        private double lastBlendedInstrumentPositionPrice = 0;
        private int lastBlendedInstrumentPositionQuantity = 0;

        const double BarPeriodSecondInterval = 60;
        private double barPeriodSecondInterval = BarPeriodSecondInterval;

        private bool limitTrancheVolumeToInProfitFlag = false;
        private bool popLimitToPullbackFlag = false;
        private bool limitTrancheVolumePerBarFlag = false;

        private double lastAccountIntradayExcessMargin = 0;
        private ATR atrBuffer;
        private double atrValue = 0;

        private string fullSoundFilename = "";

        private bool isTickHunterActivated = false;

        private int currentBarCount = 0;
        private double previous1ClosePrice = 0;
        private double previous2ClosePrice = 0;
        private double previous3ClosePrice = 0;
        private double previous4ClosePrice = 0;
        private double previous5ClosePrice = 0;
        private double previous6ClosePrice = 0;
        private double previous7ClosePrice = 0;
        private double previous8ClosePrice = 0;
        private double previous9ClosePrice = 0;
        private double previous10ClosePrice = 0;
        private double previous11ClosePrice = 0;
        private double previous12ClosePrice = 0;
        private double previous13ClosePrice = 0;
        private double previous14ClosePrice = 0;
        private double previous15ClosePrice = 0;
        private double previous16ClosePrice = 0;
        private double previous17ClosePrice = 0;
        private double previous18ClosePrice = 0;
        private double previous19ClosePrice = 0;
        private double previous20ClosePrice = 0;
        private double previous1LowPrice = 0;
        private double previous2LowPrice = 0;
        private double previous3LowPrice = 0;
        private double previous4LowPrice = 0;
        private double previous5LowPrice = 0;
        private double previous6LowPrice = 0;
        private double previous7LowPrice = 0;
        private double previous8LowPrice = 0;
        private double previous9LowPrice = 0;
        private double previous10LowPrice = 0;
        private double previous11LowPrice = 0;
        private double previous12LowPrice = 0;
        private double previous13LowPrice = 0;
        private double previous14LowPrice = 0;
        private double previous15LowPrice = 0;
        private double previous16LowPrice = 0;
        private double previous17LowPrice = 0;
        private double previous18LowPrice = 0;
        private double previous19LowPrice = 0;
        private double previous20LowPrice = 0;

        private double previous1HighPrice = 0;
        private double previous2HighPrice = 0;
        private double previous3HighPrice = 0;
        private double previous4HighPrice = 0;
        private double previous5HighPrice = 0;
        private double previous6HighPrice = 0;
        private double previous7HighPrice = 0;
        private double previous8HighPrice = 0;
        private double previous9HighPrice = 0;
        private double previous10HighPrice = 0;
        private double previous11HighPrice = 0;
        private double previous12HighPrice = 0;
        private double previous13HighPrice = 0;
        private double previous14HighPrice = 0;
        private double previous15HighPrice = 0;
        private double previous16HighPrice = 0;
        private double previous17HighPrice = 0;
        private double previous18HighPrice = 0;
        private double previous19HighPrice = 0;
        private double previous20HighPrice = 0;
        private bool previous1CandleBullish = false;
        private bool previous2CandleBullish = false;
        private bool previous3CandleBullish = false;
        private bool previous4CandleBullish = false;
        private bool previous5CandleBullish = false;
        private bool previous6CandleBullish = false;
        private bool previous7CandleBullish = false;
        private bool previous8CandleBullish = false;

        private bool inBuySliderSetupCycle = false;
        private bool inSellSliderSetupCycle = false;

        private bool usedBuySliderSetupCycle = false;
        private bool usedSellSliderSetupCycle = false;

        /*
        private Stroke stopLossStroke = null;
        private Stroke profitTargetStroke = null;
        private DateTime lastChartTraderCycleChangeTime = DateTime.MinValue;
        private int ChartTraderCycleThrottleSeconds = 5;
        */

        private DateTime lastRealTimePipeLineCycleChangeTime = DateTime.MinValue;
        private DateTime lastPopDropCycleChangeTime = DateTime.MinValue;
        private bool isPopDropOnBarUpdateCycleReady = false;

        bool runSysCheckFlag = false;

        public override string DisplayName
        {
            get
            {
                if (State == State.SetDefaults)
                    return FullSystemName;
                else if (ShowIndicatorName)
                    return FullSystemName;
                else
                    return "";
            }
        }


        protected override void OnStateChange()
        {
            string signalName = "OnStateChange";

            if (State == State.SetDefaults)
            {
                signalName = "OnStateChange (State.SetDefaults)";
                if (this.DebugLogLevel > 10) RealLogger.PrintOutput("*** " + signalName + ":");

                Name = SystemName;
                Description = FullSystemName;
                Calculate = Calculate.OnPriceChange;
                MaximumBarsLookBack = MaximumBarsLookBack.TwoHundredFiftySix;
                IsOverlay = true;
                IsChartOnly = true;
                IsSuspendedWhileInactive = false;
                DisplayInDataBox = false;
                DrawOnPricePanel = true;
                //DrawHorizontalGridLines = false;
                //DrawVerticalGridLines = false;
                PaintPriceMarkers = false;

                PrintTo = PrintTo.OutputTab1;

                // 1) Stop Loss Settings
                UseAutoPositionStopLoss = false;
                StopLossInitialTicks = 21;
                StopLossInitialATRMultiplier = 0;
                StopLossInitialSnapType = TickHunterStopLossSnapTypes.Disabled;
                StopLossInitialMaxTicks = 0;
                StopLossInitialDollars = 0;
                StopLossInitialDollarsCombined = false;
                StopLossJumpTicks = 2;
                StopLossCTRLJumpTicks = true;
                StopLossRefreshOnVolumeChange = false;
                StopLossRefreshManagementEnabled = true;

                // 2) Take Profit Settings
                UseAutoPositionTakeProfit = false;
                TakeProfitInitialTicks = 45;
                TakeProfitInitialATRMultiplier = 0;
                TakeProfitSyncBogeyTargetPrice = true;
                TakeProfitSyncECATargetPrice = true;
                TakeProfitJumpTicks = 20;
                TakeProfitCtrlSLMultiplier = 2;
                TakeProfitRefreshManagementEnabled = true;

                //3) Break-Even Settings
                AutoPositionBreakEvenType = TickHunterBreakEvenAutoTypes.Disabled;
                BreakEvenInitialTicks = 4;
                BreakEvenJumpTicks = 2;
                BreakEvenTurboJumpTicks = 4;
                BreakEvenAutoTrailNow = TickHunterBreakEvenAutoTrailNowTypes.Disabled;
                BreakEvenAutoTriggerTicks = 26;
                BreakEvenAutoTriggerATRMultiplier = 0;
                BreakEvenAutoZombieFlipResumeSnapType = TickHunterStopLossSnapTypes.Snap8Bar;
                BreakEvenAutoCreeperFlipSnapType = TickHunterStopLossSnapTypes.Snap1Bar;

                // 4) Buy/Sell Settings
                UseIntradayMarginCheck = false;
                LimitTrancheVolumeToInProfit = false;
                LimitToVolumeMaxOption = false;
                EntryVolumeMaxOption1 = 1;
                EntryVolumeMaxOption2 = 2;
                EntryVolumeMaxOption3 = 3;
                EntryVolumeMaxOption4 = 4;
                EntryVolumeMaxOption5 = 0;

                MaxInitialTrancheVolumeSize = 1;
                LimitTrancheVolumePerBar = false;
                MinTrancheVolumeDelaySeconds = 10;

                // 5) Pop/Drop Settings
                UsePopCTRLDelayedEntry = true;
                UsePopLimitToPullback = false;
                PopDelayedEntryMaxCount = 1;
                PopInitialTicks = 20;
                PopInitialATRMultiplier = 0.5;
                PopJumpTicks = 2;
                UsePopAutoJumpToSnap = true;
                DropInitialTicks = 20;
                DropInitialATRMultiplier = 0.5;
                DropJumpTicks = 2;
                UseDropAutoJumpToSnap = true;

                UsePopDropOnBarUpdateDelay = false;
                PopDropThrottleMilliseconds = 250;



                // 6) Volume Settings
                AutoEntryVolumeType = TickHunterEntryVolumeAutoTypes.Option1;
                AutoEntryVolumeOption1 = 1;
                AutoEntryVolumeOption2 = 2;
                AutoEntryVolumeOption3 = 3;
                AutoEntryVolumeOption4 = 4;
                AutoEntryVolumeOption5 = 5;

                // 7) AutoPilot Settings
                AutoPilotOrderType = TickHunterAutoPilotOrderTypes.Market;
                AutoPilotTradeSignalType = TickHunterTradeSignalTypes.BuySellAll;
                AutoPilotSetupType = TickHunterAutoPilotSetupTypes.CreeperOnly;
                UseAutoPilotLite = true;
                UseAutoPilotAddOn = false;
                AutoPilotMaxVolume = 0;
                UseAutoPilotSpeedLineFilter = false;
                AutoPilotSpeedLineFilterPeriod = 8;
                AutoPilotSetupFilterPeriod = 170;
                AutoPilotSetupCreeperPeriod1 = 12;
                AutoPilotSetupCreeperPeriod2 = 26;
                AutoPilotSetupCreeperPeriod3 = 9;
                AutoPilotSetupZombiePeriod = 15;
                AutoPilotSetupZombieMultiplier = 1;
                AutoPilotSetupWalkerPeriod = 8;
                AutoPilotSetupWalkerFreshCrossOnly = true;

                // 8) AutoPilot Profile Settings
                AutoPilotProfileSetupType = TickHunterAutoPilotProfileSetupTypes.CreeperOrSliderCombo;
                UsePeppyLimitPopDelayedEntry = true;
                UsePeppyLimitPopToPullback = false;
                UsePeppyLimitPopAlignedCreeper = true;
                UsePeppyLimitPopAlignedRushLine = true;
                UseSleepyLimitPopDelayedEntry = true;
                UseSleepyLimitPopToPullback = true;
                UseSleepyLimitPopCounterCreeper = true;
                UseSleepyLimitPopCounterRushLine = true;

                // 9) Auto Close Settings
                AutoPositionCloseType = TickHunterCloseAutoTypes.Disabled;
                UseAutoCloseMinProfit = false;
                AutoCloseMinProfitDollarsPerVolume = 5;
                UseAutoCloseAlert = false;
                AutoCloseAndTrailOffsetTicks = 1;
                AutoCloseAndTrailMA1Period = 21;
                AutoCloseAndTrailMA2Period = 34;
                AutoCloseAndTrailMA3Period = 55;
                AutoCloseAndTrailMA4Period = 170;
                AutoCloseAndTrailZL1Period = 20;
                AutoCloseAndTrailZL2Period = 50;
                AutoCloseAndTrailRLPeriod = 10;
                AutoCloseAndTrailDL1Period = 21;
                AutoCloseAndTrailDL2Period = 34;
                AutoCloseAndTrailDL3Period = 55;
                AutoCloseAndTrailDL4Period = 170;
                AutoCloseAndTrailR1Period = 34;
                AutoCloseAndTrailR5Period = 170;
                AutoCloseAndTrailKLine1Period = 15;
                AutoCloseAndTrailKLine1Multiplier = 1;
                AutoCloseAndTrailKLine2Period = 15;
                AutoCloseAndTrailKLine2Multiplier = 2;

                // 10) Bogey Target Settings
                BogeyTargetStartWithFullPnL = true;
                BogeyTargetBaseDollars = 100;
                BogeyTargetDailyBaseDollars = 0;
                ShowBogeyTargetDailyBreakEvenLine = false;
                ShowBogeyTargetDaily1Line = false;
                ShowBogeyTargetDaily2Line = false;
                ShowBogeyTargetDaily3Line = false;
                ShowBogeyTargetDaily4Line = false;
                ShowBogeyTargetDaily5Line = false;

                // 11) ECA Target Settings
                ECATargetDollars = 0;
                ECATargetDollarsPerOtherVolume = 5;
                ECATargetDollarsPerMNQVolume = 10;
                ECATargetDollarsPerNQVolume = 100;
                ECATargetDollarsPerM2KVolume = 5;
                ECATargetDollarsPerRTYVolume = 50;
                ECATargetDollarsPerMESVolume = 5;
                ECATargetDollarsPerESVolume = 50;
                ECATargetDollarsPerMYMVolume = 5;
                ECATargetDollarsPerYMVolume = 50;
                ECATargetATRMultiplierPerVolume = 0.5;

                // 12) AddOn Settings
                AutoAddOnMaxDollars = 250;

                // 13) Account Risk Settings
                UseDayOverMaxLossTrailing = false;
                DayOverMaxLossDollars = 0;
                DayOverMaxLossBTBaseRatio = 2.5;
                DayOverMaxAccountPnLPeakDollars = 0;
                DayOverAccountBalanceFloorDollars = 0;
                ECAMaxDDInDollars = 0;
                ExcessIntradayMarginMinDollars = 0;

                // 14) Sound Settings
                PlaySoundOnSetupAlert = false;
                SoundFile = NinjaTrader.Core.Globals.InstallDir.ToString() + @"sounds\whip.wav";

                // 15) Button Settings
                ShowButtonAutoBreakEven = true;
                ShowButtonReverse = true;
                ShowButtonClose = true;
                ShowButtonAutoClose = true;
                ShowButtonProfitTarget = true;
                ShowButtonTPPlus = true;
                ShowButtonBEPlus = true;
                ShowButtonSLPlus = true;
                ShowButtonBuyMarket = true;
                ShowButtonSellMarket = true;
                ShowButtonPopPlus = false;
                ShowButtonPopMinus = false;
                ShowButtonDropPlus = false;
                ShowButtonDropMinus = false;
                ShowButtonAutoAddOn = false;
                ShowButtonTradeSignal = false;
                ShowButtonAutoPilotProfile = false;
                ShowButtonAutoPilot = false;
                ShowButtonVolumeMax = false;
                ShowButtonVolume = true;

                // 16) Instrument Settings
                UseBlendedInstruments = false;
                ShowAveragePriceLine = true;
                ShowAveragePriceLineQuantity = true;
                ShowAveragePriceLineQuantityInMicros = false;
                OtherCommissionPerSide = 2.09;
                OtherIntradayMarginDollars = 1000;
                OtherPositionMaxVolume = 50;

                MNQCommissionPerSide = 0.61;
                MNQIntradayMarginDollars = 100;
                MNQPositionMaxVolume = 100;

                NQCommissionPerSide = 2.09;
                NQIntradayMarginDollars = 1000;
                NQPositionMaxVolume = 50;

                MESCommissionPerSide = 0.61;
                MESIntradayMarginDollars = 50;
                MESPositionMaxVolume = 100;

                ESCommissionPerSide = 2.09;
                ESIntradayMarginDollars = 500;
                ESPositionMaxVolume = 50;

                MYMCommissionPerSide = 0.61;
                MYMIntradayMarginDollars = 50;
                MYMPositionMaxVolume = 100;

                YMCommissionPerSide = 2.09;
                YMIntradayMarginDollars = 500;
                YMPositionMaxVolume = 50;

                M2KCommissionPerSide = 0.61;
                M2KIntradayMarginDollars = 50;
                M2KPositionMaxVolume = 100;

                RTYCommissionPerSide = 2.09;
                RTYIntradayMarginDollars = 500;
                RTYPositionMaxVolume = 50;

                IgnoreInstrumentServerSupport = false;

                // 17) Misc Settings
                SnapOffsetTicks = 1;
                SnapPowerBoxPeriod = 8;
                SnapPowerBoxAutoAdjustPeriodsOnM1 = true;
                ATRPeriod = 21;
                RefreshTPSLOffsetTicks = 0;
                RefreshTPSLOrderDelaySeconds = 0;
                SingleOrderChunkMaxQuantity = 10;
                SingleOrderChunkMinQuantity = 5;
                SingleOrderChunkDelayMilliseconds = 10;
                RealTimePipeLineThrottleMilliseconds = 50;

                // 18) Output Log Settings
                UsePositionProfitLogging = false;
                DebugLogLevel = 0;
                OrderWaitOutputThrottleSeconds = 1;

                // 19) Account Logging Settings
                UseAccountInfoLogging = false;
                AccountInfoLoggingPath = @"C:\MetaTrader\AccountInfo_NT.csv";


                //UseHedgehogEntry = false;
                //HedgehogEntryBuySymbol1SellSymbol2 = true;
                //HedgehogEntrySymbol1 = "MES";
                //HedgehogEntrySymbol2 = "M2K";


                AddPlot(new Stroke(Brushes.LimeGreen, DashStyleHelper.Solid, 3), PlotStyle.Line, "BogeyTargetLine");
                AddPlot(new Stroke(Brushes.DeepSkyBlue, DashStyleHelper.DashDotDot, 1), PlotStyle.Line, "BogeyTargetBreakEvenLine");
                AddPlot(new Stroke(Brushes.DeepSkyBlue, DashStyleHelper.Dash, 1), PlotStyle.Line, "BogeyTargetDaily1Line");
                AddPlot(new Stroke(Brushes.DeepSkyBlue, DashStyleHelper.Dash, 1), PlotStyle.Line, "BogeyTargetDaily2Line");
                AddPlot(new Stroke(Brushes.DeepSkyBlue, DashStyleHelper.Dash, 1), PlotStyle.Line, "BogeyTargetDaily3Line");
                AddPlot(new Stroke(Brushes.DeepSkyBlue, DashStyleHelper.Dash, 1), PlotStyle.Line, "BogeyTargetDaily4Line");
                AddPlot(new Stroke(Brushes.DeepSkyBlue, DashStyleHelper.Dash, 1), PlotStyle.Line, "BogeyTargetDaily5Line");

                AddPlot(new Stroke(Brushes.Red, DashStyleHelper.Solid, 3), PlotStyle.Line, "DayOverMaxLossLine");
                AddPlot(new Stroke(Brushes.Red, DashStyleHelper.Dash, 3), PlotStyle.Line, "DayOverAccountBalanceFloorLine");
                AddPlot(new Stroke(Brushes.LimeGreen, DashStyleHelper.Dash, 3), PlotStyle.Line, "ECATakeProfitLine");
                AddPlot(new Stroke(Brushes.SkyBlue, DashStyleHelper.Solid, 3), PlotStyle.Line, "AveragePriceLine");

            }
            else if (State == State.Configure)
            {
                signalName = "OnStateChange (State.Configure)";
                if (this.DebugLogLevel > 10) RealLogger.PrintOutput("*** " + signalName + ":");

                attachedInstrument = this.Instrument;
                attachedInstrumentIsEmini = IsEminiInstrument(attachedInstrument);
                attachedInstrumentIsFuture = RealInstrumentService.IsFutureInstrumentType(this.attachedInstrument);
                attachedInstrumentServerSupported = (IgnoreInstrumentServerSupport || this.Instrument.MasterInstrument.IsServerSupported);
                attachedInstrumentTickSize = RealInstrumentService.GetTickSize(attachedInstrument);
                attachedInstrumentTicksPerPoint = RealInstrumentService.GetTicksPerPoint(attachedInstrumentTickSize);
                attachedInstrumentTickValue = RealInstrumentService.GetTickValue(attachedInstrument);

                GenerateEntryVolumeAutoButtonText();
                GenerateEntryVolumeMaxButtonText();

                currentAutoPilotStatus = TickHunterAutoPilotTypes.Disabled; //DO NOT CHANGE FROM DEFAULT DISABLED AS THIS IS FOR SAFETY
                currentAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled; //DO NOT CHANGE FROM DEFAULT DISABLED AS THIS IS FOR SAFETY
                currentAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled; //DO NOT CHANGE FROM DEFAULT DISABLED AS THIS IS FOR SAFETY
                currentBuyPopDelayedStatus = TickHunterPopDelayedTypes.Disabled; //DO NOT CHANGE FROM DEFAULT DISABLED AS THIS IS FOR SAFETY
                currentSellPopDelayedStatus = TickHunterPopDelayedTypes.Disabled; //DO NOT CHANGE FROM DEFAULT DISABLED AS THIS IS FOR SAFETY
                currentTradeSignalStatus = AutoPilotTradeSignalType;
                lastToggleEntryTradeSignalStatus = currentTradeSignalStatus;
                lastToggleBuyPopDelayedStatus = currentBuyPopDelayedStatus;
                lastToggleSellPopDelayedStatus = currentSellPopDelayedStatus;

                currentAutoPilotSetupStatus = AutoPilotSetupType;
                currentAutoPilotProfileSetupStatus = AutoPilotProfileSetupType;
                currentAutoPilotOrderStatus = AutoPilotOrderType;
                currentStopLossInitialSnapStatus = StopLossInitialSnapType;
                //if (!ShowButtonTradeSignal) currentTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
                currentEntryVolumeAutoStatus = AutoEntryVolumeType;
                lastToggleEntryVolumeAutoStatus = currentEntryVolumeAutoStatus;
                currentBogeyTargetMultiplier = BogeyTargetMultiplierDisabled;
                nextBogeyTargetMultiplier = currentBogeyTargetMultiplier;

                currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                lastToggleEntryVolumeMaxStatus = currentEntryVolumeMaxStatus;

                bogeyTargetStartWithFullPnLFlag = BogeyTargetStartWithFullPnL;
                useAutoPilotAddOnFlag = UseAutoPilotAddOn;
                breakEvenAutoTrailNowFlag = BreakEvenAutoTrailNow;
                closeAutoMinProfitFlag = UseAutoCloseMinProfit;
                closeAutoAlertFlag = UseAutoCloseAlert;
                popCTRLDelayedEntryFlag = UsePopCTRLDelayedEntry;
                popLimitToPullbackFlag = UsePopLimitToPullback;
                popDelayedEntryMaxCountFlag = Math.Min(PopDelayedEntryMaxCount, (int)TickHunterPopDelayedTypes.TradeCount5);
                limitTrancheVolumeToInProfitFlag = (LimitTrancheVolumeToInProfit && MaxInitialTrancheVolumeSize > 0);
                limitTrancheVolumePerBarFlag = (LimitTrancheVolumePerBar && MinTrancheVolumeDelaySeconds > 0);


                currentCloseAutoStatus = AutoPositionCloseType;
                lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;

                currentBreakEvenAutoStatus = AutoPositionBreakEvenType;
                lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;

                if (DayOverMaxLossBTBaseRatio > 0 && BogeyTargetBaseDollars > 0 && DayOverMaxLossDollars == 0)
                {
                    dayOverMaxLossDollars = BogeyTargetBaseDollars * DayOverMaxLossBTBaseRatio;
                }
                else
                {
                    dayOverMaxLossDollars = DayOverMaxLossDollars;
                }

                autoAddOnMaxDollars = CalculateAutoAddOnMaxDollars(AutoAddOnMaxDollars, StopLossInitialDollars, dayOverMaxLossDollars);

                if (this.ECAMaxDDInDollars == 0)
                    maxDDInDollars = this.ECAMaxDDInDollars;
                else
                    maxDDInDollars = this.ECAMaxDDInDollars * -1;

                if (attachedInstrumentServerSupported)
                {
                    if (attachedInstrumentIsFuture)
                    {
                        //HedgehogEntrySymbol1FullName = HedgehogEntrySymbol1 + GetCurrentFuturesMonthYearPrefix();
                        //HedgehogEntrySymbol2FullName = HedgehogEntrySymbol2 + GetCurrentFuturesMonthYearPrefix();

                        string mnqFullName = MNQPrefix + GetCurrentFuturesMonthYearPrefix();
                        string mesFullName = MESPrefix + GetCurrentFuturesMonthYearPrefix();
                        string mymFullName = MYMPrefix + GetCurrentFuturesMonthYearPrefix();
                        string m2kFullName = M2KPrefix + GetCurrentFuturesMonthYearPrefix();

                        string nqFullName = NQPrefix + GetCurrentFuturesMonthYearPrefix();
                        string esFullName = ESPrefix + GetCurrentFuturesMonthYearPrefix();
                        string ymFullName = YMPrefix + GetCurrentFuturesMonthYearPrefix();
                        string rtyFullName = RTYPrefix + GetCurrentFuturesMonthYearPrefix();


                        // BarsArray[0] is default of chart we are on

                        if (this.Instrument.FullName != mnqFullName)
                        {
                            ValidateInstrument(mnqFullName);
                        }

                        if (this.Instrument.FullName != mesFullName)
                        {
                            ValidateInstrument(mesFullName);
                        }

                        if (this.Instrument.FullName != mymFullName)
                        {
                            ValidateInstrument(mymFullName);
                        }

                        if (this.Instrument.FullName != m2kFullName)
                        {
                            ValidateInstrument(m2kFullName);
                        }

                        if (this.Instrument.FullName != nqFullName)
                        {
                            ValidateInstrument(nqFullName);
                        }

                        if (this.Instrument.FullName != esFullName)
                        {
                            ValidateInstrument(esFullName);
                            //AddDataSeries(emini2FullName, BarsPeriodType.Minute, 5);
                        }

                        if (this.Instrument.FullName != ymFullName)
                        {
                            ValidateInstrument(ymFullName);
                            //AddDataSeries(emini3FullName, BarsPeriodType.Minute, 5);
                        }

                        if (this.Instrument.FullName != rtyFullName)
                        {
                            ValidateInstrument(rtyFullName);
                            //AddDataSeries(emini4FullName, BarsPeriodType.Minute, 5);
                        }

                        mnqInstrument = Instrument.GetInstrument(mnqFullName);
                        mesInstrument = Instrument.GetInstrument(mesFullName);
                        mymInstrument = Instrument.GetInstrument(mymFullName);
                        m2kInstrument = Instrument.GetInstrument(m2kFullName);

                        nqInstrument = Instrument.GetInstrument(nqFullName);
                        esInstrument = Instrument.GetInstrument(esFullName);
                        ymInstrument = Instrument.GetInstrument(ymFullName);
                        rtyInstrument = Instrument.GetInstrument(rtyFullName);

                        blendedInstrument = GetBlendedInstrument(attachedInstrument);

                    }
                }

                ForceRefresh();
            }
            else if (State == State.DataLoaded)
            {
                signalName = "OnStateChange (State.DataLoaded)";
                if (this.DebugLogLevel > 10) RealLogger.PrintOutput("*** " + signalName + ":");

                RealLogger.PrintOutput("Loading " + SystemVersion + " on " + this.attachedInstrument.FullName + " (" + BarsPeriod + ")", PrintTo.OutputTab1);
                RealLogger.PrintOutput("Loading " + SystemVersion + " on " + this.attachedInstrument.FullName + " (" + BarsPeriod + ")", PrintTo.OutputTab2);
                RealLogger.PrintOutput("IsFutureType=" + attachedInstrumentIsFuture.ToString() + " IsInstrumentServerSupported=" + attachedInstrumentServerSupported.ToString(), PrintTo.OutputTab2);

                isTickHunterActivated = false;
                if (attachedInstrumentServerSupported)
                {
                    hasRanOnceFirstCycle = false;
                    activeDayOverMaxLossAutoClose = false;
                    atrBuffer = ATR(ATRPeriod);
                    atrValue = 0;

                    barPeriodSecondInterval = GetBarPeriodSecondInterval(BarsPeriod);

                    runSysCheckFlag = true;

                    this.fullSoundFilename = this.SoundFile;

                    snapPowerBoxBuffer = THPowerBox("x", false, SnapPowerBoxPeriod, 2);
                    snapPowerBoxBuffer.AutoAdjustPeriodsOnM1 = SnapPowerBoxAutoAdjustPeriodsOnM1;
                    snapPowerBoxMiddleValue = 0;
                    snapPowerBoxUpperValue = 0;
                    snapPowerBoxUpperValue10 = 0;
                    snapPowerBoxUpperValue20 = 0;
                    snapPowerBoxUpperValue30 = 0;
                    snapPowerBoxUpperValue40 = 0;
                    snapPowerBoxUpperValue50 = 0;
                    snapPowerBoxLowerValue = 0;
                    snapPowerBoxLowerValue10 = 0;
                    snapPowerBoxLowerValue20 = 0;
                    snapPowerBoxLowerValue30 = 0;
                    snapPowerBoxUpperValue40 = 0;
                    snapPowerBoxUpperValue50 = 0;


                    keltnerATRBuffer = THKeltnerATR("X", false, false, KeltnerPeriod, KeltnerATRPeriod, KeltnerOffsetMultiplier1, KeltnerOffsetMultiplier2, KeltnerOffsetMultiplier3, KeltnerOffsetMultiplier4);

                    keltnerUpperInnerRingValue = 0;
                    keltnerLowerInnerRingValue = 0;

                    stingRayBuffer = THStingRay("x", 2, false, false, AutoPilotSetupCreeperPeriod1, AutoPilotSetupCreeperPeriod2, AutoPilotSetupCreeperPeriod3, AutoCloseAndTrailRLPeriod, AutoCloseAndTrailDL1Period, AutoCloseAndTrailDL2Period, AutoCloseAndTrailDL3Period, AutoCloseAndTrailDL4Period);
                    stingRayHighLevel1Value = 0;
                    stingRayHighLevel2Value = 0;
                    stingRayHighLevel3Value = 0;
                    stingRayHighLevel4Value = 0;
                    stingRayHighLevel5Value = 0;

                    stingRayLowLevel1Value = 0;
                    stingRayLowLevel2Value = 0;
                    stingRayLowLevel3Value = 0;
                    stingRayLowLevel4Value = 0;
                    stingRayLowLevel5Value = 0;

                    stingRayRecentHigherHighValue = 0;
                    stingRayRecentLowerLowValue = 0;

                    stingRayCreeperCycleCountValue = 0;
                    stingRaySurgeBarCountValue = 0;
                    stingRaySurgeBarCycleTickSpeedValue = 0;
                    stingRayGush1BarCountValue = 0;
                    stingRayGush1BarCycleTickSpeedValue = 0;

                    stingRayFlow1BarCountValue = 0;
                    stingRayFlow1BarCycleTickSpeedValue = 0;
                    stingRayFlow2BarCountValue = 0;
                    stingRayFlow2BarCycleTickSpeedValue = 0;
                    stingRayFlow3BarCountValue = 0;
                    stingRayFlow3BarCycleTickSpeedValue = 0;
                    stingRayFlow4BarCountValue = 0;
                    stingRayFlow4BarCycleTickSpeedValue = 0;

                    inBuySliderSetupCycle = false;
                    inSellSliderSetupCycle = false;
                    usedBuySliderSetupCycle = false;
                    usedSellSliderSetupCycle = false;

                    bogeyTargetLineBrush = Plots[BogeyTargetLineChangePlotIndex].Brush;
                    bogeyTargetLineDashStyle = Plots[BogeyTargetLineChangePlotIndex].DashStyleHelper;
                    bogeyTargetLineWidth = (int)Plots[BogeyTargetLineChangePlotIndex].Width;

                    bogeyTargetLineBrush.Freeze();

                    bogeyTargetBreakEvenLineBrush = Plots[BogeyTargetBreakEvenLineChangePlotIndex].Brush;
                    bogeyTargetBreakEvenLineDashStyle = Plots[BogeyTargetBreakEvenLineChangePlotIndex].DashStyleHelper;
                    bogeyTargetBreakEvenLineWidth = (int)Plots[BogeyTargetBreakEvenLineChangePlotIndex].Width;
                    bogeyTargetBreakEvenLineIsBrushTransparent = bogeyTargetBreakEvenLineBrush.IsTransparent();

                    bogeyTargetBreakEvenLineBrush.Freeze();

                    bogeyTargetDaily1LineBrush = Plots[BogeyTargetDaily1LineChangePlotIndex].Brush;
                    bogeyTargetDaily1LineDashStyle = Plots[BogeyTargetDaily1LineChangePlotIndex].DashStyleHelper;
                    bogeyTargetDaily1LineWidth = (int)Plots[BogeyTargetDaily1LineChangePlotIndex].Width;
                    bogeyTargetDaily1LineIsBrushTransparent = bogeyTargetDaily1LineBrush.IsTransparent();

                    bogeyTargetDaily1LineBrush.Freeze();

                    bogeyTargetDaily2LineBrush = Plots[BogeyTargetDaily2LineChangePlotIndex].Brush;
                    bogeyTargetDaily2LineDashStyle = Plots[BogeyTargetDaily2LineChangePlotIndex].DashStyleHelper;
                    bogeyTargetDaily2LineWidth = (int)Plots[BogeyTargetDaily2LineChangePlotIndex].Width;
                    bogeyTargetDaily2LineIsBrushTransparent = bogeyTargetDaily2LineBrush.IsTransparent();

                    bogeyTargetDaily2LineBrush.Freeze();

                    bogeyTargetDaily3LineBrush = Plots[BogeyTargetDaily3LineChangePlotIndex].Brush;
                    bogeyTargetDaily3LineDashStyle = Plots[BogeyTargetDaily3LineChangePlotIndex].DashStyleHelper;
                    bogeyTargetDaily3LineWidth = (int)Plots[BogeyTargetDaily3LineChangePlotIndex].Width;
                    bogeyTargetDaily3LineIsBrushTransparent = bogeyTargetDaily3LineBrush.IsTransparent();

                    bogeyTargetDaily3LineBrush.Freeze();

                    bogeyTargetDaily4LineBrush = Plots[BogeyTargetDaily4LineChangePlotIndex].Brush;
                    bogeyTargetDaily4LineDashStyle = Plots[BogeyTargetDaily4LineChangePlotIndex].DashStyleHelper;
                    bogeyTargetDaily4LineWidth = (int)Plots[BogeyTargetDaily4LineChangePlotIndex].Width;
                    bogeyTargetDaily4LineIsBrushTransparent = bogeyTargetDaily4LineBrush.IsTransparent();

                    bogeyTargetDaily4LineBrush.Freeze();

                    bogeyTargetDaily5LineBrush = Plots[BogeyTargetDaily5LineChangePlotIndex].Brush;
                    bogeyTargetDaily5LineDashStyle = Plots[BogeyTargetDaily5LineChangePlotIndex].DashStyleHelper;
                    bogeyTargetDaily5LineWidth = (int)Plots[BogeyTargetDaily5LineChangePlotIndex].Width;
                    bogeyTargetDaily5LineIsBrushTransparent = bogeyTargetDaily5LineBrush.IsTransparent();

                    bogeyTargetDaily5LineBrush.Freeze();

                    dayOverMaxLossLineBrush = Plots[DayOverMaxLossLineChangePlotIndex].Brush;
                    dayOverMaxLossLineDashStyle = Plots[DayOverMaxLossLineChangePlotIndex].DashStyleHelper;
                    dayOverMaxLossLineWidth = (int)Plots[DayOverMaxLossLineChangePlotIndex].Width;

                    dayOverMaxLossLineBrush.Freeze();
                    dayOverMaxLossInfoTextColor.Freeze();

                    dayOverAccountBalanceFloorLineBrush = Plots[DayOverAccountBalanceFloorLineChangePlotIndex].Brush;
                    dayOverAccountBalanceFloorLineDashStyle = Plots[DayOverAccountBalanceFloorLineChangePlotIndex].DashStyleHelper;
                    dayOverAccountBalanceFloorLineWidth = (int)Plots[DayOverAccountBalanceFloorLineChangePlotIndex].Width;

                    dayOverAccountBalanceFloorLineBrush.Freeze();

                    ecaTakeProfitLineBrush = Plots[ECATakeProfitLineChangePlotIndex].Brush;
                    ecaTakeProfitLineDashStyle = Plots[ECATakeProfitLineChangePlotIndex].DashStyleHelper;
                    ecaTakeProfitLineWidth = (int)Plots[ECATakeProfitLineChangePlotIndex].Width;

                    ecaTakeProfitLineBrush.Freeze();

                    averagePriceLineBrush = Plots[AveragePriceLineChangePlotIndex].Brush;
                    averagePriceLineDashStyle = Plots[AveragePriceLineChangePlotIndex].DashStyleHelper;
                    averagePriceLineWidth = (int)Plots[AveragePriceLineChangePlotIndex].Width;
                    averagePriceLineIsBrushTransparent = averagePriceLineBrush.IsTransparent();

                    averagePriceLineBrush.Freeze();


                    autoPilotSetupWalkerBuffer = EMA(Close, AutoPilotSetupWalkerPeriod);
                    autoPilotSpeedLineFilterBuffer = EMA(Close, AutoPilotSpeedLineFilterPeriod);
                    autoPilotFilterBuffer = EMA(Close, AutoPilotSetupFilterPeriod);

                    autoPilotSetupZombieBuffer = THZombieSetup("x", AutoPilotSetupZombiePeriod, AutoPilotSetupZombieMultiplier, false, 2);
                    autoPilotSetupZombie2Buffer = THZombieSetup("x", AutoCloseAndTrailKLine2Period, AutoCloseAndTrailKLine2Multiplier, false, 2);
                    autoPilotSetupCreeperBuffer = THCreeperSetup("X", AutoPilotSetupCreeperPeriod1, AutoPilotSetupCreeperPeriod2, AutoPilotSetupCreeperPeriod3, 12, 1, 26, Brushes.Transparent);

                    autoCloseAndTrailKLine1Buffer = THZombieSetup("x", AutoCloseAndTrailKLine1Period, AutoCloseAndTrailKLine1Multiplier, false, 2);
                    autoCloseAndTrailKLine2Buffer = THZombieSetup("x", AutoCloseAndTrailKLine2Period, AutoCloseAndTrailKLine2Multiplier, false, 2);

                    autoCloseAndTrailMA1Buffer = EMA(Close, AutoCloseAndTrailMA1Period);
                    autoCloseAndTrailMA2Buffer = EMA(Close, AutoCloseAndTrailMA2Period);
                    autoCloseAndTrailMA3Buffer = EMA(Close, AutoCloseAndTrailMA3Period);
                    autoCloseAndTrailMA4Buffer = EMA(Close, AutoCloseAndTrailMA4Period);

                    autoCloseAndTrailR1HBuffer = EMA(High, AutoCloseAndTrailR1Period);
                    autoCloseAndTrailR1LBuffer = EMA(Low, AutoCloseAndTrailR1Period);
                    autoCloseAndTrailR5HBuffer = EMA(High, AutoCloseAndTrailR5Period);
                    autoCloseAndTrailR5LBuffer = EMA(Low, AutoCloseAndTrailR5Period);

                    autoCloseAndTrailZL1Buffer = HMA(Close, AutoCloseAndTrailZL1Period);
                    autoCloseAndTrailZL2Buffer = HMA(Close, AutoCloseAndTrailZL2Period);

                    autoCloseAndTrailRLBuffer = SMA(Close, AutoCloseAndTrailRLPeriod);
                    autoCloseAndTrailDL1Buffer = SMA(Close, AutoCloseAndTrailDL1Period);
                    autoCloseAndTrailDL2Buffer = SMA(Close, AutoCloseAndTrailDL2Period);

                    autoCloseAndTrailDL3Buffer = SMA(Close, AutoCloseAndTrailDL3Period);
                    autoCloseAndTrailDL3HBuffer = SMA(High, AutoCloseAndTrailDL3Period);
                    autoCloseAndTrailDL3LBuffer = SMA(Low, AutoCloseAndTrailDL3Period);

                    autoCloseAndTrailDL4Buffer = SMA(Close, AutoCloseAndTrailDL4Period);
                    autoCloseAndTrailDL4HBuffer = SMA(High, AutoCloseAndTrailDL4Period);
                    autoCloseAndTrailDL4LBuffer = SMA(Low, AutoCloseAndTrailDL4Period);

                    isPopDropOnBarUpdateCycleReady = false;

                    if (BarsInProgress == 0 && ChartControl != null && timer == null)
                    {
                        if (ChartControl.Dispatcher.CheckAccess())
                        {
                            timer = new System.Windows.Threading.DispatcherTimer { Interval = new TimeSpan(0, 0, 0, 0, 1000), IsEnabled = true };
                            SubscribeToTimerTick(timer);
                        }
                        else
                        {
                            ChartControl.Dispatcher.InvokeAsync(() =>
                            {
                                timer = new System.Windows.Threading.DispatcherTimer { Interval = new TimeSpan(0, 0, 0, 0, 1000), IsEnabled = true };
                                SubscribeToTimerTick(timer);
                            });
                        }
                    }

                    if (ChartControl != null)
                    {
                        if (ChartControl.Dispatcher.CheckAccess())
                        {
                            SubscribeToPreviewMouseLeftButtonDown(ChartControl);
                        }
                        else
                        {
                            ChartControl.Dispatcher.InvokeAsync(() =>
                            {
                                SubscribeToPreviewMouseLeftButtonDown(ChartControl);
                            });
                        }
                    }

                    if (ChartControl != null)
                    {
                        if (ChartControl.Dispatcher.CheckAccess())
                        {
                            if (attachedInstrumentIsFuture)
                            {
                                SubscribeToMarketDataUpdate(this.attachedInstrument);

                                if (this.attachedInstrument != mnqInstrument) SubscribeToMarketDataUpdate(mnqInstrument);
                                if (this.attachedInstrument != mesInstrument) SubscribeToMarketDataUpdate(mesInstrument);
                                if (this.attachedInstrument != mymInstrument) SubscribeToMarketDataUpdate(mymInstrument);
                                if (this.attachedInstrument != m2kInstrument) SubscribeToMarketDataUpdate(m2kInstrument);

                                if (this.attachedInstrument != nqInstrument) SubscribeToMarketDataUpdate(nqInstrument);
                                if (this.attachedInstrument != esInstrument) SubscribeToMarketDataUpdate(esInstrument);
                                if (this.attachedInstrument != ymInstrument) SubscribeToMarketDataUpdate(ymInstrument);
                                if (this.attachedInstrument != rtyInstrument) SubscribeToMarketDataUpdate(rtyInstrument);
                            }
                        }
                        else
                        {
                            ChartControl.Dispatcher.InvokeAsync(() =>
                            {
                                if (attachedInstrumentIsFuture)
                                {
                                    SubscribeToMarketDataUpdate(this.attachedInstrument);

                                    if (this.attachedInstrument != mnqInstrument) SubscribeToMarketDataUpdate(mnqInstrument);
                                    if (this.attachedInstrument != mesInstrument) SubscribeToMarketDataUpdate(mesInstrument);
                                    if (this.attachedInstrument != mymInstrument) SubscribeToMarketDataUpdate(mymInstrument);
                                    if (this.attachedInstrument != m2kInstrument) SubscribeToMarketDataUpdate(m2kInstrument);

                                    if (this.attachedInstrument != nqInstrument) SubscribeToMarketDataUpdate(nqInstrument);
                                    if (this.attachedInstrument != esInstrument) SubscribeToMarketDataUpdate(esInstrument);
                                    if (this.attachedInstrument != ymInstrument) SubscribeToMarketDataUpdate(ymInstrument);
                                    if (this.attachedInstrument != rtyInstrument) SubscribeToMarketDataUpdate(rtyInstrument);
                                }
                            });
                        }
                    }


                    /*
                    if (IsStrategyAttachedToChart())
                    {
                        if (ChartControl != null)
                        {
                            if (ChartControl.Dispatcher.CheckAccess())
                            {
                                DrawButtonPanel();
                            }
                            else
                            {
                                ChartControl.Dispatcher.InvokeAsync((() =>
                                {

                                   DrawButtonPanel();
                                }));
                            }
                        }
                    }
                    */
                }
            }
            else if (State == State.Terminated)
            {
                signalName = "OnStateChange (State.Terminated)";
                if (this.DebugLogLevel > 10) RealLogger.PrintOutput("*** " + signalName + ":");

                CleanUpAllEvents(signalName);

                hasRanOnceFirstCycle = false;
                hasDrawnButtons = false;
                activeDayOverMaxLossAutoClose = false;
            }
        }



        //public override void CloseStrategy(string signalName)
        //{


        // base.CloseStrategy(signalName);
        //}


        protected override void OnConnectionStatusUpdate(ConnectionStatusEventArgs connectionStatusUpdate)
        {
            string signalName = "OnConnectionStatusUpdate";

            base.OnConnectionStatusUpdate(connectionStatusUpdate);

            if (connectionStatusUpdate.Status == ConnectionStatus.Disconnected)
            {
                CleanUpAllEvents(signalName);
            }

            //Print("*** DEBUG OnConnectionStatusUpdate from " + connectionStatusUpdate.PreviousStatus + " to " + connectionStatusUpdate.Status + " con=" + connectionStatusUpdate.Connection.Now + " pb=" + (NinjaTrader.Cbi.Connection.PlaybackConnection != null) + " acc=" + account);
        }

        private void CleanUpAllEvents(string signalName)
        {
            if (ChartControl != null)
            {
                if (ChartControl.Dispatcher.CheckAccess())
                {
                    if (attachedInstrumentServerSupported)
                    {
                        UnloadAccountEvents(signalName);
                    }
                }
                else
                {
                    ChartControl.Dispatcher.InvokeAsync(() =>
                    {
                        if (attachedInstrumentServerSupported)
                        {
                            UnloadAccountEvents(signalName);
                        }
                    });
                }
            }

            if (ChartControl != null)
            {
                if (ChartControl.Dispatcher.CheckAccess())
                {
                    if (attachedInstrumentServerSupported)
                    {
                        UnsubscribeToPreviewMouseLeftButtonDown(ChartControl);
                    }
                }
                else
                {
                    ChartControl.Dispatcher.InvokeAsync(() =>
                    {
                        if (attachedInstrumentServerSupported)
                        {
                            UnsubscribeToPreviewMouseLeftButtonDown(ChartControl);
                        }
                    });
                }
            }

            if (ChartControl != null && timer != null)
            {
                if (ChartControl.Dispatcher.CheckAccess())
                {
                    if (attachedInstrumentServerSupported)
                    {
                        UnsubscribeToTimerTick(timer);
                        timer = null;
                    }
                }
                else
                {
                    ChartControl.Dispatcher.InvokeAsync(() =>
                    {
                        if (attachedInstrumentServerSupported)
                        {
                            UnsubscribeToTimerTick(timer);
                            timer = null;
                        }
                    });
                }
            }

            if (ChartControl != null)
            {
                if (ChartControl.Dispatcher.CheckAccess())
                {
                    if (attachedInstrumentServerSupported)
                    {
                        RemoveButtonPanel();
                    }
                }
                else
                {
                    ChartControl.Dispatcher.InvokeAsync(() =>
                    {
                        if (attachedInstrumentServerSupported)
                        {
                            RemoveButtonPanel();
                        }
                    });
                }
            }

            if (ChartControl != null)
            {
                if (ChartControl.Dispatcher.CheckAccess())
                {
                    if (attachedInstrumentIsFuture)
                    {
                        UnsubscribeToMarketDataUpdate(this.attachedInstrument);

                        if (this.attachedInstrument != mnqInstrument) UnsubscribeToMarketDataUpdate(mnqInstrument);
                        if (this.attachedInstrument != mesInstrument) UnsubscribeToMarketDataUpdate(mesInstrument);
                        if (this.attachedInstrument != mymInstrument) UnsubscribeToMarketDataUpdate(mymInstrument);
                        if (this.attachedInstrument != m2kInstrument) UnsubscribeToMarketDataUpdate(m2kInstrument);

                        if (this.attachedInstrument != nqInstrument) UnsubscribeToMarketDataUpdate(nqInstrument);
                        if (this.attachedInstrument != esInstrument) UnsubscribeToMarketDataUpdate(esInstrument);
                        if (this.attachedInstrument != ymInstrument) UnsubscribeToMarketDataUpdate(ymInstrument);
                        if (this.attachedInstrument != rtyInstrument) UnsubscribeToMarketDataUpdate(rtyInstrument);
                    }
                }
                else
                {
                    ChartControl.Dispatcher.InvokeAsync(() =>
                    {
                        if (attachedInstrumentIsFuture)
                        {
                            UnsubscribeToMarketDataUpdate(this.attachedInstrument);

                            if (this.attachedInstrument != mnqInstrument) UnsubscribeToMarketDataUpdate(mnqInstrument);
                            if (this.attachedInstrument != mesInstrument) UnsubscribeToMarketDataUpdate(mesInstrument);
                            if (this.attachedInstrument != mymInstrument) UnsubscribeToMarketDataUpdate(mymInstrument);
                            if (this.attachedInstrument != m2kInstrument) UnsubscribeToMarketDataUpdate(m2kInstrument);

                            if (this.attachedInstrument != nqInstrument) UnsubscribeToMarketDataUpdate(nqInstrument);
                            if (this.attachedInstrument != esInstrument) UnsubscribeToMarketDataUpdate(esInstrument);
                            if (this.attachedInstrument != ymInstrument) UnsubscribeToMarketDataUpdate(ymInstrument);
                            if (this.attachedInstrument != rtyInstrument) UnsubscribeToMarketDataUpdate(rtyInstrument);
                        }
                    });
                }
            }
        }

        protected override void OnBarUpdate()
        {
            /*
            if (State != State.Historical)
            {
                //Print(String.Format("OnBarUpdate Bid: {0} Ask: {1} Last: {2}", GetCurrentBid(), GetCurrentAsk(), Close[0])); //debug
            }
            */

            if (attachedInstrumentServerSupported)
            {
                currentBarCount = CurrentBar;

                RefreshAccount();
                RefreshATMStrategyName();

                lastAccountIntradayExcessMargin = GetAccountIntradayExcessMargin();

                /*
                bool isNextChartTraderCycleReady = lastChartTraderCycleChangeTime <= GetDateTimeNow();

                if (isNextChartTraderCycleReady && State == State.Realtime)
                {
                    lastChartTraderCycleChangeTime = (GetDateTimeNow()).AddSeconds(ChartTraderCycleThrottleSeconds);

                    if (ChartControl != null)
                    {
                        ChartControl.Dispatcher.InvokeAsync(() =>
                        {
                            stopLossStroke = ChartControl.OwnerChart.ChartTrader.Properties.StopLoss;
                            profitTargetStroke = ChartControl.OwnerChart.ChartTrader.Properties.ProfitTarget;
                        });
                    }
                }
                */

                if (CurrentBar > 21)
                {
                    previous1ClosePrice = Close[1];
                    previous2ClosePrice = Close[2];
                    previous3ClosePrice = Close[3];
                    previous4ClosePrice = Close[4];
                    previous5ClosePrice = Close[5];
                    previous6ClosePrice = Close[6];
                    previous7ClosePrice = Close[7];
                    previous8ClosePrice = Close[8];
                    previous9ClosePrice = Close[9];
                    previous10ClosePrice = Close[10];
                    previous11ClosePrice = Close[11];
                    previous12ClosePrice = Close[12];
                    previous13ClosePrice = Close[13];
                    previous14ClosePrice = Close[14];
                    previous15ClosePrice = Close[15];
                    previous16ClosePrice = Close[16];
                    previous17ClosePrice = Close[17];
                    previous18ClosePrice = Close[18];
                    previous19ClosePrice = Close[19];
                    previous20ClosePrice = Close[20];
                    previous1HighPrice = High[1];
                    previous2HighPrice = High[2];
                    previous3HighPrice = High[3];
                    previous4HighPrice = High[4];
                    previous5HighPrice = High[5];
                    previous6HighPrice = High[6];
                    previous7HighPrice = High[7];
                    previous8HighPrice = High[8];
                    previous9HighPrice = High[9];
                    previous10HighPrice = High[10];
                    previous11HighPrice = High[11];
                    previous12HighPrice = High[12];
                    previous13HighPrice = High[13];
                    previous14HighPrice = High[14];
                    previous15HighPrice = High[15];
                    previous16HighPrice = High[16];
                    previous17HighPrice = High[17];
                    previous18HighPrice = High[18];
                    previous19HighPrice = High[19];
                    previous20HighPrice = High[20];

                    previous1LowPrice = Low[1];
                    previous2LowPrice = Low[2];
                    previous3LowPrice = Low[3];
                    previous4LowPrice = Low[4];
                    previous5LowPrice = Low[5];
                    previous6LowPrice = Low[6];
                    previous7LowPrice = Low[7];
                    previous8LowPrice = Low[8];
                    previous9LowPrice = Low[9];
                    previous10LowPrice = Low[10];
                    previous11LowPrice = Low[11];
                    previous12LowPrice = Low[12];
                    previous13LowPrice = Low[13];
                    previous14LowPrice = Low[14];
                    previous15LowPrice = Low[15];
                    previous16LowPrice = Low[16];
                    previous17LowPrice = Low[17];
                    previous18LowPrice = Low[18];
                    previous19LowPrice = Low[19];
                    previous20LowPrice = Low[20];

                    previous1CandleBullish = previous1ClosePrice >= previous2ClosePrice;
                    previous2CandleBullish = previous2ClosePrice >= previous3ClosePrice;
                    previous3CandleBullish = previous3ClosePrice >= previous4ClosePrice;
                    previous4CandleBullish = previous4ClosePrice >= previous5ClosePrice;
                    previous5CandleBullish = previous5ClosePrice >= previous6ClosePrice;
                    previous6CandleBullish = previous6ClosePrice >= previous7ClosePrice;
                    previous7CandleBullish = previous7ClosePrice >= previous8ClosePrice;
                    previous8CandleBullish = previous8ClosePrice >= previous9ClosePrice;
                }

                //snapPowerBoxBuffer.PowerBoxPeriodActual[1] != 0 && CurrentBar > snapPowerBoxBuffer.PowerBoxPeriodActual[1])

                if (CurrentBar > 4)
                {
                    stingRayHighLevel1Value = stingRayBuffer.SwingHigh1Level[1];
                    stingRayLowLevel1Value = stingRayBuffer.SwingLow1Level[1];

                    stingRayHighLevel2Value = stingRayBuffer.SwingHigh2Level[1];
                    stingRayLowLevel2Value = stingRayBuffer.SwingLow2Level[1];

                    stingRayHighLevel3Value = stingRayBuffer.SwingHigh3Level[1];
                    stingRayLowLevel3Value = stingRayBuffer.SwingLow3Level[1];

                    stingRayHighLevel4Value = stingRayBuffer.SwingHigh4Level[1];
                    stingRayLowLevel4Value = stingRayBuffer.SwingLow4Level[1];

                    stingRayHighLevel5Value = stingRayBuffer.SwingHigh5Level[1];
                    stingRayLowLevel5Value = stingRayBuffer.SwingLow5Level[1];

                    stingRayRecentHigherHighValue = stingRayBuffer.RecentHigherHigh[1];
                    stingRayRecentLowerLowValue = stingRayBuffer.RecentLowerLow[1];

                    stingRayCreeperCycleCountValue = stingRayBuffer.CreeperCycleCount[1];

                    if (runSysCheckFlag)
                    {
                        int thComponentSysCheckValue = GetTHComponentSysCheck();

                        if (thComponentSysCheckValue > 0)
                        {
                            RealLogger.PrintOutput("SYSCHECK: Detecting THComponent Full (" + thComponentSysCheckValue + ")");
                        }
                        else
                        {
                            RealLogger.PrintOutput("SYSCHECK: Detecting THComponent Stub (" + thComponentSysCheckValue + ")");
                        }

                        int stingRaySysCheckValue = stingRayBuffer.GetStingRaySysCheck();

                        if (stingRaySysCheckValue > 0)
                        {
                            RealLogger.PrintOutput("SYSCHECK: Detecting StringRay Full (" + stingRaySysCheckValue + ")");
                        }
                        else
                        {
                            RealLogger.PrintOutput("SYSCHECK: Detecting StringRay Stub (" + stingRaySysCheckValue + ")");
                        }

                        runSysCheckFlag = false;
                    }


                    stingRaySurgeBarCountValue = stingRayBuffer.SurgeBarCount[1];
                    stingRaySurgeBarCycleTickSpeedValue = stingRayBuffer.SurgeBarCycleTickSpeed[1];

                    stingRayGush1BarCountValue = stingRayBuffer.Gush1BarCount[1];
                    stingRayGush1BarCycleTickSpeedValue = stingRayBuffer.Gush1BarCycleTickSpeed[1];

                    stingRayFlow1BarCountValue = stingRayBuffer.Flow1BarCount[1];
                    stingRayFlow1BarCycleTickSpeedValue = stingRayBuffer.Flow1BarCycleTickSpeed[1];
                    stingRayFlow2BarCountValue = stingRayBuffer.Flow2BarCount[1];
                    stingRayFlow2BarCycleTickSpeedValue = stingRayBuffer.Flow2BarCycleTickSpeed[1];
                    stingRayFlow3BarCountValue = stingRayBuffer.Flow3BarCount[1];
                    stingRayFlow3BarCycleTickSpeedValue = stingRayBuffer.Flow3BarCycleTickSpeed[1];
                    stingRayFlow4BarCountValue = stingRayBuffer.Flow4BarCount[1];
                    stingRayFlow4BarCycleTickSpeedValue = stingRayBuffer.Flow4BarCycleTickSpeed[1];
                }

                if (CurrentBar > KeltnerPeriod && CurrentBar > KeltnerATRPeriod)
                {
                    if (CurrentBar > 2)
                    {
                        keltnerUpperInnerRingValue = keltnerATRBuffer.UpperLevel2[1];
                        keltnerLowerInnerRingValue = keltnerATRBuffer.LowerLevel2[1];
                    }
                }

                if (CurrentBar > SnapPowerBoxPeriod)
                {
                    if (CurrentBar > 2)
                    {
                        snapPowerBoxMiddleValue = snapPowerBoxBuffer.MeanChange[1];
                        snapPowerBoxUpperValue = snapPowerBoxBuffer.Upper[1];
                        snapPowerBoxLowerValue = snapPowerBoxBuffer.Lower[1];
                    }

                    if (CurrentBar > 11)
                    {
                        snapPowerBoxUpperValue10 = snapPowerBoxBuffer.Upper[10];
                        snapPowerBoxLowerValue10 = snapPowerBoxBuffer.Lower[10];
                    }

                    if (CurrentBar > 21)
                    {
                        snapPowerBoxUpperValue20 = snapPowerBoxBuffer.Upper[20];
                        snapPowerBoxLowerValue20 = snapPowerBoxBuffer.Lower[20];
                    }

                    if (CurrentBar > 31)
                    {
                        snapPowerBoxUpperValue30 = snapPowerBoxBuffer.Upper[30];
                        snapPowerBoxLowerValue30 = snapPowerBoxBuffer.Lower[30];
                    }

                    if (CurrentBar > 41)
                    {
                        snapPowerBoxUpperValue40 = snapPowerBoxBuffer.Upper[40];
                        snapPowerBoxLowerValue40 = snapPowerBoxBuffer.Lower[40];
                    }

                    if (CurrentBar > 51)
                    {
                        snapPowerBoxUpperValue50 = snapPowerBoxBuffer.Upper[50];
                        snapPowerBoxLowerValue50 = snapPowerBoxBuffer.Lower[50];
                    }
                }

                if (CurrentBar > AutoCloseAndTrailMA3Period)
                {
                    autoCloseAndTrailKLine1Value = autoCloseAndTrailKLine1Buffer.TrailingStop[1];
                    autoCloseAndTrailKLine2Value = autoCloseAndTrailKLine2Buffer.TrailingStop[1];

                    autoPilotSetupZombieValue = autoPilotSetupZombieBuffer.ZombieSetupStatus[1];
                    autoPilotSetupZombieValue2 = autoPilotSetupZombieBuffer.ZombieSetupStatus[2];
                    autoPilotSetupZombieValue3 = autoPilotSetupZombieBuffer.ZombieSetupStatus[3];
                    autoPilotSetupZombieValue4 = autoPilotSetupZombieBuffer.ZombieSetupStatus[4];
                    autoPilotSetupZombieValue5 = autoPilotSetupZombieBuffer.ZombieSetupStatus[5];
                    autoPilotSetupZombieValue6 = autoPilotSetupZombieBuffer.ZombieSetupStatus[6];
                    autoPilotSetupZombieValue7 = autoPilotSetupZombieBuffer.ZombieSetupStatus[7];
                    autoPilotSetupZombieValue8 = autoPilotSetupZombieBuffer.ZombieSetupStatus[8];
                    autoPilotSetupZombieValue9 = autoPilotSetupZombieBuffer.ZombieSetupStatus[9];
                    autoPilotSetupZombieValue10 = autoPilotSetupZombieBuffer.ZombieSetupStatus[10];

                    autoPilotSetupZombieBuyContinuation1 = autoPilotSetupZombieValue == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation2 = autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation3 = autoPilotSetupZombieValue3 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation4 = autoPilotSetupZombieValue4 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation5 = autoPilotSetupZombieValue5 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation6 = autoPilotSetupZombieValue6 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation7 = autoPilotSetupZombieValue7 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuyContinuation8 = autoPilotSetupZombieValue8 == ZombieSetupBuyCode;

                    autoPilotSetupZombieSellContinuation1 = autoPilotSetupZombieValue == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation2 = autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation3 = autoPilotSetupZombieValue3 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation4 = autoPilotSetupZombieValue4 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation5 = autoPilotSetupZombieValue5 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation6 = autoPilotSetupZombieValue6 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation7 = autoPilotSetupZombieValue7 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellContinuation8 = autoPilotSetupZombieValue8 == ZombieSetupSellCode;

                    double autoPilotSetupZombie2Value = autoPilotSetupZombie2Buffer.ZombieSetupStatus[1];
                    autoPilotSetupZombie2BuyContinuation1 = autoPilotSetupZombie2Value == ZombieSetupBuyCode;
                    autoPilotSetupZombie2SellContinuation1 = autoPilotSetupZombie2Value == ZombieSetupSellCode;


                    autoPilotSetupZombieBuySetup1 = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup1 = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup2 = autoPilotSetupZombieValue2 == ZombieSetupBuyCode && autoPilotSetupZombieValue3 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup2 = autoPilotSetupZombieValue2 == ZombieSetupSellCode && autoPilotSetupZombieValue3 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup3 = autoPilotSetupZombieValue3 == ZombieSetupBuyCode && autoPilotSetupZombieValue4 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup3 = autoPilotSetupZombieValue3 == ZombieSetupSellCode && autoPilotSetupZombieValue4 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup4 = autoPilotSetupZombieValue4 == ZombieSetupBuyCode && autoPilotSetupZombieValue5 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup4 = autoPilotSetupZombieValue4 == ZombieSetupSellCode && autoPilotSetupZombieValue5 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup5 = autoPilotSetupZombieValue5 == ZombieSetupBuyCode && autoPilotSetupZombieValue6 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup5 = autoPilotSetupZombieValue5 == ZombieSetupSellCode && autoPilotSetupZombieValue6 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup6 = autoPilotSetupZombieValue6 == ZombieSetupBuyCode && autoPilotSetupZombieValue7 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup6 = autoPilotSetupZombieValue6 == ZombieSetupSellCode && autoPilotSetupZombieValue7 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup7 = autoPilotSetupZombieValue7 == ZombieSetupBuyCode && autoPilotSetupZombieValue8 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup7 = autoPilotSetupZombieValue7 == ZombieSetupSellCode && autoPilotSetupZombieValue8 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup8 = autoPilotSetupZombieValue8 == ZombieSetupBuyCode && autoPilotSetupZombieValue9 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup8 = autoPilotSetupZombieValue8 == ZombieSetupSellCode && autoPilotSetupZombieValue9 == ZombieSetupBuyCode;
                    autoPilotSetupZombieBuySetup9 = autoPilotSetupZombieValue9 == ZombieSetupBuyCode && autoPilotSetupZombieValue10 == ZombieSetupSellCode;
                    autoPilotSetupZombieSellSetup9 = autoPilotSetupZombieValue9 == ZombieSetupSellCode && autoPilotSetupZombieValue10 == ZombieSetupBuyCode;

                    if (autoPilotSetupZombieBuySetup1)
                    {
                        recentZombieBuyLowPrice = Math.Min(previous1LowPrice, previous2LowPrice);
                        if (recentZombieSellLowPrice > 0) recentZombieBuyLowPrice = Math.Min(recentZombieBuyLowPrice, recentZombieSellLowPrice);
                        recentZombieBuyHighPrice = 0;
                        recentZombieSellHighPrice = previous1HighPrice;
                        recentZombieSellLowPrice = 0;
                    }
                    else if (autoPilotSetupZombieBuyContinuation1)
                    {
                        recentZombieBuyLowPrice = Math.Min(previous1LowPrice, recentZombieBuyLowPrice);
                        recentZombieSellHighPrice = Math.Max(previous1HighPrice, recentZombieSellHighPrice);
                    }
                    else if (autoPilotSetupZombieSellSetup1)
                    {
                        recentZombieSellHighPrice = Math.Max(previous1HighPrice, previous2HighPrice);
                        if (recentZombieBuyHighPrice > 0) recentZombieSellHighPrice = Math.Max(recentZombieSellHighPrice, recentZombieBuyHighPrice);
                        recentZombieSellLowPrice = 0;
                        recentZombieBuyHighPrice = previous1HighPrice;
                        recentZombieBuyLowPrice = 0;
                    }
                    else if (autoPilotSetupZombieSellContinuation1)
                    {
                        recentZombieBuyHighPrice = Math.Max(previous1HighPrice, recentZombieBuyHighPrice);
                        recentZombieSellLowPrice = Math.Min(previous1LowPrice, recentZombieSellLowPrice);
                    }


                    autoPilotSetupWalkerValue = autoPilotSetupWalkerBuffer[1];
                    autoPilotSetupWalkerValue2 = autoPilotSetupWalkerBuffer[2];

                    autoPilotSpeedLineFilterValue = autoPilotSpeedLineFilterBuffer[1];
                    autoPilotSpeedLineFilterValue2 = autoPilotSpeedLineFilterBuffer[2];
                    autoPilotSpeedLineFilterValue3 = autoPilotSpeedLineFilterBuffer[3];
                    autoPilotSpeedLineFilterValue4 = autoPilotSpeedLineFilterBuffer[4];
                    autoPilotSpeedLineFilterValue5 = autoPilotSpeedLineFilterBuffer[5];
                    autoPilotSpeedLineFilterValue6 = autoPilotSpeedLineFilterBuffer[6];
                    autoPilotSpeedLineFilterValue7 = autoPilotSpeedLineFilterBuffer[7];
                    autoPilotSpeedLineFilterValue8 = autoPilotSpeedLineFilterBuffer[8];
                    autoPilotSpeedLineFilterValue9 = autoPilotSpeedLineFilterBuffer[9];
                    autoPilotSpeedLineFilterValue10 = autoPilotSpeedLineFilterBuffer[10];

                    autoPilotSetupCreeperValue = autoPilotSetupCreeperBuffer.AvgChange[1];
                    autoPilotSetupCreeperValue2 = autoPilotSetupCreeperBuffer.AvgChange[2];
                    autoPilotSetupCreeperValue3 = autoPilotSetupCreeperBuffer.AvgChange[3];
                    autoPilotSetupCreeperValue4 = autoPilotSetupCreeperBuffer.AvgChange[4];
                    autoPilotSetupCreeperValue5 = autoPilotSetupCreeperBuffer.AvgChange[5];
                    autoPilotSetupCreeperValue6 = autoPilotSetupCreeperBuffer.AvgChange[6];
                    autoPilotSetupCreeperValue7 = autoPilotSetupCreeperBuffer.AvgChange[7];
                    autoPilotSetupCreeperValue8 = autoPilotSetupCreeperBuffer.AvgChange[8];
                    autoPilotSetupCreeperValue9 = autoPilotSetupCreeperBuffer.AvgChange[9];
                    autoPilotSetupCreeperValue10 = autoPilotSetupCreeperBuffer.AvgChange[10];

                    bool altBuyCreeperSetup1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;
                    bool altSellCreeperSetup1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;

                    autoPilotSetupCreeperBuyContinuation1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2;
                    autoPilotSetupCreeperSellContinuation1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2;

                    if (altBuyCreeperSetup1)
                    {
                        recentCreeperBuyLowPrice = Math.Min(Math.Min(previous1LowPrice, previous2LowPrice), previous3LowPrice);
                        if (recentCreeperSellLowPrice > 0) recentCreeperBuyLowPrice = Math.Min(recentCreeperBuyLowPrice, recentCreeperSellLowPrice);
                        recentCreeperBuyHighPrice = previous1HighPrice;
                        recentCreeperSellHighPrice = 0;
                        recentCreeperSellLowPrice = 0;
                    }
                    else if (autoPilotSetupCreeperBuyContinuation1)
                    {
                        recentCreeperBuyLowPrice = Math.Min(previous1LowPrice, recentCreeperBuyLowPrice);
                        recentCreeperBuyHighPrice = Math.Max(previous1HighPrice, recentCreeperBuyHighPrice);
                    }
                    else if (altSellCreeperSetup1)
                    {
                        recentCreeperSellHighPrice = Math.Max(Math.Max(previous1HighPrice, previous2HighPrice), previous3HighPrice);
                        if (recentCreeperBuyHighPrice > 0) recentCreeperSellHighPrice = Math.Max(recentCreeperSellHighPrice, recentCreeperBuyHighPrice);
                        recentCreeperBuyHighPrice = 0;
                        recentCreeperBuyLowPrice = 0;
                        recentCreeperSellLowPrice = previous1LowPrice;
                    }
                    else if (autoPilotSetupCreeperSellContinuation1)
                    {
                        recentCreeperSellHighPrice = Math.Max(previous1HighPrice, recentCreeperSellHighPrice);
                        recentCreeperSellLowPrice = Math.Min(previous1LowPrice, recentCreeperBuyLowPrice);
                    }


                    autoCloseAndTrailMA1Value = autoCloseAndTrailMA1Buffer[1];
                    autoCloseAndTrailMA1Value2 = autoCloseAndTrailMA1Buffer[2];
                    autoCloseAndTrailMA1Value3 = autoCloseAndTrailMA1Buffer[3];
                    autoCloseAndTrailMA2Value = autoCloseAndTrailMA2Buffer[1];
                    autoCloseAndTrailMA2Value2 = autoCloseAndTrailMA2Buffer[2];
                    autoCloseAndTrailMA2Value3 = autoCloseAndTrailMA2Buffer[3];
                    autoCloseAndTrailMA3Value = autoCloseAndTrailMA3Buffer[1];
                    autoCloseAndTrailMA3Value2 = autoCloseAndTrailMA3Buffer[2];
                    autoCloseAndTrailMA3Value3 = autoCloseAndTrailMA3Buffer[3];
                }

                if (CurrentBar > AutoCloseAndTrailMA4Period + 10)
                {
                    autoCloseAndTrailMA4Value = autoCloseAndTrailMA4Buffer[1];
                    autoCloseAndTrailMA4Value2 = autoCloseAndTrailMA4Buffer[2];
                    autoCloseAndTrailMA4Value3 = autoCloseAndTrailMA4Buffer[3];
                    autoCloseAndTrailMA4Value4 = autoCloseAndTrailMA4Buffer[4];
                    autoCloseAndTrailMA4Value5 = autoCloseAndTrailMA4Buffer[5];
                    autoCloseAndTrailMA4Value6 = autoCloseAndTrailMA4Buffer[6];
                    autoCloseAndTrailMA4Value7 = autoCloseAndTrailMA4Buffer[7];
                    autoCloseAndTrailMA4Value8 = autoCloseAndTrailMA4Buffer[8];
                    autoCloseAndTrailMA4Value9 = autoCloseAndTrailMA4Buffer[9];
                    autoCloseAndTrailMA4Value10 = autoCloseAndTrailMA4Buffer[10];

                    autoPilotBullishRiverTrend = (Close[1] >= autoCloseAndTrailMA4Value4);
                }

                if (CurrentBar > AutoCloseAndTrailR1Period)
                {
                    autoCloseAndTrailR1HValue = autoCloseAndTrailR1HBuffer[1];
                    autoCloseAndTrailR1LValue = autoCloseAndTrailR1LBuffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailR5Period)
                {
                    autoCloseAndTrailR5HValue = autoCloseAndTrailR5HBuffer[1];
                    autoCloseAndTrailR5LValue = autoCloseAndTrailR5LBuffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailZL1Period)
                {
                    autoCloseAndTrailZL1Value = autoCloseAndTrailZL1Buffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailZL2Period)
                {
                    autoCloseAndTrailZL2Value = autoCloseAndTrailZL2Buffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailRLPeriod + 4)
                {
                    autoCloseAndTrailRLValue = autoCloseAndTrailRLBuffer[1];
                    autoCloseAndTrailRLValue2 = autoCloseAndTrailRLBuffer[2];
                    autoCloseAndTrailRLValue3 = autoCloseAndTrailRLBuffer[3];
                    autoCloseAndTrailRLValue4 = autoCloseAndTrailRLBuffer[4];
                }

                if (CurrentBar > AutoCloseAndTrailDL1Period)
                {
                    autoCloseAndTrailDL1Value = autoCloseAndTrailDL1Buffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailDL2Period)
                {
                    autoCloseAndTrailDL2Value = autoCloseAndTrailDL2Buffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailDL3Period)
                {
                    autoCloseAndTrailDL3Value = autoCloseAndTrailDL3Buffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailDL4Period + 15)
                {
                    autoCloseAndTrailDL4Value = autoCloseAndTrailDL4Buffer[1];
                    autoCloseAndTrailDL4Value2 = autoCloseAndTrailDL4Buffer[2];
                    autoCloseAndTrailDL4Value3 = autoCloseAndTrailDL4Buffer[3];
                    autoCloseAndTrailDL4Value4 = autoCloseAndTrailDL4Buffer[4];
                    autoCloseAndTrailDL4Value5 = autoCloseAndTrailDL4Buffer[5];
                    autoCloseAndTrailDL4Value6 = autoCloseAndTrailDL4Buffer[6];
                    autoCloseAndTrailDL4Value7 = autoCloseAndTrailDL4Buffer[7];
                    autoCloseAndTrailDL4Value8 = autoCloseAndTrailDL4Buffer[8];
                    autoCloseAndTrailDL4Value9 = autoCloseAndTrailDL4Buffer[9];
                    autoCloseAndTrailDL4Value10 = autoCloseAndTrailDL4Buffer[10];
                    autoCloseAndTrailDL4Value11 = autoCloseAndTrailDL4Buffer[11];
                    autoCloseAndTrailDL4Value12 = autoCloseAndTrailDL4Buffer[12];
                    autoCloseAndTrailDL4Value13 = autoCloseAndTrailDL4Buffer[13];
                    autoCloseAndTrailDL4Value14 = autoCloseAndTrailDL4Buffer[14];
                    autoCloseAndTrailDL4Value15 = autoCloseAndTrailDL4Buffer[15];

                    autoPilotBullishDriftTrend = (Close[1] >= autoCloseAndTrailDL4Value);
                }

                if (CurrentBar > AutoCloseAndTrailDL3Period)
                {
                    autoCloseAndTrailDL3HValue = autoCloseAndTrailDL3HBuffer[1];
                    autoCloseAndTrailDL3LValue = autoCloseAndTrailDL3LBuffer[1];
                }

                if (CurrentBar > AutoCloseAndTrailDL4Period)
                {
                    autoCloseAndTrailDL4HValue = autoCloseAndTrailDL4HBuffer[1];
                    autoCloseAndTrailDL4LValue = autoCloseAndTrailDL4LBuffer[1];
                }

                if (CurrentBar > AutoPilotSetupFilterPeriod)
                {
                    autoPilotBullishTrend = (Close[1] >= autoPilotFilterBuffer[1]);
                }

                if (StopLossInitialATRMultiplier > 0 || TakeProfitInitialATRMultiplier > 0 || ECATargetATRMultiplierPerVolume > 0)
                {
                    if (CurrentBar > ATRPeriod)
                    {
                        atrValue = atrBuffer[1];
                    }
                }


                if (CurrentBar > 4 && IsFirstTickOfBar)
                {
                    //bool isPriceAbovePBMiddle = previous1ClosePrice >= snapPowerBoxMiddleValue;
                    //bool isPriceBelowPBMiddle = previous1ClosePrice <= snapPowerBoxMiddleValue;

                    bool twoOrMoreBullish = (previous1CandleBullish && previous2CandleBullish)
                                || (previous1CandleBullish && previous3CandleBullish)
                                || (previous2CandleBullish && previous3CandleBullish);

                    bool twoOrMoreBearish = (!previous1CandleBullish && !previous2CandleBullish)
                        || (!previous1CandleBullish && !previous3CandleBullish)
                        || (!previous2CandleBullish && !previous3CandleBullish);

                    if (!inBuySliderSetupCycle)
                    {
                        bool buySlider = (twoOrMoreBearish
                            && previous1HighPrice <= previous2HighPrice && previous2HighPrice <= previous3HighPrice
                            && previous1HighPrice <= autoCloseAndTrailRLValue
                            && previous2HighPrice <= autoCloseAndTrailRLValue2
                            && previous3HighPrice <= autoCloseAndTrailRLValue3);
                    }
                    else
                    {
                        bool buySliderBroken = (!twoOrMoreBearish
                            || previous1HighPrice > previous2HighPrice
                            || previous1HighPrice > autoCloseAndTrailRLValue);

                        if (buySliderBroken)
                        {
                            inBuySliderSetupCycle = false;
                            usedBuySliderSetupCycle = false;
                        }
                    }

                    if (!inSellSliderSetupCycle)
                    {
                        bool sellSlider = (twoOrMoreBullish
                            && previous1LowPrice >= previous2LowPrice && previous2LowPrice >= previous3LowPrice
                            && previous1LowPrice >= autoCloseAndTrailRLValue
                            && previous2LowPrice >= autoCloseAndTrailRLValue2
                            && previous3LowPrice >= autoCloseAndTrailRLValue3);

                        if (sellSlider) inSellSliderSetupCycle = true;
                    }
                    else
                    {
                        bool sellSliderBroken = (!twoOrMoreBullish
                            || previous1LowPrice < previous2LowPrice
                            || previous1LowPrice < autoCloseAndTrailRLValue);

                        if (sellSliderBroken)
                        {
                            inSellSliderSetupCycle = false;
                            usedSellSliderSetupCycle = false;
                        }
                    }
                }


                RefreshObjects();

                isPopDropOnBarUpdateCycleReady = true;

                if (CurrentBar > 5) //keep code block at bottom after values set
                {
                    if (IsFirstTickOfBar)
                    {
                        AutoPilotRunOncePerBar.SetNewBar();
                        AutoAddOnRunOncePerBar.SetNewBar();
                        AutoCloseRunOncePerBar.SetNewBar();
                        AutoBreakEvenRunOncePerBar.SetNewBar();
                        PopDelayedEntryRunOncePerBar.SetNewBar();
                    }
                }

                //RealLogger.PrintOutput("atrValue[0]=" + atrValue[0].ToString());
            }
        }

        private double GetBarPeriodSecondInterval(BarsPeriod barPeriod)
        {
            double returnInverval = BarPeriodSecondInterval;

            if (barPeriod != null)
            {
                if (barPeriod.BarsPeriodType == BarsPeriodType.Minute)
                {
                    returnInverval = barPeriod.Value * 60;
                }
                else if (barPeriod.BarsPeriodType == BarsPeriodType.Second)
                {
                    returnInverval = barPeriod.Value;
                }
            }

            return returnInverval;
        }
        private void RefreshObjects()
        {
            HandleEntryVolumeAutoStatusChange();

            HandleEntryVolumeMaxStatusChange();

            HandleAutoPilotStatusChange();

            HandleAutoPilotLiteStatusChange();

            HandleAutoPilotProfileStatusChange();

            HandleAutoAddOnStatusChange();

            HandleTradeSignalStatusChange();

            HandleAutoCloseStatusChange();

            HandleAutoBreakEvenStatusChange();

            HandleProfitTargetStatusChange();
        }

        private void HandleAutoPilotLiteStatusChange()
        {
            if (lastAutoPilotLiteChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastAutoPilotLiteChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleAutoPilotButton != null)
                    {
                        //string nextAutoPilotLiteButtonText = "";
                        //string nextAutoPilotLiteButtonToolTip = "";

                        //GetAutoPilotButtonText(nextAutoPilotStatus, out nextAutoPilotLiteButtonText, out nextAutoPilotLiteButtonToolTip);

                        currentAutoPilotLiteStatus = nextAutoPilotLiteStatus;

                        lastAutoPilotLiteChangeTime = DateTime.MinValue;
                        nextAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleAutoPilotButton.Background = buttonBGColor;
                            //toggleAutoPilotButton.Content = nextAutoPilotLiteButtonText;
                            //toggleAutoPilotButton.ToolTip = nextAutoPilotLiteButtonToolTip;
                        }));
                        RealLogger.PrintOutput("Activated autopilot lite type " + currentAutoPilotLiteStatus + " (" + currentAutoPilotSetupStatus + " / SpeedLineFilter=" + UseAutoPilotSpeedLineFilter.ToString().ToLower() + " / AutoPilotAddOn=" + useAutoPilotAddOnFlag.ToString().ToLower() + ")");
                    }
                }
            }
        }

        private void HandleAutoPilotStatusChange()
        {
            if (lastAutoPilotChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastAutoPilotChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleAutoPilotButton != null)
                    {
                        string nextAutoPilotButtonText = "";
                        string nextAutoPilotButtonToolTip = "";

                        GetAutoPilotButtonText(nextAutoPilotStatus, out nextAutoPilotButtonText, out nextAutoPilotButtonToolTip);

                        currentAutoPilotStatus = nextAutoPilotStatus;

                        lastAutoPilotChangeTime = DateTime.MinValue;
                        nextAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentAutoPilotStatus == TickHunterAutoPilotTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleAutoPilotButton.Background = buttonBGColor;
                            toggleAutoPilotButton.Content = nextAutoPilotButtonText;
                            toggleAutoPilotButton.ToolTip = nextAutoPilotButtonToolTip;
                        }));
                        RealLogger.PrintOutput("Activated autopilot type " + currentAutoPilotStatus + " (" + currentTradeSignalStatus + " / " + currentAutoPilotSetupStatus + " / SpeedLineFilter=" + UseAutoPilotSpeedLineFilter.ToString().ToLower() + " / AutoPilotAddOn=" + useAutoPilotAddOnFlag.ToString().ToLower() + ")");
                    }
                }
            }
        }

        private void HandleTradeSignalStatusChange()
        {
            if (lastTradeSignalChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastTradeSignalChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleTradeSignalButton != null)
                    {
                        currentTradeSignalStatus = nextTradeSignalStatus;
                        lastTradeSignalChangeTime = DateTime.MinValue;
                        nextTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentTradeSignalStatus == TickHunterTradeSignalTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleTradeSignalButton.Background = buttonBGColor;
                        }));
                        RealLogger.PrintOutput("Activated trade signal type " + currentTradeSignalStatus + " (" + currentAutoPilotSetupStatus + " / SpeedLineFilter=" + UseAutoPilotSpeedLineFilter.ToString().ToLower() + ")");
                    }
                }
            }
        }

        private void HandleAutoPilotProfileStatusChange()
        {
            string signalName = "HandleAutoPilotProfileStatusChange";

            if (lastAutoPilotProfileChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastAutoPilotProfileChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleAutoPilotProfileButton != null)
                    {
                        const int colorDelaySeconds = 0;

                        if (nextAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Peppy)
                        {
                            currentAutoPilotSetupStatus = TickHunterAutoPilotSetupTypes.PeppySetupCombo;
                            //currentAutoPilotOrderStatus = TickHunterAutoPilotOrderTypes.MarketPop;
                            //currentStopLossInitialSnapStatus = TickHunterStopLossSnapTypes.SnapProfilePeppy;

                            breakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit;

                            //closeAutoMinProfitFlag = false;
                            limitTrancheVolumeToInProfitFlag = (true && MaxInitialTrancheVolumeSize > 0);
                            limitTrancheVolumePerBarFlag = (true && MinTrancheVolumeDelaySeconds > 0);
                            popCTRLDelayedEntryFlag = !UsePeppyLimitPopDelayedEntry;
                            popLimitToPullbackFlag = UsePeppyLimitPopToPullback;

                            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                            {
                                string buttonText = "";
                                string buttonToolTip = "";

                                DeactivateBuyPopButton(signalName);
                                DeactivateSellPopButton(signalName);

                                GetPopButtonText(TickHunterPopTypes.PopPlus, currentBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                                Brush buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.Blue : Brushes.DimGray;

                                SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, currentBuyPopDelayedStatus, 0, buttonBGColor);

                                GetPopButtonText(TickHunterPopTypes.PopMinus, currentSellPopDelayedStatus, out buttonText, out buttonToolTip);
                                buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.OrangeRed : Brushes.DimGray;

                                SetSellPopButton(SellPopButton, buttonText, buttonToolTip, currentSellPopDelayedStatus, 0, buttonBGColor);
                                /*
                                lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.CreeperFlip;
                                GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);
                                SetAutoCloseButton(toggleAutoCloseButton, buttonText, buttonToolTip,
                                    lastToggleEntryCloseAutoStatus, colorDelaySeconds, Brushes.DimGray);
                                */
                                lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                                GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);
                                SetAutoBEButton(toggleAutoBEButton, buttonText, buttonToolTip,
                                    lastToggleEntryBreakEvenAutoStatus, colorDelaySeconds, toggleAutoBEButton.Background);

                            }));
                        }
                        else if (nextAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Sleepy)
                        {
                            currentAutoPilotSetupStatus = TickHunterAutoPilotSetupTypes.SleepySetupCombo;
                            //currentAutoPilotOrderStatus = TickHunterAutoPilotOrderTypes.MarketPop;
                            //currentStopLossInitialSnapStatus = TickHunterStopLossSnapTypes.SnapProfileSleepy;

                            breakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit;

                            //closeAutoMinProfitFlag = false;
                            limitTrancheVolumeToInProfitFlag = (true && MaxInitialTrancheVolumeSize > 0);
                            limitTrancheVolumePerBarFlag = (true && MinTrancheVolumeDelaySeconds > 0);
                            popCTRLDelayedEntryFlag = !UseSleepyLimitPopDelayedEntry;
                            popLimitToPullbackFlag = UseSleepyLimitPopToPullback;

                            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                            {
                                string buttonText = "";
                                string buttonToolTip = "";

                                DeactivateBuyPopButton(signalName);
                                DeactivateSellPopButton(signalName);

                                GetPopButtonText(TickHunterPopTypes.PopPlus, currentBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                                Brush buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.Blue : Brushes.DimGray;

                                SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, currentBuyPopDelayedStatus, 0, buttonBGColor);

                                GetPopButtonText(TickHunterPopTypes.PopMinus, currentSellPopDelayedStatus, out buttonText, out buttonToolTip);
                                buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.OrangeRed : Brushes.DimGray;

                                SetSellPopButton(SellPopButton, buttonText, buttonToolTip, currentSellPopDelayedStatus, 0, buttonBGColor);

                                /*
                                lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;
                                GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);
                                SetAutoCloseButton(toggleAutoCloseButton, buttonText, buttonToolTip,
                                    lastToggleEntryCloseAutoStatus, colorDelaySeconds, Brushes.DimGray);
                                */

                                lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                                GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);
                                SetAutoBEButton(toggleAutoBEButton, buttonText, buttonToolTip,
                                    lastToggleEntryBreakEvenAutoStatus, colorDelaySeconds, toggleAutoBEButton.Background);

                            }));
                        }
                        else
                        {
                            currentAutoPilotSetupStatus = AutoPilotSetupType;
                            //currentAutoPilotOrderStatus = AutoPilotOrderType;
                            //currentStopLossInitialSnapStatus = StopLossInitialSnapType;

                            breakEvenAutoTrailNowFlag = BreakEvenAutoTrailNow;

                            //closeAutoMinProfitFlag = UseAutoCloseMinProfit;
                            limitTrancheVolumeToInProfitFlag = (LimitTrancheVolumeToInProfit && MaxInitialTrancheVolumeSize > 0);
                            limitTrancheVolumePerBarFlag = (LimitTrancheVolumePerBar && MinTrancheVolumeDelaySeconds > 0);
                            popCTRLDelayedEntryFlag = UsePopCTRLDelayedEntry;
                            popLimitToPullbackFlag = UsePopLimitToPullback;

                            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                            {
                                string buttonText = "";
                                string buttonToolTip = "";

                                DeactivateBuyPopButton(signalName);
                                DeactivateSellPopButton(signalName);

                                GetPopButtonText(TickHunterPopTypes.PopPlus, currentBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                                Brush buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.Blue : Brushes.DimGray;

                                SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, currentBuyPopDelayedStatus, 0, buttonBGColor);

                                GetPopButtonText(TickHunterPopTypes.PopMinus, currentSellPopDelayedStatus, out buttonText, out buttonToolTip);
                                buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.OrangeRed : Brushes.DimGray;

                                SetSellPopButton(SellPopButton, buttonText, buttonToolTip, currentSellPopDelayedStatus, 0, buttonBGColor);
                                //DisableAutoCloseButton(colorDelaySeconds);

                                //DisableAutoBEButton(colorDelaySeconds);
                            }));
                        }

                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            if (UseAutoPilotLite)
                            {
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotLiteButton(toggleAutoPilotButton, buttonText, buttonToolTip,
                                        lastToggleEntryAutoPilotLiteStatus, 0, Brushes.DimGray);
                            }
                            else
                            {
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotButton(toggleAutoPilotButton, buttonText, buttonToolTip,
                                        lastToggleEntryAutoPilotStatus, 0, Brushes.DimGray);
                            }
                        }));

                        RealLogger.PrintOutput("Activating auto pilot profile feature: currentAutoPilotSetupType=" + currentAutoPilotSetupStatus.ToString());
                        RealLogger.PrintOutput("Activating auto pilot profile feature: currentAutoPilotProfileSetupStatus=" + currentAutoPilotProfileSetupStatus.ToString());
                        RealLogger.PrintOutput("Activating auto pilot profile feature: currentAutoPilotOrderType=" + currentAutoPilotOrderStatus.ToString());
                        RealLogger.PrintOutput("Activating auto pilot profile feature: breakEvenAutoTrailNow=" + breakEvenAutoTrailNowFlag.ToString().ToLower());
                        RealLogger.PrintOutput("Activating auto pilot profile feature: closeAutoMinProfit=" + closeAutoMinProfitFlag.ToString().ToLower());
                        RealLogger.PrintOutput("Activating auto pilot profile feature: limitTrancheVolumeToInProfit=" + limitTrancheVolumeToInProfitFlag.ToString().ToLower() + " (" + MaxInitialTrancheVolumeSize.ToString("N0") + ")");
                        RealLogger.PrintOutput("Activating auto pilot profile feature: limitTrancheVolumePerBar=" + limitTrancheVolumePerBarFlag.ToString().ToLower() + " (" + MinTrancheVolumeDelaySeconds.ToString("N0") + " sec)");
                        RealLogger.PrintOutput("Activating auto pilot profile feature: popLimitToPullback=" + popLimitToPullbackFlag.ToString().ToLower());
                        RealLogger.PrintOutput("Activating auto pilot profile feature: popCTRLDelayedEntryFlag=" + popCTRLDelayedEntryFlag.ToString().ToLower());

                        if (nextAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Peppy)
                        {
                            RealLogger.PrintOutput("Activating auto pilot profile feature: peppyLimitPopAlignedCreeper=" + UsePeppyLimitPopAlignedCreeper.ToString().ToLower());
                            RealLogger.PrintOutput("Activating auto pilot profile feature: peppyLimitPopAlignedRushLine=" + UsePeppyLimitPopAlignedRushLine.ToString().ToLower());
                        }
                        else if (nextAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Sleepy)
                        {
                            RealLogger.PrintOutput("Activating auto pilot profile feature: sleepyLimitPopCounterCreeper=" + UseSleepyLimitPopCounterCreeper.ToString().ToLower());
                            RealLogger.PrintOutput("Activating auto pilot profile feature: sleepyLimitPopCounterRushLine=" + UseSleepyLimitPopCounterRushLine.ToString().ToLower());
                        }


                        currentAutoPilotProfileStatus = nextAutoPilotProfileStatus;
                        lastAutoPilotProfileChangeTime = DateTime.MinValue;
                        nextAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Disabled;
                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleAutoPilotProfileButton.Background = buttonBGColor;
                        }));

                        RealLogger.PrintOutput("Activated auto pilot profile type " + currentAutoPilotProfileStatus + " (" + currentAutoPilotSetupStatus + " / AutoAdjust=" + autoPilotProfileAutoAdjustFlag.ToString().ToLower() + ")");
                    }
                }
            }
        }

        private void HandleAutoAddOnStatusChange()
        {
            if (lastAutoAddOnChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastAutoAddOnChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleAutoAddOnButton != null)
                    {
                        if (currentAutoAddOnStatus != nextAutoAddOnStatus)
                            RealLogger.PrintOutput("Activated auto addon type " + nextAutoAddOnStatus + " ( AutoAddOnMaxDollars=$" + autoAddOnMaxDollars.ToString("N2") + " / Margin=$" + attachedInstrumentIntradayMarginDollars + " / MaxVol=" + attachedInstrumentPositionMaxVolume + ")");

                        currentAutoAddOnStatus = nextAutoAddOnStatus;
                        lastAutoAddOnChangeTime = DateTime.MinValue;
                        nextAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled;
                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentAutoAddOnStatus == TickHunterAutoAddOnTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleAutoAddOnButton.Background = buttonBGColor;
                        }));
                    }
                }
            }
        }

        private void HandleAutoBreakEvenStatusChange()
        {
            if (lastBreakEvenAutoChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastBreakEvenAutoChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleAutoBEButton != null)
                    {
                        if (nextBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMonster
                            || nextBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftMonster)
                            AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                        currentBreakEvenAutoStatus = nextBreakEvenAutoStatus;
                        lastBreakEvenAutoChangeTime = DateTime.MinValue;
                        nextBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;

                        if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.HODL)
                        {
                            ActivateHODL(false);
                        }
                        else if (currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.HODL && breakEvenAutoHODLFlag)
                        {
                            DeactivateHODL(false);
                        }

                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleAutoBEButton.Background = buttonBGColor;
                        }));

                        int period = 0;

                        if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
                            period = AutoPilotSpeedLineFilterPeriod;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
                            period = AutoCloseAndTrailMA1Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
                            period = AutoCloseAndTrailMA2Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
                            period = AutoCloseAndTrailMA3Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
                            period = AutoCloseAndTrailMA4Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                            period = AutoCloseAndTrailRLPeriod;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
                            period = AutoCloseAndTrailDL1Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
                            period = AutoCloseAndTrailDL2Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                            period = AutoCloseAndTrailDL3Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                            period = AutoCloseAndTrailDL4Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
                            period = AutoCloseAndTrailR1Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
                            period = AutoCloseAndTrailR5Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek1)
                            period = AutoCloseAndTrailDL3Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek5)
                            period = AutoCloseAndTrailDL4Period;
                        else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                            period = AutoCloseAndTrailDL4Period;

                        if (period != 0)
                        {
                            RealLogger.PrintOutput("Activated break-even auto type " + currentBreakEvenAutoStatus + " (period=" + period + " / TrailNow=" + breakEvenAutoTrailNowFlag.ToString().ToLower() + ")");
                        }
                        else
                        {
                            RealLogger.PrintOutput("Activated break-even auto type " + currentBreakEvenAutoStatus + " (TrailNow=" + breakEvenAutoTrailNowFlag.ToString().ToLower() + ")");
                        }
                    }
                }
            }
        }

        private void ActivateHODL(bool enableLogging = true)
        {
            string signalName = "OnAutoBreakStatusChange";

            if (enableLogging) RealLogger.PrintOutput("HODL activated");
            breakEvenAutoHODLFlag = true;

            CancelPositionAllTakeProfitOrders(signalName);
        }

        private void DeactivateHODL(bool enableLogging = true)
        {
            if (enableLogging) RealLogger.PrintOutput("HODL deactivated");
            breakEvenAutoHODLFlag = false;
        }

        private void CancelPositionAllTakeProfitOrders(string signalName)
        {
            CancelPositionTPOrders(signalName, attachedInstrument);
            if (IsBlendedInstrumentEnabled())
            {
                CancelPositionTPOrders(signalName, blendedInstrument);
            }
        }

        /*
        private void OnAutoBreakStatusChange()
        {
            if (IsHODLEnabled())
            {
                CancelPositionTPOrders("OnAutoBreakStatusChange", attachedInstrument);
                if (IsBlendedInstrumentEnabled())
                {
                    CancelPositionTPOrders("OnAutoBreakStatusChange", blendedInstrument);
                }
            }
        }
        */

        private void HandleAutoCloseStatusChange()
        {
            if (lastCloseAutoChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastCloseAutoChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleAutoCloseButton != null)
                    {
                        currentCloseAutoStatus = nextCloseAutoStatus;
                        lastCloseAutoChangeTime = DateTime.MinValue;
                        nextCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;

                        ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                        {
                            Brush buttonBGColor = (currentCloseAutoStatus == TickHunterCloseAutoTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                            toggleAutoCloseButton.Background = buttonBGColor;
                            closeAllButton.Content = (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonText : ToggleCloseButtonText;
                            closeAllButton.ToolTip = (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonToolTip : ToggleCloseButtonToolTip;
                        }));

                        RealLogger.PrintOutput("Activated close auto type " + currentCloseAutoStatus + " (MinProfit=" + closeAutoMinProfitFlag.ToString().ToLower() + " / " + " Alert=" + closeAutoAlertFlag.ToString().ToLower() + ")");
                    }
                }
            }
        }

        private void HandleProfitTargetStatusChange()
        {
            string signalName = "HandleProfitTargetStatusChange";

            if (lastProfitTargetChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastProfitTargetChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleProfitTargetButton != null)
                    {
                        if (lastToggleProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget)
                        {
                            currentProfitTargetStatus = nextProfitTargetStatus;
                            lastProfitTargetChangeTime = DateTime.MinValue;
                            nextProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;
                            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                            {
                                Brush buttonBGColor = (currentProfitTargetStatus == TickHunterProfitTargetTypes.Disabled) ? Brushes.DimGray : Brushes.HotPink;
                                toggleProfitTargetButton.Background = buttonBGColor;
                                closeAllButton.Content = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? ToggleFlatButtonText : (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonText : ToggleCloseButtonText;
                                closeAllButton.ToolTip = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? ToggleFlatButtonToolTip : (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonToolTip : ToggleCloseButtonToolTip;
                            }));

                            RealLogger.PrintOutput("Activated profit type " + currentProfitTargetStatus);
                        }
                        else
                        {
                            bool hasProfitTargetChanged = (currentProfitTargetStatus != nextProfitTargetStatus);

                            currentProfitTargetStatus = nextProfitTargetStatus;
                            nextProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;

                            currentBogeyTargetMultiplier = nextBogeyTargetMultiplier;
                            lastProfitTargetChangeTime = DateTime.MinValue;

                            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                            {
                                Brush buttonBGColor = (currentBogeyTargetMultiplier == BogeyTargetMultiplierDisabled) ? Brushes.DimGray : Brushes.HotPink;
                                toggleProfitTargetButton.Background = buttonBGColor;
                                closeAllButton.Content = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? ToggleFlatButtonText : (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonText : ToggleCloseButtonText;
                                closeAllButton.ToolTip = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? ToggleFlatButtonToolTip : (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonToolTip : ToggleCloseButtonToolTip;
                            }));

                            if (hasProfitTargetChanged)
                            {
                                if (currentProfitTargetStatus == TickHunterProfitTargetTypes.Disabled
                                    && UseAutoPositionTakeProfit
                                    && (TakeProfitSyncBogeyTargetPrice || TakeProfitSyncECATargetPrice))
                                {
                                    CancelPositionAllTakeProfitOrders(signalName);
                                }
                            }

                            string startWithText = "StartWithFullPnL=false";

                            if (bogeyTargetStartWithFullPnLFlag)
                            {
                                startWithText = "StartWithFullPnL=true";
                            }

                            RealLogger.PrintOutput("Activated profit type " + currentProfitTargetStatus);
                            RealLogger.PrintOutput("Activated bogey target multiplier x " + currentBogeyTargetMultiplier + " (" + startWithText + ")");

                            if (IsBogeyTargetEnabled())
                            {
                                double bogeyTargetMultiplier = currentBogeyTargetMultiplier; // CalculateBogeyTargetMutiplier(currentBogeyTargetStatus);
                                double dpMultipliedAmount = (BogeyTargetBaseDollars * bogeyTargetMultiplier);

                                RealLogger.PrintOutput("Bogey Target Base: $" + BogeyTargetBaseDollars.ToString("N0") + " x " + bogeyTargetMultiplier.ToString("N0") + " ($" + dpMultipliedAmount.ToString("N0") + ")");
                            }
                        }
                    }
                }
            }
        }

        private void HandleEntryVolumeAutoStatusChange()
        {
            if (lastEntryVolumeAutoChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastEntryVolumeAutoChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleEntryVolumeAutoButton != null)
                    {
                        currentEntryVolumeAutoStatus = nextEntryVolumeAutoStatus;
                        lastEntryVolumeAutoChangeTime = DateTime.MinValue;
                        nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;

                        RealLogger.PrintOutput("Activated auto entry volume type " + currentEntryVolumeAutoStatus + " (" + CalculateAutoEntryVolume(currentEntryVolumeAutoStatus) + ")");
                    }
                }
            }
        }

        private void HandleEntryVolumeMaxStatusChange()
        {
            if (lastEntryVolumeMaxChangeTime != DateTime.MinValue && ChartControl != null)
            {
                bool fullyEnabled = lastEntryVolumeMaxChangeTime <= GetDateTimeNow();

                if (fullyEnabled)
                {
                    if (toggleEntryVolumeMaxButton != null)
                    {
                        currentEntryVolumeMaxStatus = nextEntryVolumeMaxStatus;
                        lastEntryVolumeMaxChangeTime = DateTime.MinValue;
                        nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;

                        RealLogger.PrintOutput("Activated entry volume max type " + currentEntryVolumeMaxStatus + " (" + CalculateEntryVolumeMax(currentEntryVolumeMaxStatus) + ")");
                    }
                }
            }
        }


        private bool IsBlendedInstrumentEnabled()
        {
            bool returnFLag = false;

            if (UseBlendedInstruments && blendedInstrument != null)
            {
                returnFLag = true;
            }

            return returnFLag;
        }

        private Instrument GetBlendedInstrument(Instrument instrument)
        {
            Instrument foundBlendedInstrument = null;

            if (instrument != null)
            {
                if (instrument == mymInstrument)
                {
                    foundBlendedInstrument = ymInstrument;
                }
                else if (instrument == mesInstrument)
                {
                    foundBlendedInstrument = esInstrument;
                }
                else if (instrument == m2kInstrument)
                {
                    foundBlendedInstrument = rtyInstrument;
                }
                else if (instrument == mnqInstrument)
                {
                    foundBlendedInstrument = nqInstrument;
                }
                else if (instrument == ymInstrument)
                {
                    foundBlendedInstrument = mymInstrument;
                }
                else if (instrument == esInstrument)
                {
                    foundBlendedInstrument = mesInstrument;
                }
                else if (instrument == rtyInstrument)
                {
                    foundBlendedInstrument = m2kInstrument;
                }
                else if (instrument == nqInstrument)
                {
                    foundBlendedInstrument = mnqInstrument;
                }
            }

            return foundBlendedInstrument;
        }

        /*
        private string GenerateAutoPilotStatusText(TickHunterAutoPilotTypes autoPilotType)
        {
            string autoPilotStatusText = ToggleAutoPilotButtonDisabledText;

            if (autoPilotType == TickHunterAutoPilotTypes.TradeCount1)
            {
                autoPilotStatusText = ToggleAutoPilotCount1ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount2)
            {
                autoPilotStatusText = ToggleAutoPilotCount2ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount3)
            {
                autoPilotStatusText = ToggleAutoPilotCount3ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount4)
            {
                autoPilotStatusText = ToggleAutoPilotCount4ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount5)
            {
                autoPilotStatusText = ToggleAutoPilotCount5ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount6)
            {
                autoPilotStatusText = ToggleAutoPilotCount6ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount7)
            {
                autoPilotStatusText = ToggleAutoPilotCount7ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount8)
            {
                autoPilotStatusText = ToggleAutoPilotCount8ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount9)
            {
                autoPilotStatusText = ToggleAutoPilotCount9ButtonEnabledText;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount10)
            {
                autoPilotStatusText = ToggleAutoPilotCount10ButtonEnabledText;
            }

            return autoPilotStatusText;
        }

        private string GenerateAutoPilotStatusToolTip(TickHunterAutoPilotTypes autoPilotType)
        {
            string autoPilotStatusToolTip = ToggleAutoPilotButtonDisabledToolTip;

            if (autoPilotType == TickHunterAutoPilotTypes.TradeCount1)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount1ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount2)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount2ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount3)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount3ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount4)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount4ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount5)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount5ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount6)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount6ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount7)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount7ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount8)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount8ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount9)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount9ButtonEnabledToolTip;
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount10)
            {
                autoPilotStatusToolTip = ToggleAutoPilotCount10ButtonEnabledToolTip;
            }

            return autoPilotStatusToolTip;
        }
        */

        private string GetInstrumentPeriodText()
        {
            string instrumentName = this.attachedInstrument.FullName;
            string periodText = this.BarsPeriod.Value + " " + this.BarsPeriod.BarsPeriodType.ToString();

            string instrumentPeriodText = instrumentName + " (" + periodText + ")";

            return instrumentPeriodText;
        }

        private void RefreshAccount()
        {
            if (hasRanOnceFirstCycle)
            {
                Account tempAccount = GetAccount();
                if (account != null & tempAccount != account)
                {
                    hasRanOnceFirstCycle = false;
                }
            }
        }

        private void RefreshATMStrategyName()
        {
            if (hasRanOnceFirstCycle)
            {
                string tempATMStrategyName = GetATMStrategy();
                if (tempATMStrategyName != atmStrategyName)
                {
                    hasRanOnceFirstCycle = false;
                }
            }
        }

        private void MarketData_Update(object sender, MarketDataEventArgs e)
        {
            bool newBidAsk = false;

            if (e.Instrument != null)
            {
                Interlocked.Exchange(ref marketDataBidAskPulseStatus, 1);

                double lastPrice = 0;
                double newPrice = 0;
                if (e.MarketDataType == MarketDataType.Ask)
                {
                    lastPrice = RealInstrumentService.GetAskPrice(e.Instrument);
                    newPrice = e.Ask;

                    if (lastPrice != newPrice)
                    {
                        newBidAsk = true;
                        RealInstrumentService.SetAskPrice(e.Instrument, newPrice);
                    }
                }
                else if (e.MarketDataType == MarketDataType.Bid)
                {
                    lastPrice = RealInstrumentService.GetBidPrice(e.Instrument);
                    newPrice = e.Bid;

                    if (lastPrice != newPrice)
                    {
                        newBidAsk = true;
                        RealInstrumentService.SetBidPrice(e.Instrument, newPrice);
                    }
                }
                else if (e.MarketDataType == MarketDataType.Last)
                {
                    lastPrice = RealInstrumentService.GetLastPrice(e.Instrument);
                    newPrice = e.Last;

                    if (lastPrice != newPrice)
                    {
                        //newBidAsk = true;
                        RealInstrumentService.SetLastPrice(e.Instrument, newPrice);
                    }
                }

                /*
                if (newBidAsk)
                {
                    Interlocked.Exchange(ref marketDataBidAskChangeStatus, 1);
                }
                */
            }

            if (newBidAsk)
            {
                var lockTimeout = TimeSpan.FromMilliseconds(250);
                bool lockTaken = false;

                try
                {
                    Monitor.TryEnter(RealTimePipelineLock, lockTimeout, ref lockTaken);

                    if (lockTaken)
                    {
                        if (RealTimePipeLineThrottleMilliseconds <= 0)
                        {
                            lock (ThreadManagerLock)
                            {
                                TriggerCustomEvent(o =>
                                {
                                    RealTimePipeline();
                                }, null);
                            }
                        }
                        else
                        {
                            bool isNextRealTimeCycleReady = lastRealTimePipeLineCycleChangeTime <= GetDateTimeNow();

                            if (isNextRealTimeCycleReady)
                            {
                                lastRealTimePipeLineCycleChangeTime = (GetDateTimeNow()).AddMilliseconds(RealTimePipeLineThrottleMilliseconds);
                                lock (ThreadManagerLock)
                                {
                                    TriggerCustomEvent(o =>
                                    {
                                        RealTimePipeline();
                                    }, null);
                                }
                            }
                        }

                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception calling RealTimePipeline:" + ex.Message + " " + ex.StackTrace);
                    throw;
                }
                finally
                {
                    if (lockTaken)
                        Monitor.Exit(RealTimePipelineLock);
                }
            }
        }

        private bool hasMultiCycleOrderElementsOutput = false;
        private bool hasActiveOrdersOutput = false;
        private bool hasOrderUpdateCycleOutput = false;
        private void RealTimePipeline()
        {
            const string signalName = "RealTimePipeline";
            //if (DebugLogLevel > 0) RealLogger.PrintOutput("***Starting RealTimePipeline...",PrintTo.OutputTab1, true);

            DetermineIfWindowHidden();

            if (HasRanOnceFirstCycle() && account != null && !isIndicatorSuspended)
            {
                IsNinjaTraderOrdersAlreadyLoaded = false;

                if (RealOrderService.AreAllOrderUpdateCyclesComplete())
                {
                    if (hasMultiCycleOrderElementsOutput)
                    {
                        RealLogger.PrintOutput("Multi-cycle order update(s) cleared...", PrintTo.OutputTab1, true);
                        hasMultiCycleOrderElementsOutput = false;
                    }

                    if (hasActiveOrdersOutput)
                    {
                        RealLogger.PrintOutput("Active order(s) cleared...", PrintTo.OutputTab1, true);
                        hasActiveOrdersOutput = false;
                    }

                    if (hasOrderUpdateCycleOutput)
                    {
                        RealLogger.PrintOutput("Order update cycle cleared...", PrintTo.OutputTab1, true);
                        hasOrderUpdateCycleOutput = false;
                    }

                    if (IsTickHunterActivated()) AttemptToClosePositionsInProfit();
                    if (IsTickHunterActivated()) AttemptToClosePositionsInLoss();

                    if (accountHadPositions && IsAccountFlat()
                        && RealOrderService.AreAllOrderUpdateCyclesComplete()
                        && RealOrderService.OrderCount == 0)
                    {
                        accountHadPositions = false;
                        RealLogger.PrintOutput("Account is flat... ", PrintTo.OutputTab1, true);
                    }

                    if (IsTickHunterActivated()) AttemptToEngageAutoPilot();
                    if (IsTickHunterActivated()) AttemptToEngagePopDelayedEntry();
                    if (IsTickHunterActivated()) AttemptToEngageAutoAddOn();

                    //AttemptToEngageAutobot();

                    if (!IsAccountFlat())
                    {
                        if (!accountHadPositions) RealLogger.PrintOutput("Account has active orders...", PrintTo.OutputTab1, true);
                        accountHadPositions = true;
                    }
                }
                else
                {
                    bool readyOutputWithThrottle = (lastOrderOutputTime == DateTime.MinValue || lastOrderOutputTime >= (GetDateTimeNow()).AddSeconds(OrderWaitOutputThrottleSeconds));
                    if (readyOutputWithThrottle)
                    {
                        if (RealOrderService.OrderUpdateMultiCycleCache.HasElements())
                        {
                            RealLogger.PrintOutput("Waiting on " + RealOrderService.OrderUpdateMultiCycleCache.Count.ToString() + " multi-cycle order update(s) to clear...", PrintTo.OutputTab1, true);
                            hasMultiCycleOrderElementsOutput = true;
                        }
                        else if (RealOrderService.HasActiveMarketOrders())
                        {
                            RealLogger.PrintOutput("Waiting on active orders to clear...", PrintTo.OutputTab1, true);
                            hasActiveOrdersOutput = true;
                        }
                        else
                        {
                            RealLogger.PrintOutput("Waiting on order update cycle to clear...", PrintTo.OutputTab1, true);
                            hasOrderUpdateCycleOutput = true;
                        }

                        lastOrderOutputTime = GetDateTimeNow();
                    }
                }

                if (IsTickHunterActivated() && RealOrderService.AreAllOrderUpdateCyclesComplete())
                {
                    HandlePositionInfoRefresh(signalName);
                    RefreshDayOverLines();
                    HandleTPSLRefresh(signalName);
                    RefreshRiskInfoLabel();
                    RefreshProfitInfoLabel();
                    if ((dayOverMaxLossInfoLabel != null && dayOverMaxLossInfoLabel.Content != "")
                        || (bogeyTargetInfoLabel != null && bogeyTargetInfoLabel.Content != "")
                        || (riskInfoLabel != null && riskInfoLabel.Content != "")
                        || (profitInfoLabel != null && profitInfoLabel.Content != ""))
                    {
                        if (labelGrid != null)
                        {
                            labelGrid.Background = Brushes.Black;
                        }
                    }
                    else
                    {
                        if (labelGrid != null)
                        {
                            labelGrid.Background = Brushes.Transparent;
                        }
                    }

                    bool isNextPopDropCycleReady = lastPopDropCycleChangeTime <= GetDateTimeNow();

                    if (isNextPopDropCycleReady)
                    {
                        if (PopDropThrottleMilliseconds > 0) lastPopDropCycleChangeTime = (GetDateTimeNow()).AddMilliseconds(PopDropThrottleMilliseconds);

                        bool passedOnBarUpdateDelayCheck = false;

                        if (UsePopDropOnBarUpdateDelay)
                        {
                            if (isPopDropOnBarUpdateCycleReady)
                            {
                                passedOnBarUpdateDelayCheck = true;
                            }
                        }
                        else
                        {
                            passedOnBarUpdateDelayCheck = true;
                        }

                        if (passedOnBarUpdateDelayCheck)
                        {
                            isPopDropOnBarUpdateCycleReady = false;

                            HandlePopAutoJumpToSnap(signalName);
                            HandleDropAutoJumpToSnap(signalName);
                        }
                    }

                    AttemptAccountInfoLogging();
                }
            }
        }


        private void OnTimerTick(object sender, EventArgs e)
        {
            var lockTimeout = TimeSpan.FromMilliseconds(250);
            bool lockTaken = false;

            try
            {
                Monitor.TryEnter(DelayedPipelineLock, lockTimeout, ref lockTaken);

                if (lockTaken)
                {
                    lock (ThreadManagerLock)
                    {
                        TriggerCustomEvent(o =>
                        {
                            DelayedPipeline();
                        }, null);
                    }
                }
            }
            catch (Exception ex)
            {
                //log and stuff exception
                RealLogger.PrintOutput("Exception calling DelayedPipeline:" + ex.Message + " " + ex.StackTrace);
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(DelayedPipelineLock);
            }
        }

        private void DelayedPipeline()
        {
            const string signalName = "DelayedPipeline";

            if (!hasDrawnButtons)
            {
                if (IsStrategyAttachedToChart() && HasRanOnceFirstCycle())
                {
                    if (!hasDrawnButtons)
                    {
                        ForceRefresh();
                    }
                }
            }
        }

        private void ResetPositionTPSLOrderDelayOrderDelay()
        {
            lock (PositionTPSLOrderDelayLock)
            {
                lastPositionQuantityChange = DateTime.MinValue;
            }
        }

        private void SetPositionTPSLOrderDelayOrderDelay()
        {
            lock (PositionTPSLOrderDelayLock)
            {
                if (RefreshTPSLOrderDelaySeconds > 0)
                    lastPositionQuantityChange = (GetDateTimeNow()).AddSeconds(RefreshTPSLOrderDelaySeconds);
                else
                    lastPositionQuantityChange = GetDateTimeNow();

            }
        }

        private DateTime GetDateTimeNow()
        {
            DateTime now = DateTime.MinValue;

            bool isUsingPlaybackConnection = (NinjaTrader.Cbi.Connection.PlaybackConnection != null);

            if (isUsingPlaybackConnection)
            {
                now = NinjaTrader.Cbi.Connection.PlaybackConnection.Now;
            }
            else
            {
                now = DateTime.Now;
            }

            return now;
        }

        private bool HasPositionTPSLOrderDelay()
        {
            bool returnFlag = false;

            if (RefreshTPSLOrderDelaySeconds > 0)
            {
                lock (PositionTPSLOrderDelayLock)
                {
                    bool delayTPSLOrders = (lastPositionQuantityChange >= GetDateTimeNow());

                    if (delayTPSLOrders)
                        returnFlag = true;
                }
            }

            return returnFlag;
        }

        private void OrderUpdate(Account orderAccount, Instrument orderInstrument, long orderId, string exchangeOrderId, string orderName,
            OrderState orderState, OrderAction orderAction, OrderType orderType, int orderQuantity, int orderQuantityChanged, int orderFilled,
            double orderAverageFillPrice, double orderLimitPrice, double orderLimitPriceChanged, double orderStopPrice, double orderStopPriceChanged,
            bool isMarket, bool isStopMarket, bool isLimit)
        {
            try
            {
                //Print("OrderUpdate- exchangeOrderId=" + exchangeOrderId + " orderId=" + orderId + " orderId=" + orderId + " orderState=" + orderState + " orderAction=" + orderAction + " OrderType=" + orderType);

                RealOrderService.InOrderUpdateCycleIncrement();

                bool hasPositionQuantityChanged = false;
                int remainingPositionQuantity = 0;

                RealOrder updatedOrder = RealOrderService.BuildRealOrder(orderAccount, orderInstrument, orderId, exchangeOrderId, orderName, orderType, orderAction,
                    orderQuantity, orderQuantityChanged,
                    orderLimitPrice, orderLimitPriceChanged, orderStopPrice, orderStopPriceChanged, orderState, orderFilled);

                RealOrderService.AddOrUpdateOrder(updatedOrder);

                string instrumentName = attachedInstrument.FullName;
                bool isAttachedInstrument = orderInstrument == attachedInstrument;
                bool isBlendedInstrument = IsBlendedInstrumentEnabled() && orderInstrument == blendedInstrument;
                string orderUniqueId = RealOrderService.BuildOrderUniqueId(orderId);

                if (DebugLogLevel > 15 && isAttachedInstrument && !RealOrderService.OrderUpdateMultiCycleCache.HasElements()) RealLogger.PrintOutput("***** OrderUpdate-" + instrumentName + ": START *****");
                //RealLogger.PrintOutput("DEBUG: orderId=" + exchangeOrderId + " rderId=" + exchangeOrderId + " orderId=" + orderId + " uniqueId=" + orderUniqueId);

                bool isOrderInitialized = (orderState == OrderState.Initialized);
                bool isOrderCancelPending = (orderState == OrderState.CancelPending || orderState == OrderState.CancelSubmitted);
                bool isChangePending = (orderState == OrderState.ChangePending || orderState == OrderState.ChangeSubmitted);

                bool isStopOrderWorking = (isStopMarket && orderState == OrderState.Working);

                if (isOrderInitialized || isOrderCancelPending || isChangePending)
                {
                    bool addedToMultiCycleCache = RealOrderService.OrderUpdateMultiCycleCache.RegisterUniqueId(orderUniqueId);
                    if (DebugLogLevel > 5 && isAttachedInstrument && addedToMultiCycleCache) RealLogger.PrintOutput("OrderUpdate-" + instrumentName + ": Adding to cache OrderState=" + orderState.ToString() + " name=" + orderName + " exchangeOrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " orderaction=" + orderAction.ToString() + " orderType=" + orderType.ToString() + " orderQuan=" + orderQuantity.ToString());
                }

                bool isCancelPendingOrdersActivated = ((isStopMarket || isLimit) && orderState == OrderState.CancelSubmitted);
                bool isFilledPendingOrdersActivated = (!isMarket && (orderState == OrderState.Filled || orderState == OrderState.PartFilled));
                bool isRejected = orderState == OrderState.Rejected;
                //bool isFlat = (isMarket && orderState == OrderState.Filled && orderQuantity == orderFilled);

                if (isRejected)
                {
                    if (isAttachedInstrument || isBlendedInstrument)
                    {
                        RealLogger.PrintOutput("OrderUpdate-" + instrumentName + ": rejected OrderState=" + orderState.ToString() + " name=" + orderName + " exchangeOrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " price=" + Math.Max(orderStopPrice, orderLimitPrice).ToString() + " orderaction=" + orderAction.ToString() + " lastPrice=" + RealInstrumentService.GetLastPrice(orderInstrument).ToString() + " bidPrice=" + RealInstrumentService.GetBidPrice(orderInstrument).ToString() + " askPrice=" + RealInstrumentService.GetAskPrice(orderInstrument).ToString() + " instrument=" + orderInstrument.FullName);

                        bool isStopLossOrder = (orderName == RealOrderService.BuildStopOrderName());
                        bool isTakeProfitOrder = (orderName == RealOrderService.BuildTargetOrderName());

                        if (isStopLossOrder || isTakeProfitOrder)
                        {
                            RealPosition foundPosition = null;
                            if (RealPositionService.TryGetByInstrumentFullName(orderInstrument.FullName, out foundPosition))
                            {
                                if (foundPosition.IsValid)
                                {
                                    foundPosition.IsValid = false;
                                    string messageTitle = SystemName + " - Critical Error";
                                    string errorMessage = SystemName + " can no longer protect your position with a stoploss or take profit order due to a rejection from the exchange.Refresh indicators using F5 or close position to reset protection.";

                                    Dispatcher.InvokeAsync(() =>
                                    {
                                        NinjaTrader.Gui.Tools.NTMessageBoxSimple.Show(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), errorMessage, messageTitle, MessageBoxButton.OK, MessageBoxImage.Stop);
                                    });
                                }

                                RealLogger.PrintOutput("***CRITICAL ERROR: OrderUpdate-" + instrumentName + ": rejected OrderState=" + orderState.ToString() + " - TickHunter no longer protecting with SL/TP due to exchange rejection.  Refresh indicators using F5 or close position to reset protection.");
                            }
                        }
                    }
                }

                if (isCancelPendingOrdersActivated || isFilledPendingOrdersActivated || isStopOrderWorking)
                {
                    //RealLogger.PrintOutput("OrderUpdate delay state = " + orderState.ToString() + " name=" + orderName + " quantity=" + orderQuantity + " filled=" + orderFilled + " orderaction=" + orderAction.ToString() + " position=" + Convert.ToString(positionQuantity));
                    //if (DebugLogLevel > 2 && isAttachedInstrument) RealLogger.PrintOutput("OrderUpdate-" + instrumentName + ": delay OrderState=" + orderState.ToString() + " name=" + orderName + " OrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " quantity=" + orderQuantity + " filled=" + orderFilled + " orderaction=" + orderAction.ToString() + " positionCount=" + Convert.ToString(RealPositionService.PositionCount) + " instrument=" + orderInstrument.FullName);
                    //SetPendingOrderDelay();
                }

                bool hasFilledOrder = orderFilled > 0 && (orderState == OrderState.PartFilled || orderState == OrderState.Filled);

                /*
                if (hasFilledOrder)
                {
                    int filledQuantity = RealOrderService.GetFilledOrderQuantity(orderId, orderState, orderFilled);

                    if (DebugLogLevel > 15) RealLogger.PrintOutput("***** OrderUpdate-" + instrumentName + ": order filled OrderState=" + orderState.ToString() + " name=" + orderName + " exchangeOrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " quantity=" + orderQuantity + " filled=" + orderFilled + " orderaction=" + orderAction.ToString() + " positionCount=" + Convert.ToString(RealPositionService.PositionCount));


                    MarketPosition marketPosition = ConvertOrderActionToMarketPosition(orderAction);

                    RealPosition newPosition = RealPositionService.BuildRealPosition(orderAccount, orderInstrument, marketPosition, filledQuantity, orderAverageFillPrice, GetDateTimeNow());


                    if (DebugLogLevel > 15) RealLogger.PrintOutput("OrderUpdate before AddUpdate positioncount=" + RealPositionService.PositionCount + " filledQuantity=" + filledQuantity + " orderFilled=" + orderFilled + " OrderState = " + orderState.ToString());

                    remainingPositionQuantity = RealPositionService.AddOrUpdatePosition(newPosition);

                    if (DebugLogLevel > 15) RealLogger.PrintOutput("OrderUpdate after AddUpdate remainingPositionQuantity=" + remainingPositionQuantity);

                    if (DebugLogLevel > 2)
                    {
                        if (DebugLogLevel > 2 && isAttachedInstrument) RealLogger.PrintOutput("OrderUpdate-" + instrumentName + ": order filled OrderState=" + orderState.ToString() + " name=" + orderName + " exchangeOrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " quantity=" + orderQuantity + " filled=" + orderFilled + " orderaction=" + orderAction.ToString() + " positionCount=" + Convert.ToString(RealPositionService.PositionCount) + " filledquan=" + filledQuantity.ToString() + " poQuan=" + remainingPositionQuantity.ToString() + " instrument=" + orderInstrument.FullName);
                        //RealLogger.PrintOutput("OrderUpdate after" + " poQuan=" + updatedPositionQuantity.ToString() + " filledquan=" + filledQuantity.ToString()); //debug
                    }

                    //if (RealPositionService.PositionCount == 0)
                    //{
                    //ResetPositionTPSLOrderDelayOrderDelay();
                    //}
                    //else
                    //{
                    //SetPositionTPSLOrderDelayOrderDelay();
                    //}

                    if (remainingPositionQuantity > 0) hasPositionQuantityChanged = true;
                }
                */


                bool isCompletedMarketOrder = (isMarket && Order.IsTerminalState(orderState));
                bool isCompletedStopOrder = (isStopMarket && (orderState == OrderState.Accepted || orderState == OrderState.Working));
                bool isCompletedLimitOrder = (isLimit && (orderState == OrderState.Accepted || orderState == OrderState.Working));
                bool isCompletedCancelledOrder = (orderState == OrderState.Cancelled);
                bool isFilledStopOrder = (isStopMarket && orderState == OrderState.Filled || orderState == OrderState.PartFilled);
                bool isFilledLimit = (isLimit && orderState == OrderState.Filled || orderState == OrderState.PartFilled);

                bool hadStopLossFilled = isFilledStopOrder && orderName.StartsWith(RealOrderService.BuildStopOrderName());
                bool hadTakeProfitFilled = isFilledLimit && orderName.StartsWith(RealOrderService.BuildTargetOrderName());


                bool foundOrderUniqueId = false;

                foundOrderUniqueId = RealOrderService.OrderUpdateMultiCycleCache.ContainsKey(orderUniqueId);

                //RealLogger.PrintOutput("OrderUpdate order state = " + orderState.ToString() + " name=" + orderName);
                if (foundOrderUniqueId &&
                    (isCompletedMarketOrder || isCompletedStopOrder || isCompletedLimitOrder || isRejected || isCompletedCancelledOrder || isFilledStopOrder || isFilledLimit))
                {
                    if (DebugLogLevel > 5 && isAttachedInstrument) RealLogger.PrintOutput("OrderUpdate-" + instrumentName + ": Removing from cache OrderState=" + orderState.ToString() + " name=" + orderName + " exchangeOrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " orderaction=" + orderAction.ToString() + " orderType=" + orderType.ToString());

                    RealOrderService.OrderUpdateMultiCycleCache.DeregisterUniqueId(orderUniqueId);
                }
                else
                {
                    bool foundInCache = false;
                    if (foundOrderUniqueId)
                        foundInCache = RealOrderService.OrderUpdateMultiCycleCache.TouchUniqueId(orderUniqueId);


                    if (DebugLogLevel > 8 && isAttachedInstrument) RealLogger.PrintOutput("OrderUpdate-" + instrumentName + ": Not removed from cache OrderState=" + orderState.ToString() + " name=" + orderName + " exchangeOrderId=" + exchangeOrderId + " InternalId=" + orderUniqueId + " orderaction=" + orderAction.ToString() + " orderType=" + orderType.ToString() + " foundInCache=" + foundInCache);
                }

                /*
                if (1==2 && orderFilled > 0)
                {
                    try
                    {
                        StrategyBase atmStrategy = e.Order.GetOwnerStrategy();

                        //if ()

                        //if (atmStrategy == null)
                        {
                            //HandleTPSLRefresh("OrderUpdate");
                        }
                    }
                    catch (Exception ex)
                    {
                        RealLogger.PrintOutput("Exception calling OrderUpdate:" + ex.Message + " " + ex.StackTrace);
                        ///stuff exception
                    }
                }
                */
                //RealLogger.PrintOutput("******** OrderUpdate: OrderServiceCount=" + RealOrderService.OrderCount + " PositionCount=" + RealPositionService.PositionCount);
                if (Order.IsTerminalState(orderState))  //RealPositionService.PositionCount == 0) //Order.IsTerminalState(orderState)) //
                {
                    //RealLogger.PrintOutput("OrderUpdate: before remove OrderServiceCount=" + RealOrderService.OrderCount);
                    //RealOrderService.RemoveAllTerminalStateOrders();
                    RealOrderService.RemoveOrder(orderId);
                    //RealLogger.PrintOutput("OrderUpdate: after remove OrderServiceCount=" + RealOrderService.OrderCount);



                    int orderCount = RealOrderService.OrderCount;

                    for (int index = 0; index < orderCount; index++)
                    {
                        RealOrder order = null;

                        if (RealOrderService.TryGetByIndex(index, out order))
                        {
                            //RealLogger.PrintOutput("OrderUpdate: OrderId=" + order.OrderId + " OrderState=" + order.OrderState);
                        }
                    }

                }
                else
                {
                    //RealLogger.PrintOutput("OrderUpdate: not terminal OrderServiceCount=" + RealOrderService.OrderCount + " exchangeOrderId=" + exchangeOrderId + " OrderState=" + orderState);
                }

                if (hadStopLossFilled)
                {
                    validateAttachedPositionTakeProfitQuantityStage1 = true;
                    if (IsBlendedInstrumentEnabled()) validateBlendedPositionTakeProfitQuantityStage1 = true;

                }
                else if (hadTakeProfitFilled)
                {
                    validateAttachedPositionStopLossQuantityStage1 = true;
                    if (IsBlendedInstrumentEnabled()) validateBlendedPositionStopLossQuantityStage1 = true;
                }
                else if (hasFilledOrder)
                {
                    validateAttachedPositionStopLossQuantityStage1 = true;
                    validateAttachedPositionTakeProfitQuantityStage1 = true;

                    if (IsBlendedInstrumentEnabled())
                    {
                        validateBlendedPositionStopLossQuantityStage1 = true;
                        validateBlendedPositionTakeProfitQuantityStage1 = true;
                    }
                }

                /*
                if (hasPositionQuantityChanged)
                {
                    if (remainingPositionQuantity > 0)
                    {
                        if (hadTakeProfitFilled)
                        {
                            validateAttachedPositionStopLossQuantityStage1 = true;
                            if (IsBlendedInstrumentEnabled()) validateBlendedPositionStopLossQuantityStage1 = true;
                            //validateAttachedPositionStopLossQuantity = true;
                            //validateBlendedPositionStopLossQuantity = true;
                        }
                        else if (hadStopLossFilled)
                        {
                            validateAttachedPositionTakeProfitQuantityStage1 = true;
                            if (IsBlendedInstrumentEnabled()) validateBlendedPositionTakeProfitQuantityStage1 = true;

                            //validateAttachedPositionTakeProfitQuantity = true;
                            //validateBlendedPositionTakeProfitQuantity = true;
                        }
                        else
                        {
                            validateAttachedPositionStopLossQuantityStage1 = true;
                            validateAttachedPositionTakeProfitQuantityStage1 = true;

                            if (IsBlendedInstrumentEnabled())
                            {
                                validateBlendedPositionStopLossQuantityStage1 = true;
                                validateBlendedPositionTakeProfitQuantityStage1 = true;
                            }

                            //validateAttachedPositionStopLossQuantity = true;
                            //validateBlendedPositionStopLossQuantity = true;
                            //validateAttachedPositionTakeProfitQuantity = true;
                            //validateBlendedPositionTakeProfitQuantity = true;
                        }
                    }
                    else
                    {
                        validateAttachedPositionStopLossQuantityStage1 = true;
                        validateAttachedPositionTakeProfitQuantityStage1 = true;

                        if (IsBlendedInstrumentEnabled())
                        {
                            validateBlendedPositionStopLossQuantityStage1 = true;
                            validateBlendedPositionTakeProfitQuantityStage1 = true;
                        }

                        //validateAttachedPositionStopLossQuantity = false;
                        //validateAttachedPositionTakeProfitQuantity = false;
                        //validateBlendedPositionStopLossQuantity = false;
                        //validateBlendedPositionTakeProfitQuantity = false;
                    }
                }
                */

                if (DebugLogLevel > 15 && isAttachedInstrument && !RealOrderService.OrderUpdateMultiCycleCache.HasElements()) RealLogger.PrintOutput("***** OrderUpdate-" + instrumentName + ": END *****");
            }
            catch (Exception ex)
            {
                //log and stuff exception
                RealLogger.PrintOutput("Exception calling OrderUpdate:" + ex.Message + " " + ex.StackTrace);
            }
            finally
            {
                RealOrderService.InOrderUpdateCycleDecrement();
            }
        }


        private void OnOrderUpdate(object sender, OrderEventArgs e)
        {
            try
            {
                if (e != null && e.Order != null)
                {
                    Account orderAccount = e.Order.Account;
                    Instrument orderInstrument = e.Order.Instrument;
                    OrderState orderState = e.OrderState;
                    OrderAction orderAction = e.Order.OrderAction;
                    OrderType orderType = e.Order.OrderType;
                    int orderQuantity = e.Quantity;
                    int orderQuantityChanged = e.Order.QuantityChanged;
                    int orderFilled = e.Filled;
                    double orderAverageFillPrice = e.AverageFillPrice;
                    double orderLimitPrice = e.LimitPrice;
                    double orderStopPrice = e.StopPrice;
                    double orderStopPriceChanged = e.Order.StopPriceChanged;
                    double orderLimitPriceChanged = e.Order.LimitPriceChanged;
                    long orderId = e.Order.Id;
                    string exchangeOrderId = e.Order.OrderId;
                    string orderName = e.Order.Name;
                    bool isStopMarket = e.Order.IsStopMarket;
                    bool isMarket = e.Order.IsMarket;
                    bool isLimit = e.Order.IsLimit;

                    OrderUpdate(orderAccount, orderInstrument, orderId, exchangeOrderId, orderName, orderState,
                        orderAction, orderType, orderQuantity, orderQuantityChanged, orderFilled, orderAverageFillPrice,
                        orderLimitPrice, orderLimitPriceChanged, orderStopPrice, orderStopPriceChanged, isMarket, isStopMarket,
                        isLimit);
                }
            }
            catch (Exception ex)
            {
                //log and stuff exception
                RealLogger.PrintOutput("Exception calling OnOrderUpdate:" + ex.Message + " " + ex.StackTrace);
            }
        }

        private void LoadPositions()
        {
            RealPositionService.LoadPositions(account);
            RealOrderService.LoadOrders(account, RealPositionService.PositionCount);

            if (RealPositionService.PositionCount > 0)
            {
                validateAttachedPositionStopLossQuantity = true;
                validateAttachedPositionTakeProfitQuantity = true;
                validateBlendedPositionStopLossQuantity = true;
                validateBlendedPositionTakeProfitQuantity = true;
            }
        }

        private string EscapeKeyName(string keyName)
        {
            string newKeyName = keyName.Replace(' ', '_');

            return newKeyName;
        }

        string BuildBogeyTargetHLineKey()
        {
            string key = BuildObjectFullName("dayoverbt_");

            return key;
        }

        string BuildBogeyTargetBreakEvenHLineKey()
        {
            string key = BuildObjectFullName("btbe_");

            return key;
        }

        string BuildBogeyTargetDaily1HLineKey()
        {
            string key = BuildObjectFullName("btd1_");

            return key;
        }

        string BuildBogeyTargetDaily2HLineKey()
        {
            string key = BuildObjectFullName("btd2_");

            return key;
        }

        string BuildBogeyTargetDaily3HLineKey()
        {
            string key = BuildObjectFullName("btd3_");

            return key;
        }

        string BuildBogeyTargetDaily4HLineKey()
        {
            string key = BuildObjectFullName("btd4_");

            return key;
        }

        string BuildBogeyTargetDaily5HLineKey()
        {
            string key = BuildObjectFullName("btd5_");

            return key;
        }

        string BuildDayOverMaxLossHLineKey()
        {
            string key = BuildObjectFullName("dayoverdml_");

            return key;
        }

        string BuildDayOverAccountBalanceFloorHLineKey()
        {
            string key = BuildObjectFullName("dayoverabfl_");

            return key;
        }

        string BuildECATakeProfitHLineKey()
        {
            string key = BuildObjectFullName("ecatpl_");

            return key;
        }

        string BuildAveragePriceHLineKey()
        {
            string key = BuildObjectFullName("avgpl_");

            return key;
        }

        private string BuildObjectFullName(string name)
        {
            string fullName = ObjectPrefix + name;
            return fullName;
        }

        private bool RemoveDayOverMaxLossLine()
        {
            bool returnFlag = false;

            if (dayOverMaxLossLineVisible)
            {
                string key = BuildDayOverMaxLossHLineKey();

                RemoveDrawObject(key);

                dayOverMaxLossLineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetLine()
        {
            bool returnFlag = false;

            if (bogeyTargetLineVisible)
            {
                string key = BuildBogeyTargetHLineKey();

                RemoveDrawObject(key);

                bogeyTargetLineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetBreakEvenLine()
        {
            bool returnFlag = false;

            if (bogeyTargetBreakEvenLineVisible)
            {
                string key = BuildBogeyTargetBreakEvenHLineKey();

                RemoveDrawObject(key);

                bogeyTargetBreakEvenLineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetDaily1Line()
        {
            bool returnFlag = false;

            if (bogeyTargetDaily1LineVisible)
            {
                string key = BuildBogeyTargetDaily1HLineKey();

                RemoveDrawObject(key);

                bogeyTargetDaily1LineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetDaily2Line()
        {
            bool returnFlag = false;

            if (bogeyTargetDaily2LineVisible)
            {
                string key = BuildBogeyTargetDaily2HLineKey();

                RemoveDrawObject(key);

                bogeyTargetDaily2LineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetDaily3Line()
        {
            bool returnFlag = false;

            if (bogeyTargetDaily3LineVisible)
            {
                string key = BuildBogeyTargetDaily3HLineKey();

                RemoveDrawObject(key);

                bogeyTargetDaily3LineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetDaily4Line()
        {
            bool returnFlag = false;

            if (bogeyTargetDaily4LineVisible)
            {
                string key = BuildBogeyTargetDaily4HLineKey();

                RemoveDrawObject(key);

                bogeyTargetDaily4LineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveBogeyTargetDaily5Line()
        {
            bool returnFlag = false;

            if (bogeyTargetDaily5LineVisible)
            {
                string key = BuildBogeyTargetDaily5HLineKey();

                RemoveDrawObject(key);

                bogeyTargetDaily5LineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveDayOverAccountBalanceFloorLine()
        {
            bool returnFlag = false;

            if (dayOverAccountBalanceFloorLineVisible)
            {
                string key = BuildDayOverAccountBalanceFloorHLineKey();

                RemoveDrawObject(key);

                dayOverAccountBalanceFloorLineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveECATakeProfitLine()
        {
            bool returnFlag = false;

            if (ecaTakeProfitLineVisible)
            {
                string key = BuildECATakeProfitHLineKey();

                RemoveDrawObject(key);

                ecaTakeProfitLineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool RemoveAveragePriceLine()
        {
            bool returnFlag = false;

            if (averagePriceLineVisible)
            {
                string key = BuildAveragePriceHLineKey();

                RemoveDrawObject(key);

                averagePriceLineVisible = false;
                returnFlag = true;
            }

            return returnFlag;
        }

        private void DrawHLine(string key, double price, Brush lineColor, DashStyleHelper lineDashStyle, int lineWidth, int zOrder = 10000)
        {
            HorizontalLine tempObject = Draw.HorizontalLine(this, key, false, price, lineColor, lineDashStyle, lineWidth);
            tempObject.IsLocked = true;
            tempObject.IgnoresUserInput = true;
            tempObject.ZOrder = zOrder;

            tempObject.Dispose();
        }
        private void DrawLabeledHLine(string key, double price, Brush lineColor, DashStyleHelper lineDashStyle, int lineWidth, string text, double horizontalOffset, int zOrder = 10000)
        {
            int fontSize = 13;
            int opacity = 100;

            ZLabeledHorizontalLine tempObject = DrawZLabledLine.ZLabeledHorizontalLine(this, key, false, price, lineColor, lineDashStyle, lineWidth);
            tempObject.AppendPriceTime = false;
            tempObject.DisplayText = text;
            tempObject.Font = new SimpleFont(this.ChartControl.Properties.LabelFont.Family.ToString(), fontSize);
            tempObject.HorizontalOffset = horizontalOffset;
            tempObject.OutlineStroke = new Stroke(lineColor, lineWidth);
            tempObject.AreaOpacity = opacity;
            tempObject.TextBrush = Brushes.Black;
            tempObject.BackgroundBrush = lineColor;
            tempObject.ZOrder = zOrder;

            tempObject.IsLocked = true;
            tempObject.IgnoresUserInput = true;

            tempObject.Dispose();
        }

        private void RefreshDayOverLines()
        {
            string signalName = "RefreshDayOverLines";
            bool removedLine = false;

            if (IsDayOverAccountBalanceFloorEnabled() && dayOverAccountBalanceFloorHasChanged)
            {
                if (IsDayOverAccountBalanceFloorEnabled())
                {
                    bool readyForRefresh = lastDayOverAccountBalanceRefreshTime <= GetDateTimeNow();

                    if (readyForRefresh || lastDayOverAccountBalance <= 0)
                    {
                        lastDayOverAccountBalance = Math.Round(account.Get(AccountItem.CashValue, Currency.UsDollar), 2);
                        lastDayOverAccountBalanceRefreshTime = (GetDateTimeNow()).AddSeconds(DayOverAccountBalanceRefreshDelaySeconds);
                    }
                }

                bool lastDayOverAccountBalanceFloorDollarsChanged = lastDayOverAccountBalance != lastDayOverAccountBalanceFloorDollars;
                if (lastDayOverAccountBalanceFloorDollarsChanged) lastDayOverAccountBalanceFloorDollars = lastDayOverAccountBalance;
                bool lastDayOverAccountBalanceFloorPositionTypeChanged = dayOverAccountBalanceFloorMarketPosition != lastDayOverAccountBalanceFloorPositionType;
                bool lastDayOverAccountBalanceFloorPositionPriceChanged = dayOverAccountBalanceFloorPositionPrice != lastDayOverAccountBalanceFloorPositionPrice;
                bool lastDayOverAccountBalanceFloorPositionQuantityChanged = dayOverAccountBalanceFloorPositionQuantity != lastDayOverAccountBalanceFloorPositionQuantity;

                if (attachedInstrumentHasPosition && lastDayOverAccountBalance > 0 &&
                    (lastDayOverAccountBalanceFloorPositionTypeChanged ||
                    lastDayOverAccountBalanceFloorDollarsChanged ||
                    lastDayOverAccountBalanceFloorPositionPriceChanged ||
                    lastDayOverAccountBalanceFloorPositionQuantityChanged))
                {

                    lastDayOverAccountBalanceFloorPositionType = dayOverAccountBalanceFloorMarketPosition;
                    lastDayOverAccountBalanceFloorPositionPrice = dayOverAccountBalanceFloorPositionPrice;
                    lastDayOverAccountBalanceFloorPositionQuantity = dayOverAccountBalanceFloorPositionQuantity;

                    double newLinePrice = 0;

                    double equityToFloorDiff = lastDayOverAccountBalance - DayOverAccountBalanceFloorDollars;

                    if (lastDayOverAccountBalanceFloorPositionType == MarketPosition.Long)
                    {
                        int balanceToFloorRemainingTicks = (int)Math.Ceiling((equityToFloorDiff / (lastDayOverAccountBalanceFloorPositionQuantity * attachedInstrumentTickValue)));
                        newLinePrice = lastDayOverAccountBalanceFloorPositionPrice - (balanceToFloorRemainingTicks * attachedInstrumentTickSize);
                    }
                    else if (lastDayOverAccountBalanceFloorPositionType == MarketPosition.Short)
                    {
                        int balanceToFloorRemainingTicks = (int)Math.Floor(equityToFloorDiff / (lastDayOverAccountBalanceFloorPositionQuantity * attachedInstrumentTickValue));
                        newLinePrice = lastDayOverAccountBalanceFloorPositionPrice + (balanceToFloorRemainingTicks * attachedInstrumentTickSize);
                    }

                    bool isLinePriceValid = newLinePrice > 0;

                    if (isLinePriceValid)
                    {
                        bool dayOverAccountBalanceFloorLinePriceChanged = (newLinePrice != lastDayOverAccountBalanceFloorLinePrice);

                        if (dayOverAccountBalanceFloorLinePriceChanged)
                        {
                            lastDayOverAccountBalanceFloorLinePrice = newLinePrice;

                            string key = BuildDayOverAccountBalanceFloorHLineKey();
                            DrawHLine(key, lastDayOverAccountBalanceFloorLinePrice, dayOverAccountBalanceFloorLineBrush, dayOverAccountBalanceFloorLineDashStyle, dayOverAccountBalanceFloorLineWidth);
                            dayOverAccountBalanceFloorLineVisible = true;
                        }
                    }
                }
            }

            if (dayOverAccountBalanceFloorLineVisible && (!attachedInstrumentHasPosition || !IsDayOverAccountBalanceFloorEnabled()))
            {
                lastDayOverAccountBalanceRefreshTime = GetDateTimeNow();
                lastDayOverAccountBalanceFloorPositionType = MarketPosition.Flat;
                lastDayOverAccountBalanceFloorLinePrice = 0;
                lastDayOverAccountBalanceFloorPositionPrice = 0;
                lastDayOverAccountBalanceFloorPositionQuantity = 0;

                removedLine = (RemoveDayOverAccountBalanceFloorLine()) ? true : removedLine;
            }


            bool isBogeyTargetBreakEvenEnabled = (ShowBogeyTargetDailyBreakEvenLine && !bogeyTargetBreakEvenLineIsBrushTransparent);
            bool isBogeyTargetDaily1Enabled = (BogeyTargetDailyBaseDollars > 0 && ShowBogeyTargetDaily1Line && !bogeyTargetDaily1LineIsBrushTransparent);
            bool isBogeyTargetDaily2Enabled = (BogeyTargetDailyBaseDollars > 0 && ShowBogeyTargetDaily2Line && !bogeyTargetDaily2LineIsBrushTransparent);
            bool isBogeyTargetDaily3Enabled = (BogeyTargetDailyBaseDollars > 0 && ShowBogeyTargetDaily3Line && !bogeyTargetDaily3LineIsBrushTransparent);
            bool isBogeyTargetDaily4Enabled = (BogeyTargetDailyBaseDollars > 0 && ShowBogeyTargetDaily4Line && !bogeyTargetDaily4LineIsBrushTransparent);
            bool isBogeyTargetDaily5Enabled = (BogeyTargetDailyBaseDollars > 0 && ShowBogeyTargetDaily5Line && !bogeyTargetDaily5LineIsBrushTransparent);

            bool hasAnySupportedBogeyTarget = (IsBogeyTargetEnabled()
                || isBogeyTargetBreakEvenEnabled
                || isBogeyTargetDaily1Enabled
                || isBogeyTargetDaily2Enabled
                || isBogeyTargetDaily3Enabled
                || isBogeyTargetDaily4Enabled
                || isBogeyTargetDaily5Enabled);

            //if (BogeyTargetBaseDollars > 0 && currentBogeyTargetMultiplier != BogeyTargetMultiplierDisabled
            //&& currentProfitTargetStatus == TickHunterProfitTargetTypes.BogeyTarget)

            if (hasAnySupportedBogeyTarget && bogeyTargetHasChanged) //needs to be modified
            {
                double newLastBogeyTargetClosedOrderProfit = Math.Round(account.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar), 2);
                bool lastBogeyTargetClosedOrderProfitChanged = newLastBogeyTargetClosedOrderProfit != lastBogeyTargetClosedOrderProfit;
                if (lastBogeyTargetClosedOrderProfitChanged) lastBogeyTargetClosedOrderProfit = newLastBogeyTargetClosedOrderProfit;

                double newBogeyTargetBaseDollars = 0;

                if (IsBogeyTargetEnabled())
                {
                    double bogeyTargetMultiplier = currentBogeyTargetMultiplier;

                    if (lastBogeyTargetClosedOrderProfit > 0)
                    {
                        newBogeyTargetBaseDollars = (this.BogeyTargetBaseDollars * bogeyTargetMultiplier) - lastBogeyTargetClosedOrderProfit;
                    }
                    else
                    {
                        if (bogeyTargetStartWithFullPnLFlag)
                        {
                            newBogeyTargetBaseDollars = (this.BogeyTargetBaseDollars * bogeyTargetMultiplier) + (lastBogeyTargetClosedOrderProfit * -1);
                        }
                        else
                        {
                            newBogeyTargetBaseDollars = (this.BogeyTargetBaseDollars * bogeyTargetMultiplier);
                        }
                    }

                    if (newBogeyTargetBaseDollars <= 0) newBogeyTargetBaseDollars = 0.1;
                }

                bool lastBogeyTargetBaseDollarsChanged = newBogeyTargetBaseDollars != lastBogeyTargetBaseDollars;
                if (lastBogeyTargetBaseDollarsChanged) lastBogeyTargetBaseDollars = newBogeyTargetBaseDollars;

                if (IsBogeyTargetEnabled() && bogeyTargetInfoLabel != null && (bogeyTargetInfoLabel.Content == "" || lastBogeyTargetBaseDollarsChanged))
                {
                    string bogeyTargetInfoText = " BogeyTarget: $" + this.BogeyTargetBaseDollars.ToString("N0") + " / $" + lastBogeyTargetBaseDollars.ToString("N0") + " ";

                    bogeyTargetInfoLabel.Content = bogeyTargetInfoText;
                }

                bool lastBogeyTargetPositionTypeChanged = bogeyTargetMarketPosition != lastBogeyTargetPositionType;
                bool lastBogeyTargetPositionPriceChanged = bogeyTargetPositionPrice != lastBogeyTargetPositionPrice;
                bool lastBogeyTargetPositionQuantityChanged = bogeyTargetPositionQuantity != lastBogeyTargetPositionQuantity;

                double newBogeyTargetBreakEvenDollars = 0;

                if (isBogeyTargetBreakEvenEnabled)
                {
                    const double BreakEventBaseDollars = 1.0;

                    if (lastBogeyTargetClosedOrderProfit > 0)
                    {
                        newBogeyTargetBreakEvenDollars = BreakEventBaseDollars - lastBogeyTargetClosedOrderProfit;
                    }
                    else
                    {
                        newBogeyTargetBreakEvenDollars = (BreakEventBaseDollars) + (lastBogeyTargetClosedOrderProfit * -1);
                    }

                    if (newBogeyTargetBreakEvenDollars <= 0) newBogeyTargetBreakEvenDollars = 0.1;
                }

                bool lastBogeyTargetBreakEvenDollarsChanged = newBogeyTargetBreakEvenDollars != lastBogeyTargetBreakEvenDollars;
                if (lastBogeyTargetBreakEvenDollarsChanged) lastBogeyTargetBreakEvenDollars = newBogeyTargetBreakEvenDollars;

                double newBogeyTargetDaily1Dollars = 0;

                if (isBogeyTargetDaily1Enabled)
                {
                    if (lastBogeyTargetClosedOrderProfit > 0)
                    {
                        newBogeyTargetDaily1Dollars = (BogeyTargetDailyBaseDollars) - lastBogeyTargetClosedOrderProfit;
                    }
                    else
                    {
                        newBogeyTargetDaily1Dollars = (BogeyTargetDailyBaseDollars) + (lastBogeyTargetClosedOrderProfit * -1);
                    }

                    if (newBogeyTargetDaily1Dollars <= 0) newBogeyTargetDaily1Dollars = 0.1;
                }

                bool lastBogeyTargetDaily1DollarsChanged = newBogeyTargetDaily1Dollars != lastBogeyTargetDaily1Dollars;
                if (lastBogeyTargetDaily1DollarsChanged) lastBogeyTargetDaily1Dollars = newBogeyTargetDaily1Dollars;

                double newBogeyTargetDaily2Dollars = 0;

                if (isBogeyTargetDaily2Enabled)
                {
                    const double BogyTargetDailyMultiplier = 2;

                    if (lastBogeyTargetClosedOrderProfit > 0)
                    {
                        newBogeyTargetDaily2Dollars = (BogeyTargetDailyBaseDollars * BogyTargetDailyMultiplier) - lastBogeyTargetClosedOrderProfit;
                    }
                    else
                    {
                        newBogeyTargetDaily2Dollars = (BogeyTargetDailyBaseDollars * BogyTargetDailyMultiplier) + (lastBogeyTargetClosedOrderProfit * -1);
                    }

                    if (newBogeyTargetDaily2Dollars <= 0) newBogeyTargetDaily2Dollars = 0.1;
                }

                bool lastBogeyTargetDaily2DollarsChanged = newBogeyTargetDaily2Dollars != lastBogeyTargetDaily2Dollars;
                if (lastBogeyTargetDaily2DollarsChanged) lastBogeyTargetDaily2Dollars = newBogeyTargetDaily2Dollars;

                double newBogeyTargetDaily3Dollars = 0;

                if (isBogeyTargetDaily3Enabled)
                {
                    const double BogyTargetDailyMultiplier = 3;

                    if (lastBogeyTargetClosedOrderProfit > 0)
                    {
                        newBogeyTargetDaily3Dollars = (BogeyTargetDailyBaseDollars * BogyTargetDailyMultiplier) - lastBogeyTargetClosedOrderProfit;
                    }
                    else
                    {
                        newBogeyTargetDaily3Dollars = (BogeyTargetDailyBaseDollars * BogyTargetDailyMultiplier) + (lastBogeyTargetClosedOrderProfit * -1);
                    }

                    if (newBogeyTargetDaily3Dollars <= 0) newBogeyTargetDaily3Dollars = 0.1;
                }

                bool lastBogeyTargetDaily3DollarsChanged = newBogeyTargetDaily3Dollars != lastBogeyTargetDaily3Dollars;
                if (lastBogeyTargetDaily3DollarsChanged) lastBogeyTargetDaily3Dollars = newBogeyTargetDaily3Dollars;

                double newBogeyTargetDaily4Dollars = 0;

                if (isBogeyTargetDaily4Enabled)
                {
                    const double BogyTargetDailyMultiplier = 4;

                    if (lastBogeyTargetClosedOrderProfit > 0)
                    {
                        newBogeyTargetDaily4Dollars = (BogeyTargetDailyBaseDollars * BogyTargetDailyMultiplier) - lastBogeyTargetClosedOrderProfit;
                    }
                    else
                    {
                        newBogeyTargetDaily4Dollars = (BogeyTargetDailyBaseDollars * BogyTargetDailyMultiplier) + (lastBogeyTargetClosedOrderProfit * -1);
                    }

                    if (newBogeyTargetDaily4Dollars <= 0) newBogeyTargetDaily4Dollars = 0.1;
                }

                bool lastBogeyTargetDaily4DollarsChanged = newBogeyTargetDaily4Dollars != lastBogeyTargetDaily4Dollars;
                if (lastBogeyTargetDaily4DollarsChanged) lastBogeyTargetDaily4Dollars = newBogeyTargetDaily4Dollars;

                double newBogeyTargetDaily5Dollars = 0;

                if (isBogeyTargetDaily5Enabled)
                {
                    const double BogyTargetDailyMultiplier = 5;

                    if (lastBogeyTargetClosedOrderProfit > 0)
                    {
                        newBogeyTargetDaily5Dollars = (BogeyTargetDailyBaseDollars * BogyTargetDailyMultiplier) - lastBogeyTargetClosedOrderProfit;
                    }
                    else
                    {
                        newBogeyTargetDaily5Dollars = (BogeyTargetDailyBaseDollars * BogyTargetDailyMultiplier) + (lastBogeyTargetClosedOrderProfit * -1);
                    }

                    if (newBogeyTargetDaily5Dollars <= 0) newBogeyTargetDaily5Dollars = 0.1;
                }

                bool lastBogeyTargetDaily5DollarsChanged = newBogeyTargetDaily5Dollars != lastBogeyTargetDaily5Dollars;
                if (lastBogeyTargetDaily5DollarsChanged) lastBogeyTargetDaily5Dollars = newBogeyTargetDaily5Dollars;

                if (attachedInstrumentHasPosition || blendedInstrumentHasPosition)
                {
                    if (lastBogeyTargetBaseDollarsChanged
                        || lastBogeyTargetBreakEvenDollarsChanged
                        || lastBogeyTargetDaily1DollarsChanged || lastBogeyTargetDaily2DollarsChanged || lastBogeyTargetDaily3DollarsChanged
                        || lastBogeyTargetDaily4DollarsChanged || lastBogeyTargetDaily5DollarsChanged
                        || lastBogeyTargetPositionTypeChanged || lastBogeyTargetPositionPriceChanged || lastBogeyTargetPositionQuantityChanged)
                    {
                        lastBogeyTargetPositionType = bogeyTargetMarketPosition;
                        lastBogeyTargetPositionPrice = bogeyTargetPositionPrice;
                        lastBogeyTargetPositionQuantity = bogeyTargetPositionQuantity;

                        if (IsBogeyTargetEnabled())
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetBaseDollars);
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetBaseDollars);
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetLinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetLinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetHLineKey();
                                    DrawHLine(key, lastBogeyTargetLinePrice, bogeyTargetLineBrush, bogeyTargetLineDashStyle, bogeyTargetLineWidth);

                                    bogeyTargetLineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                        if (isBogeyTargetBreakEvenEnabled)
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetBreakEvenDollars);
                                if (lastBogeyTargetPositionPrice >= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetBreakEvenDollars);
                                if (lastBogeyTargetPositionPrice <= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetBreakEvenLinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetBreakEvenLinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetBreakEvenHLineKey();
                                    DrawHLine(key, lastBogeyTargetBreakEvenLinePrice, bogeyTargetBreakEvenLineBrush, bogeyTargetBreakEvenLineDashStyle, bogeyTargetBreakEvenLineWidth);

                                    bogeyTargetBreakEvenLineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                        if (isBogeyTargetDaily1Enabled)
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily1Dollars);
                                if (lastBogeyTargetPositionPrice >= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily1Dollars);
                                if (lastBogeyTargetPositionPrice <= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetDaily1LinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetDaily1LinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetDaily1HLineKey();
                                    DrawHLine(key, lastBogeyTargetDaily1LinePrice, bogeyTargetDaily1LineBrush, bogeyTargetDaily1LineDashStyle, bogeyTargetDaily1LineWidth);

                                    bogeyTargetDaily1LineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                        if (isBogeyTargetDaily2Enabled)
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily2Dollars);
                                if (lastBogeyTargetPositionPrice >= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily2Dollars);
                                if (lastBogeyTargetPositionPrice <= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetDaily2LinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetDaily2LinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetDaily2HLineKey();
                                    DrawHLine(key, lastBogeyTargetDaily2LinePrice, bogeyTargetDaily2LineBrush, bogeyTargetDaily2LineDashStyle, bogeyTargetDaily2LineWidth);

                                    bogeyTargetDaily2LineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                        if (isBogeyTargetDaily3Enabled)
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily3Dollars);
                                if (lastBogeyTargetPositionPrice >= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily3Dollars);
                                if (lastBogeyTargetPositionPrice <= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetDaily3LinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetDaily3LinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetDaily3HLineKey();
                                    DrawHLine(key, lastBogeyTargetDaily3LinePrice, bogeyTargetDaily3LineBrush, bogeyTargetDaily3LineDashStyle, bogeyTargetDaily3LineWidth);

                                    bogeyTargetDaily3LineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                        if (isBogeyTargetDaily4Enabled)
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily4Dollars);
                                if (lastBogeyTargetPositionPrice >= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily4Dollars);
                                if (lastBogeyTargetPositionPrice <= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetDaily4LinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetDaily4LinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetDaily4HLineKey();
                                    DrawHLine(key, lastBogeyTargetDaily4LinePrice, bogeyTargetDaily4LineBrush, bogeyTargetDaily4LineDashStyle, bogeyTargetDaily4LineWidth);

                                    bogeyTargetDaily4LineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                        if (isBogeyTargetDaily5Enabled)
                        {
                            double newLinePrice = 0;

                            if (lastBogeyTargetPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Long, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily5Dollars);
                                if (lastBogeyTargetPositionPrice >= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }
                            else if (lastBogeyTargetPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetBogeyTargetFromDollars(attachedInstrument, MarketPosition.Short, lastBogeyTargetPositionPrice, lastBogeyTargetPositionQuantity, lastBogeyTargetDaily5Dollars);
                                if (lastBogeyTargetPositionPrice <= newLinePrice)
                                {
                                    newLinePrice = 0;
                                }
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool bogeyTargetLinePriceChanged = (newLinePrice != lastBogeyTargetDaily5LinePrice);

                                if (bogeyTargetLinePriceChanged)
                                {
                                    lastBogeyTargetDaily5LinePrice = RealInstrumentService.NormalizePrice(attachedInstrument, newLinePrice);

                                    string key = BuildBogeyTargetDaily5HLineKey();
                                    DrawHLine(key, lastBogeyTargetDaily5LinePrice, bogeyTargetDaily5LineBrush, bogeyTargetDaily5LineDashStyle, bogeyTargetDaily5LineWidth);

                                    bogeyTargetDaily5LineVisible = true;

                                    bogeyTargetLinePriceChanged = false;
                                }
                            }
                        }

                    }
                }
            }

            if (!IsBogeyTargetEnabled())
            {
                if (bogeyTargetInfoLabel != null && bogeyTargetInfoLabel.Content != "")
                {
                    bogeyTargetInfoLabel.Content = "";
                }
            }

            if (bogeyTargetLineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !IsBogeyTargetEnabled()))
            {
                lastBogeyTargetPositionType = MarketPosition.Flat;
                lastBogeyTargetLinePrice = 0;
                lastBogeyTargetPositionPrice = 0;
                lastBogeyTargetPositionQuantity = 0;
                removedLine = (RemoveBogeyTargetLine()) ? true : removedLine;
            }

            if (bogeyTargetBreakEvenLineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !isBogeyTargetBreakEvenEnabled))
            {
                lastBogeyTargetBreakEvenLinePrice = 0;
                lastBogeyTargetBreakEvenDollars = 0;
                RemoveBogeyTargetBreakEvenLine();
            }

            if (bogeyTargetDaily1LineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !isBogeyTargetDaily1Enabled))
            {
                lastBogeyTargetDaily1LinePrice = 0;
                lastBogeyTargetDaily1Dollars = 0;
                RemoveBogeyTargetDaily1Line();
            }

            if (bogeyTargetDaily2LineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !isBogeyTargetDaily2Enabled))
            {
                lastBogeyTargetDaily2LinePrice = 0;
                lastBogeyTargetDaily2Dollars = 0;
                RemoveBogeyTargetDaily2Line();
            }

            if (bogeyTargetDaily3LineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !isBogeyTargetDaily3Enabled))
            {
                lastBogeyTargetDaily3LinePrice = 0;
                lastBogeyTargetDaily3Dollars = 0;
                RemoveBogeyTargetDaily3Line();
            }

            if (bogeyTargetDaily4LineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !isBogeyTargetDaily4Enabled))
            {
                lastBogeyTargetDaily4LinePrice = 0;
                lastBogeyTargetDaily4Dollars = 0;
                RemoveBogeyTargetDaily4Line();
            }

            if (bogeyTargetDaily5LineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !isBogeyTargetDaily5Enabled))
            {
                lastBogeyTargetDaily5LinePrice = 0;
                lastBogeyTargetDaily5Dollars = 0;
                RemoveBogeyTargetDaily5Line();
            }


            if (IsDayOverMaxLossEnabled() && dayOverMaxLossHasChanged)
            {
                double newLastDayOverMaxLossClosedOrderProfit = Math.Round(account.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar), 2);
                bool lastDayOverMaxLossClosedOrderProfitChanged = newLastDayOverMaxLossClosedOrderProfit != lastDayOverMaxLossClosedOrderProfit;
                if (lastDayOverMaxLossClosedOrderProfitChanged) lastDayOverMaxLossClosedOrderProfit = newLastDayOverMaxLossClosedOrderProfit;

                //if (lastDayOverMaxLossClosedOrderProfitChanged && newLastDayOverMaxLossClosedOrderProfit > lastDayOverMaxLossHighestPnLInSessionPnL)
                //{
                //    lastDayOverMaxLossHighestPnLInSessionPnL = newLastDayOverMaxLossClosedOrderProfit;
                //    StoreStateDayOverMaxLossHighestPnLInSession();
                //}

                //RealLogger.PrintOutput("lastDayOverMaxLossHighestPnLInSessionPnL=" + lastDayOverMaxLossHighestPnLInSessionPnL + " newLastDayOverMaxLossClosedOrderProfit=" + newLastDayOverMaxLossClosedOrderProfit);

                double newDayOverMaxLossDollars = 0;

                //if (DayOverMaxLossIncludeProfit)
                //{

                //}
                //else
                //{
                //    newDayOverMaxLossDollars = this.DayOverMaxLossDollars - lastDayOverMaxLossHighestPnLInSessionPnL + lastDayOverMaxLossClosedOrderProfit;
                //}
                newDayOverMaxLossDollars = this.dayOverMaxLossDollars + lastDayOverMaxLossClosedOrderProfit;

                bool lastDayOverMaxLossDollarsChanged = newDayOverMaxLossDollars != lastDayOverMaxLossDollars;
                if (lastDayOverMaxLossDollarsChanged)
                {
                    lastDayOverMaxLossDollars = newDayOverMaxLossDollars;

                    if (UseDayOverMaxLossTrailing)
                    {
                        if (DayOverMaxAccountPnLPeakDollars > 0)
                        {
                            dayOverMaxAccountPnLPeakDollars = Math.Max(DayOverMaxAccountPnLPeakDollars, lastDayOverMaxLossClosedOrderProfit);
                        }
                        else
                        {
                            dayOverMaxAccountPnLPeakDollars = Math.Max(dayOverMaxAccountPnLPeakDollars, lastDayOverMaxLossClosedOrderProfit);
                        }

                        lastDayOverMaxLossDollars = (this.dayOverMaxLossDollars + lastDayOverMaxLossClosedOrderProfit) - dayOverMaxAccountPnLPeakDollars;
                    }

                    double lastAutoAddOnMaxDollar = autoAddOnMaxDollars;
                    autoAddOnMaxDollars = CalculateAutoAddOnMaxDollars(AutoAddOnMaxDollars, StopLossInitialDollars, lastDayOverMaxLossDollars);
                    bool autoAddOnMaxDollarsChanged = lastAutoAddOnMaxDollar != autoAddOnMaxDollars;

                    if (toggleAutoAddOnButton != null && autoAddOnMaxDollarsChanged && currentAutoAddOnStatus == TickHunterAutoAddOnTypes.Disabled)
                    {
                        DisableAutoAddOnButton(0);
                    }
                }

                bool lastDayOverMaxLossPositionTypeChanged = dayOverMaxLossMarketPosition != lastDayOverMaxLossPositionType;
                bool lastDayOverMaxLossPositionPriceChanged = dayOverMaxLossPositionPrice != lastDayOverMaxLossPositionPrice;
                bool lastDayOverMaxLossPositionQuantityChanged = dayOverMaxLossPositionQuantity != lastDayOverMaxLossPositionQuantity;

                if (lastDayOverMaxLossDollars <= 0)
                {
                    activeDayOverMaxLossAutoClose = true;
                }
                else
                {
                    activeDayOverMaxLossAutoClose = false;
                }

                if (attachedInstrumentHasPosition || blendedInstrumentHasPosition)
                {
                    if (!activeDayOverMaxLossAutoClose &&
                        (lastDayOverMaxLossPositionTypeChanged || lastDayOverMaxLossDollarsChanged || lastDayOverMaxLossPositionPriceChanged || lastDayOverMaxLossPositionQuantityChanged))
                    {
                        lastDayOverMaxLossPositionType = dayOverMaxLossMarketPosition;
                        lastDayOverMaxLossPositionPrice = dayOverMaxLossPositionPrice;
                        lastDayOverMaxLossPositionQuantity = dayOverMaxLossPositionQuantity;

                        double newLinePrice = 0;

                        if (lastDayOverMaxLossPositionType == MarketPosition.Long)
                        {
                            newLinePrice = GetDayOverMaxLossFromDollars(MarketPosition.Long, lastDayOverMaxLossPositionPrice, lastDayOverMaxLossPositionQuantity, lastDayOverMaxLossDollars);
                        }
                        else if (lastDayOverMaxLossPositionType == MarketPosition.Short)
                        {
                            newLinePrice = GetDayOverMaxLossFromDollars(MarketPosition.Short, lastDayOverMaxLossPositionPrice, lastDayOverMaxLossPositionQuantity, lastDayOverMaxLossDollars);
                        }

                        bool isLinePriceValid = newLinePrice > 0;

                        if (isLinePriceValid)
                        {
                            bool dayOverMaxLossLinePriceChanged = (newLinePrice != lastDayOverMaxLossLinePrice);

                            if (dayOverMaxLossLinePriceChanged)
                            {
                                lastDayOverMaxLossLinePrice = newLinePrice;

                                string key = BuildDayOverMaxLossHLineKey();
                                DrawHLine(key, lastDayOverMaxLossLinePrice, dayOverMaxLossLineBrush, dayOverMaxLossLineDashStyle, dayOverMaxLossLineWidth);

                                dayOverMaxLossLineVisible = true;

                                dayOverMaxLossLinePriceChanged = false;
                            }
                        }
                    }
                }
            }


            if (dayOverMaxLossLineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !IsDayOverMaxLossEnabled()))
            {
                lastDayOverMaxLossPositionType = MarketPosition.Flat;
                lastDayOverMaxLossLinePrice = 0;
                lastDayOverMaxLossPositionPrice = 0;
                lastDayOverMaxLossPositionQuantity = 0;
                removedLine = (RemoveDayOverMaxLossLine()) ? true : removedLine;
            }

            //Print("dayOverAccountBalanceFloorHasChanged=" + dayOverAccountBalanceFloorHasChanged + " lastDayOverAccountBalanceFloorDollars=" + lastDayOverAccountBalanceFloorDollars);

            if (dayOverMaxLossInfoLabel != null && (dayOverMaxLossHasChanged || dayOverAccountBalanceFloorHasChanged))
            {
                bool lastDayOverAccountFloorInfoDollarsChanged = false;
                bool lastDayOverMaxLossInfoDollarsChanged = false;

                if (IsDayOverAccountBalanceFloorEnabled() && dayOverAccountBalanceFloorHasChanged)
                {
                    lastDayOverAccountFloorInfoDollarsChanged = lastDayOverAccountFloorInfoDollars != DayOverAccountBalanceFloorDollars;
                    if (lastDayOverAccountFloorInfoDollarsChanged) lastDayOverAccountFloorInfoDollars = DayOverAccountBalanceFloorDollars;

                    if (lastDayOverAccountFloorInfoDollarsChanged)
                    {
                        string formattedAccountFloorDollars = "";

                        formattedAccountFloorDollars = "$" + lastDayOverAccountFloorInfoDollars.ToString("N0");

                        lastDayOverAccountFloorLabelText = " Floor: " + formattedAccountFloorDollars + " ";
                    }
                }

                if (IsDayOverMaxLossEnabled() && dayOverMaxLossHasChanged)
                {
                    lastDayOverMaxLossInfoDollarsChanged = lastDayOverMaxLossInfoDollars != lastDayOverMaxLossDollars;
                    if (lastDayOverMaxLossInfoDollarsChanged) lastDayOverMaxLossInfoDollars = lastDayOverMaxLossDollars;

                    if (lastDayOverMaxLossInfoDollarsChanged)
                    {
                        double tempDayOverMaxLossRemaining = lastDayOverMaxLossDollars;
                        string formattedDailyMaxDollars = "";
                        if (lastDayOverMaxLossDollars > 0)
                        {
                            formattedDailyMaxDollars = "$" + tempDayOverMaxLossRemaining.ToString("N0");
                        }
                        else
                        {
                            formattedDailyMaxDollars = "($" + tempDayOverMaxLossRemaining.ToString("N0") + ")";
                        }

                        //lastDayOverMaxLossLabelText = formattedDailyMaxDollars + " / $" + dayOverMaxLossDollars.ToString("N0");
                        lastDayOverMaxLossLabelText = " MaxLoss: $" + dayOverMaxLossDollars.ToString("N0") + " / " + formattedDailyMaxDollars + " ";
                    }
                }

                if (IsDayOverMaxLossEnabled() && dayOverMaxLossHasChanged && UseDayOverMaxLossTrailing)
                {
                    bool lastDayOverMaxLossAccountPnLPeakInfoDollarsChanged = lastDayOverMaxLossAccountPnLPeakInfoDollars != dayOverMaxAccountPnLPeakDollars;
                    if (lastDayOverMaxLossAccountPnLPeakInfoDollarsChanged) lastDayOverMaxLossAccountPnLPeakInfoDollars = dayOverMaxAccountPnLPeakDollars;

                    if (lastDayOverMaxLossAccountPnLPeakInfoDollarsChanged || lastDayOverMaxAccountPnLPeakLabelText == "")
                    {
                        string formattedAccountPnLPeakDollars = "";

                        formattedAccountPnLPeakDollars = "$" + dayOverMaxAccountPnLPeakDollars.ToString("N0");

                        lastDayOverMaxAccountPnLPeakLabelText = " Peak: " + formattedAccountPnLPeakDollars + " ";
                    }
                }

                if (lastDayOverAccountFloorInfoDollarsChanged || lastDayOverMaxLossInfoDollarsChanged)
                {
                    if (lastDayOverMaxLossLabelText != "" && lastDayOverAccountFloorLabelText != "" && lastDayOverMaxAccountPnLPeakLabelText != "")
                    {
                        dayOverMaxLossInfoLabel.Content = lastDayOverMaxLossLabelText + "   " + lastDayOverMaxAccountPnLPeakLabelText + "   " + lastDayOverAccountFloorLabelText;
                    }
                    else if (lastDayOverMaxLossLabelText != "" && lastDayOverAccountFloorLabelText != "")
                    {
                        dayOverMaxLossInfoLabel.Content = lastDayOverMaxLossLabelText + "   " + lastDayOverAccountFloorLabelText;
                    }
                    else if (lastDayOverMaxLossLabelText != "" && lastDayOverMaxAccountPnLPeakLabelText != "")
                    {
                        dayOverMaxLossInfoLabel.Content = lastDayOverMaxLossLabelText + "   " + lastDayOverMaxAccountPnLPeakLabelText;
                    }
                    else if (lastDayOverMaxLossLabelText != "")
                    {
                        dayOverMaxLossInfoLabel.Content = lastDayOverMaxLossLabelText;
                    }
                    else if (lastDayOverAccountFloorLabelText != "")
                    {
                        dayOverMaxLossInfoLabel.Content = lastDayOverAccountFloorLabelText;
                    }
                    else
                    {
                        dayOverMaxLossInfoLabel.Content = "";
                    }
                }
            }

            dayOverAccountBalanceFloorHasChanged = false;
            dayOverMaxLossHasChanged = false;
            bogeyTargetHasChanged = false;

            if (IsECATPEnabled() && ecaTakeProfitHasChanged)
            {
                if (attachedInstrumentHasPosition || blendedInstrumentHasPosition)
                {
                    bool lastECATakeProfitDollarsChanged = cacheECATakeProfitDollars != lastECATakeProfitDollars;
                    if (lastECATakeProfitDollarsChanged) lastECATakeProfitDollars = cacheECATakeProfitDollars;

                    bool lastECATakeProfitPositionTypeChanged = ecaTakeProfitMarketPosition != lastECATakeProfitPositionType;
                    bool lastECATakeProfitPositionPriceChanged = ecaTakeProfitPositionPrice != lastECATakeProfitPositionPrice;
                    bool lastECATakeProfitPositionQuantityChanged = ecaTakeProfitPositionQuantity != lastECATakeProfitPositionQuantity;

                    if (attachedInstrumentHasPosition || blendedInstrumentHasPosition)
                    {
                        if (lastECATakeProfitPositionTypeChanged || lastECATakeProfitDollarsChanged || lastECATakeProfitPositionPriceChanged || lastECATakeProfitPositionQuantityChanged)
                        {
                            lastECATakeProfitPositionType = ecaTakeProfitMarketPosition;
                            lastECATakeProfitPositionPrice = ecaTakeProfitPositionPrice;
                            lastECATakeProfitPositionQuantity = ecaTakeProfitPositionQuantity;

                            double newLinePrice = 0;

                            if (lastECATakeProfitPositionType == MarketPosition.Long)
                            {
                                newLinePrice = GetECATakeProfitPriceFromDollars(MarketPosition.Long, lastECATakeProfitPositionPrice, lastECATakeProfitPositionQuantity, lastECATakeProfitDollars);
                            }
                            else if (lastECATakeProfitPositionType == MarketPosition.Short)
                            {
                                newLinePrice = GetECATakeProfitPriceFromDollars(MarketPosition.Short, lastECATakeProfitPositionPrice, lastECATakeProfitPositionQuantity, lastECATakeProfitDollars);
                            }

                            bool isLinePriceValid = newLinePrice > 0;

                            if (isLinePriceValid)
                            {
                                bool ecaTakeProfitLinePriceChanged = (newLinePrice != lastECATakeProfitLinePrice);

                                if (ecaTakeProfitLinePriceChanged)
                                {
                                    lastECATakeProfitLinePrice = newLinePrice;



                                    string key = BuildECATakeProfitHLineKey();
                                    DrawHLine(key, lastECATakeProfitLinePrice, ecaTakeProfitLineBrush, ecaTakeProfitLineDashStyle, ecaTakeProfitLineWidth);

                                    ecaTakeProfitLineVisible = true;
                                    ecaTakeProfitLinePriceChanged = false;
                                }
                            }
                        }
                    }
                }
            }

            if (ecaTakeProfitLineVisible && ((!attachedInstrumentHasPosition && !blendedInstrumentHasPosition) || !IsECATPEnabled()))
            {
                lastECATakeProfitPositionType = MarketPosition.Flat;
                lastECATakeProfitLinePrice = 0;
                lastECATakeProfitPositionPrice = 0;
                lastECATakeProfitPositionQuantity = 0;
                removedLine = (RemoveECATakeProfitLine()) ? true : removedLine;

            }

            ecaTakeProfitHasChanged = false;

            if (averagePriceHasChanged)
            {
                if (attachedInstrumentHasPosition || blendedInstrumentHasPosition)
                {
                    bool lastAveragePricePositionTypeChanged = averagePriceMarketPosition != lastAveragePricePositionType;
                    bool lastAveragePricePositionPriceChanged = averagePricePositionPrice != lastAveragePricePositionPrice;
                    bool lastAveragePricePositionQuantityChanged = averagePricePositionQuantity != lastAveragePricePositionQuantity;

                    if (lastAveragePricePositionTypeChanged || lastAveragePricePositionPriceChanged || lastAveragePricePositionQuantityChanged)
                    {
                        lastAveragePricePositionType = averagePriceMarketPosition;
                        lastAveragePricePositionPrice = averagePricePositionPrice;
                        lastAveragePricePositionQuantity = averagePricePositionQuantity;

                        double newLinePrice = 0;

                        newLinePrice = lastAveragePricePositionPrice;
                        /*
                        if (averagePriceHasPosition && blendedInstrumentHasPosition)
                        {
                            int eminiQuantity = 0;
                            double eminiAveragePrice = 0;
                            int microQuantity = 0;
                            double microAveragePrice = 0;

                            if (IsEminiInstrument(attachedInstrument))
                            {
                                microQuantity = lastBlendedInstrumentPositionQuantity;
                                microAveragePrice = lastBlendedInstrumentPositionPrice;

                                eminiQuantity = lastAveragePricePositionQuantity * MICRO_TO_EMINI_MULTIPLIER;
                                eminiAveragePrice = lastAveragePricePositionPrice;
                            }
                            else
                            {
                                microQuantity = lastAveragePricePositionQuantity;
                                microAveragePrice = lastAveragePricePositionPrice;

                                eminiQuantity = lastBlendedInstrumentPositionQuantity * MICRO_TO_EMINI_MULTIPLIER;
                                eminiAveragePrice = lastBlendedInstrumentPositionPrice;
                            }

                            int quantitySum = microQuantity + eminiQuantity;
                            double newWeightedAveragePrice = ((microAveragePrice * microQuantity) + (eminiAveragePrice * eminiQuantity)) / quantitySum;

                            newLinePrice = newWeightedAveragePrice;
                        }
                        else if (averagePriceHasPosition && !blendedInstrumentHasPosition)
                        {
                            newLinePrice = lastAveragePricePositionPrice;
                        }
                        else if (!averagePriceHasPosition && blendedInstrumentHasPosition)
                        {
                            newLinePrice = lastBlendedInstrumentPositionPrice;
                        }
                        */
                        bool isLinePriceValid = newLinePrice > 0;

                        if (isLinePriceValid)
                        {
                            bool averagePriceLinePriceChanged = (newLinePrice != lastAveragePriceLinePrice
                                || lastAveragePricePositionPriceChanged || lastAveragePricePositionQuantityChanged);

                            if (averagePriceLinePriceChanged)
                            {
                                lastAveragePriceLinePrice = newLinePrice;

                                string key = BuildAveragePriceHLineKey();



                                /*
                                int mixedInstrumentQuantity = lastAveragePricePositionQuantity;

                                if (attachedInstrumentHasPosition)
                                {
                                    if (attachedIsEMini)
                                    {
                                        blendQuantity += (lastAveragePricePositionQuantity * MICRO_TO_EMINI_MULTIPLIER);
                                    }
                                    else
                                    {
                                        blendQuantity += lastAveragePricePositionQuantity;
                                    }
                                }

                                if (blendedInstrumentHasPosition)
                                {
                                    if (!attachedIsEMini)
                                    {
                                        blendQuantity += (lastBlendedInstrumentPositionQuantity * MICRO_TO_EMINI_MULTIPLIER);
                                    }
                                    else
                                    {
                                        blendQuantity += lastBlendedInstrumentPositionQuantity;
                                    }
                                }
                                */

                                if (ShowAveragePriceLine && !averagePriceLineIsBrushTransparent)
                                {
                                    string formatter = "N" + RealInstrumentService.GetTickSizeDecimalPlaces(attachedInstrumentTickSize);
                                    string lineText = lastAveragePriceLinePrice.ToString(formatter);

                                    if (ShowAveragePriceLineQuantity)
                                    {
                                        lineText += " (" + lastAveragePricePositionQuantity.ToString("N0") + ")";
                                    }

                                    DrawLabeledHLine(key, lastAveragePriceLinePrice, averagePriceLineBrush, averagePriceLineDashStyle,
                                        averagePriceLineWidth, lineText, averagePriceLevelHorizontalOffset, AveragePriceLineZOrder);

                                    averagePriceLineVisible = true;
                                }

                                averagePriceLinePriceChanged = false;
                            }
                        }
                    }
                }
            }

            if (averagePriceLineVisible && !attachedInstrumentHasPosition && !blendedInstrumentHasPosition)
            {
                lastAveragePricePositionType = MarketPosition.Flat;
                lastAveragePricePositionPrice = 0;
                lastAveragePricePositionQuantity = 0;
                lastAveragePriceLinePrice = 0;

                removedLine = (RemoveAveragePriceLine()) ? true : removedLine;
            }

            averagePriceHasChanged = false;

            if (removedLine && currentBogeyTargetMultiplier != BogeyTargetMultiplierDisabled && nextBogeyTargetMultiplier != BogeyTargetMultiplierDisabled)
            {
                RealLogger.PrintOutput("Attempting Bogey Target button smart jump...");
                bool hasBogeyTargetJumped = AttemptBogeyTargetSmartJump();

                if (hasBogeyTargetJumped)
                {
                    DeactivateAutoEntryFeatures(signalName);
                }
            }
        }

        private double CalculateAutoAddOnMaxDollars(double originalAutoAddOnMaxDollars, double originalStopLossInitialDollars, double originalDayOverMaxLossDollars)
        {
            double newAutoAddOnMaxDollars = 0;
            bool isStopLossInitialDollarsEnabled = originalStopLossInitialDollars > 0;
            bool isAutoAddOnMaxDollarsEnabled = originalAutoAddOnMaxDollars > 0;
            bool isDayOverMaxDollarsEnabled = IsDayOverMaxLossEnabled();

            if (isStopLossInitialDollarsEnabled && isAutoAddOnMaxDollarsEnabled && isDayOverMaxDollarsEnabled)
            {
                newAutoAddOnMaxDollars = Math.Min(Math.Min(originalStopLossInitialDollars, originalAutoAddOnMaxDollars), originalDayOverMaxLossDollars);
            }
            else if (isStopLossInitialDollarsEnabled && isAutoAddOnMaxDollarsEnabled)
            {
                newAutoAddOnMaxDollars = Math.Min(originalStopLossInitialDollars, originalAutoAddOnMaxDollars);
            }
            else if (isStopLossInitialDollarsEnabled && isDayOverMaxDollarsEnabled)
            {
                newAutoAddOnMaxDollars = Math.Min(originalStopLossInitialDollars, originalDayOverMaxLossDollars);
            }
            else if (isAutoAddOnMaxDollarsEnabled && isDayOverMaxDollarsEnabled)
            {
                newAutoAddOnMaxDollars = Math.Min(originalAutoAddOnMaxDollars, originalDayOverMaxLossDollars);
            }
            else if (isDayOverMaxDollarsEnabled)
            {
                newAutoAddOnMaxDollars = originalDayOverMaxLossDollars;
            }
            else if (isAutoAddOnMaxDollarsEnabled)
            {
                newAutoAddOnMaxDollars = originalAutoAddOnMaxDollars;
            }
            else if (isStopLossInitialDollarsEnabled)
            {
                newAutoAddOnMaxDollars = originalStopLossInitialDollars;
            }

            bool isInvalidAutoAddOnMaxDollars = newAutoAddOnMaxDollars <= 0;

            if (isInvalidAutoAddOnMaxDollars) newAutoAddOnMaxDollars = DEFAULT_ADDON_MAX_DOLLARS;

            return newAutoAddOnMaxDollars;
        }

        private void RefreshProfitInfoLabel()
        {
            if (profitInfoLabel != null && profitInfoHasChanged)
            {
                double profitInfoTotalDollars = 0;

                int profitInfoAttachedTicks = 0;
                double profitInfoAttachedDollars = 0;
                bool attachedInstrumentHasTakeProfit = attachedInstrumentPositionTakeProfitPrice > 0;
                bool blendedInstrumentHasTakeProfit = blendedInstrumentPositionTakeProfitPrice > 0;

                if (attachedInstrumentHasPosition)
                {
                    profitInfoAttachedDollars = Math.Round(GetPositionProfitWithStoLoss(attachedInstrument, attachedInstrumentMarketPosition, attachedInstrumentPositionQuantity, attachedInstrumentPositionPrice, attachedInstrumentPositionTakeProfitPrice), 2);
                    if (attachedInstrumentHasTakeProfit) profitInfoAttachedTicks = (int)Math.Round(((profitInfoAttachedDollars / attachedInstrumentPositionQuantity) / RealInstrumentService.GetTickValue(attachedInstrument)), MidpointRounding.ToEven);
                    profitInfoTotalDollars += profitInfoAttachedDollars;
                }

                double profitInfoBlendedDollars = 0;
                double profitInfoBlendedTicks = 0;

                if (blendedInstrumentHasPosition)
                {
                    profitInfoBlendedDollars = Math.Round(GetPositionProfitWithStoLoss(blendedInstrument, blendedInstrumentMarketPosition, blendedInstrumentPositionQuantity, blendedInstrumentPositionPrice, blendedInstrumentPositionTakeProfitPrice), 2);
                    if (blendedInstrumentHasTakeProfit) profitInfoBlendedTicks = (int)Math.Round(((profitInfoBlendedDollars / blendedInstrumentPositionQuantity) / RealInstrumentService.GetTickValue(blendedInstrument)), MidpointRounding.ToEven);
                    profitInfoTotalDollars += profitInfoBlendedDollars;
                }

                if ((attachedInstrumentHasPosition && profitInfoHasChanged) || (blendedInstrumentHasPosition && profitInfoHasChanged))
                {
                    string profitDollarText = "";
                    string profitFullText = "";

                    if (profitInfoTotalDollars >= 0)
                    {
                        profitInfoLabel.Foreground = Brushes.LightGreen;
                        profitDollarText = "$" + profitInfoTotalDollars.ToString("N2");
                    }
                    else
                    {
                        profitInfoLabel.Foreground = Brushes.Tomato;
                        profitDollarText = "-$" + profitInfoTotalDollars.ToString("N2").Replace("-", "");

                    }

                    if (attachedInstrumentHasPosition
                        && attachedInstrumentHasTakeProfit
                        && profitInfoAttachedTicks != 0
                        && blendedInstrumentHasPosition
                        && blendedInstrumentHasTakeProfit
                        && profitInfoBlendedTicks != 0)
                    {
                        int profitInfoMaxTicks = (int)Math.Max(profitInfoAttachedTicks, profitInfoBlendedTicks);
                        profitFullText = " TakeProfit: " + profitDollarText + " (" + profitInfoMaxTicks.ToString("N0") + ") ";
                    }
                    else if (attachedInstrumentHasPosition
                        && attachedInstrumentHasTakeProfit
                        && profitInfoAttachedTicks != 0
                        && !blendedInstrumentHasPosition
                        && !blendedInstrumentHasTakeProfit
                        && profitInfoBlendedTicks == 0)
                    {
                        profitFullText = " TakeProfit: " + profitDollarText + " (" + profitInfoAttachedTicks.ToString("N0") + ") ";
                    }
                    else if (!attachedInstrumentHasPosition
                        && !attachedInstrumentHasTakeProfit
                        && profitInfoAttachedTicks == 0
                        && blendedInstrumentHasPosition
                        && blendedInstrumentHasTakeProfit
                        && profitInfoBlendedTicks != 0)
                    {
                        profitFullText = " TakeProfit: " + profitDollarText + " (" + profitInfoBlendedTicks.ToString("N0") + ") ";
                    }
                    else
                    {
                        profitInfoLabel.Foreground = Brushes.White;
                        profitFullText = " TakeProfit: " + "none ";
                    }

                    profitInfoLabel.Content = profitFullText;
                }
                else
                {
                    profitInfoLabel.Foreground = Brushes.White;
                    profitInfoLabel.Content = "";
                }

                profitInfoHasChanged = false;
            }
        }

        private void RefreshRiskInfoLabel()
        {
            if (riskInfoLabel != null && riskInfoHasChanged)
            {
                double riskInfoTotalDollars = 0;

                int riskInfoAttachedTicks = 0;
                double riskInfoAttachedDollars = 0;
                bool attachedInstrumentHasStopLoss = attachedInstrumentPositionStopLossPrice > 0;
                bool blendedInstrumentHasStopLoss = blendedInstrumentPositionStopLossPrice > 0;

                if (attachedInstrumentHasPosition)
                {
                    riskInfoAttachedDollars = Math.Round(GetPositionProfitWithStoLoss(attachedInstrument, attachedInstrumentMarketPosition, attachedInstrumentPositionQuantity, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice), 2);
                    if (attachedInstrumentHasStopLoss) riskInfoAttachedTicks = (int)Math.Round(((riskInfoAttachedDollars / attachedInstrumentPositionQuantity) / RealInstrumentService.GetTickValue(attachedInstrument)), MidpointRounding.ToEven);
                    riskInfoTotalDollars += riskInfoAttachedDollars;
                }

                double riskInfoBlendedDollars = 0;
                double riskInfoBlendedTicks = 0;

                if (blendedInstrumentHasPosition)
                {
                    riskInfoBlendedDollars = Math.Round(GetPositionProfitWithStoLoss(blendedInstrument, blendedInstrumentMarketPosition, blendedInstrumentPositionQuantity, blendedInstrumentPositionPrice, blendedInstrumentPositionStopLossPrice), 2);
                    if (blendedInstrumentHasStopLoss) riskInfoBlendedTicks = (int)Math.Round(((riskInfoBlendedDollars / blendedInstrumentPositionQuantity) / RealInstrumentService.GetTickValue(blendedInstrument)), MidpointRounding.ToEven);
                    riskInfoTotalDollars += riskInfoBlendedDollars;
                }

                if ((attachedInstrumentHasPosition && riskInfoHasChanged) || (blendedInstrumentHasPosition && riskInfoHasChanged))
                {
                    string riskDollarText = "";
                    string riskFullText = "";

                    if (riskInfoTotalDollars >= 0)
                    {
                        riskInfoLabel.Foreground = Brushes.LightGreen;
                        riskDollarText = "$" + riskInfoTotalDollars.ToString("N2");
                    }
                    else
                    {
                        riskInfoLabel.Foreground = Brushes.Tomato;
                        riskDollarText = "-$" + riskInfoTotalDollars.ToString("N2").Replace("-", "");

                    }

                    if (attachedInstrumentHasPosition
                        && attachedInstrumentHasStopLoss
                        && riskInfoAttachedTicks != 0
                        && blendedInstrumentHasPosition
                        && blendedInstrumentHasStopLoss
                        && riskInfoBlendedTicks != 0)
                    {
                        int riskInfoMaxTicks = (int)Math.Max(riskInfoAttachedTicks, riskInfoBlendedTicks);
                        riskFullText = " StopLoss: " + riskDollarText + " (" + riskInfoMaxTicks.ToString("N0") + ") ";
                    }
                    else if (attachedInstrumentHasPosition
                        && attachedInstrumentHasStopLoss
                        && riskInfoAttachedTicks != 0
                        && !blendedInstrumentHasPosition
                        && !blendedInstrumentHasStopLoss
                        && riskInfoBlendedTicks == 0)
                    {
                        riskFullText = " StopLoss: " + riskDollarText + " (" + riskInfoAttachedTicks.ToString("N0") + ") ";
                    }
                    else if (!attachedInstrumentHasPosition
                        && !attachedInstrumentHasStopLoss
                        && riskInfoAttachedTicks == 0
                        && blendedInstrumentHasPosition
                        && blendedInstrumentHasStopLoss
                        && riskInfoBlendedTicks != 0)
                    {
                        riskFullText = " StopLoss: " + riskDollarText + " (" + riskInfoBlendedTicks.ToString("N0") + ") ";
                    }
                    else
                    {
                        riskInfoLabel.Foreground = Brushes.White;
                        riskFullText = " StopLoss: " + "none ";
                    }

                    riskInfoLabel.Content = riskFullText;
                }
                else
                {
                    riskInfoLabel.Foreground = Brushes.White;
                    riskInfoLabel.Content = "";
                }

                riskInfoHasChanged = false;
            }
        }

        private void OnButtonClick(object sender, RoutedEventArgs re)
        {
            lock (ThreadManagerLock)
            {
                System.Windows.Controls.Button button = sender as System.Windows.Controls.Button;

                if (button == revButton && button.Name == HHRevButtonName)
                {
                    RealLogger.PrintOutput("Reverse button clicked");
                    string signalName = "ReverseButton";

                    /*
                    string messageTitle = CloseAlertMessageTitle;
                    
                    ExitCloseAlertWindows();

                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                    {
                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), "test", messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, true);

                        if (result == MessageBoxResult.Yes)
                        {
                            RealLogger.PrintOutput("AutoClose close alert prompt accepted ");

                            
                        }
                        else
                        {
                            RealLogger.PrintOutput("AutoClose close alert prompt declined ");
                        }
                    }));
                    
                    */

                    //CreatePositionStopLoss(signalName, attachedInstrument, OrderAction.Sell, OrderEntry.Manual, 1, 3824);

                    bool positionFound = HandleReverse(signalName);

                    if (!positionFound)
                    {
                        if (IsBlendedInstrumentEnabled())
                        {
                            RealLogger.PrintOutput("Reverse Error: No position found for " + attachedInstrument.FullName.ToString() + " or " + blendedInstrument.FullName.ToString());
                        }
                        else
                        {
                            RealLogger.PrintOutput("Reverse Error: No position found for " + attachedInstrument.FullName.ToString());
                        }
                    }
                }
                else if (button == closeAllButton && button.Name == HHCloseAllButtonName)
                {
                    RealLogger.PrintOutput("Close button clicked");
                    string signalName = "FlattenEverythingButton";

                    Instrument limitToSingleInstrument = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? null : attachedInstrument;
                    Instrument secondaryInstrument = null;

                    if (IsBlendedInstrumentEnabled())
                    {
                        if (limitToSingleInstrument != null)
                        {
                            secondaryInstrument = blendedInstrument;
                        }
                        else
                        {
                            limitToSingleInstrument = blendedInstrument;
                        }
                    }

                    bool positionFound = FlattenEverything(signalName, true, limitToSingleInstrument, secondaryInstrument);

                    if (!positionFound)
                    {
                        RealLogger.PrintOutput("Close Error: No position found for " + attachedInstrument.FullName.ToString());
                    }
                }
                else if (button == toggleAutoCloseButton && button.Name == HHToggleAutoCloseButtonName)
                {
                    RealLogger.PrintOutput("Auto Close button clicked");

                    if (IsCtrlKeyDown())
                    {
                        DisableAutoCloseButton(0);
                    }
                    else if (IsShiftKeyDown())
                    {
                        if (closeAutoMinProfitFlag)
                        {
                            closeAutoMinProfitFlag = false;
                        }
                        else
                        {
                            closeAutoMinProfitFlag = true;
                        }

                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        SetAutoCloseButton(button, buttonText, buttonToolTip,
                            lastToggleEntryCloseAutoStatus, 0, Brushes.DimGray);
                    }
                    else
                    {
                        string buttonContent = button.Content.ToString();


                        if (lastToggleEntryCloseAutoStatus != TickHunterCloseAutoTypes.Disabled
                            && currentCloseAutoStatus != TickHunterCloseAutoTypes.Disabled
                            && nextCloseAutoStatus == TickHunterCloseAutoTypes.Disabled)
                        {
                            currentCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;
                            DisableAutoCloseButton(0);
                        }
                        else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.Disabled)
                        {
                            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.ZombieFlip;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoCloseButton(button, buttonText, buttonToolTip,
                                lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.ZombieFlip)
                        {
                            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.ZLineDualFlip;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoCloseButton(button, buttonText, buttonToolTip,
                                lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.ZLineDualFlip)
                        {
                            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.KLineDualFlip;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoCloseButton(button, buttonText, buttonToolTip,
                                lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.KLineDualFlip)
                        {
                            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.KZFlip;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoCloseButton(button, buttonText, buttonToolTip,
                                lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.KZFlip)
                        {
                            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.CreeperFlip;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoCloseButton(button, buttonText, buttonToolTip,
                                lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.CreeperFlip)
                        {
                            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.ZombieStackedFlip;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoCloseButton(button, buttonText, buttonToolTip,
                                lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.ZombieStackedFlip)
                        {
                            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.ZombieBoostedFlip;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoCloseButton(button, buttonText, buttonToolTip,
                                lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.ZombieBoostedFlip)
                        {
                            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.MovingAverage1Slope;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoCloseButton(button, buttonText, buttonToolTip,
                                lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage1Slope)
                        {
                            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.MovingAverage2Slope;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoCloseButton(button, buttonText, buttonToolTip,
                                lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage2Slope)
                        {
                            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.MovingAverage3Slope;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoCloseButton(button, buttonText, buttonToolTip,
                                lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage3Slope)
                        {
                            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.MovingAverage4Break;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoCloseButton(button, buttonText, buttonToolTip,
                                lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage4Break)
                        {
                            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.DriftLine4Break;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoCloseButton(button, buttonText, buttonToolTip,
                                lastToggleEntryCloseAutoStatus, CloseAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else
                        {
                            DisableAutoCloseButton(CloseAutoColorDelaySeconds);
                        }
                    }
                }
                else if (button == toggleEntryVolumeAutoButton && button.Name == HHToggleEntryVolumeAutoButtonName)
                {
                    RealLogger.PrintOutput("Volume button clicked");

                    if (IsCtrlKeyDown() || !IsTickHunterActivated())
                    {
                        //if (IsCtrlKeyDown())
                        {
                            string signalName = "Volume Button";

                            if (!IsTickHunterActivated())
                            {
                                ActivateTickHunter(signalName);
                            }
                            else
                            {
                                DeactivateTickHunter(signalName);
                            }
                        }
                    }
                    else
                    {
                        if (lastToggleEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option1)
                        {
                            lastToggleEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option2;
                            button.Content = ToggleAutoEntryVolOption2ButtonEnabledText;
                            button.ToolTip = ToggleAutoEntryVolOption2ButtonEnabledToolTip;
                            currentEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option2;
                            nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option2;
                            lastEntryVolumeAutoChangeTime = GetDateTimeNow();
                        }
                        else if (lastToggleEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option2)
                        {
                            lastToggleEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option3;
                            button.Content = ToggleAutoEntryVolOption3ButtonEnabledText;
                            button.ToolTip = ToggleAutoEntryVolOption3ButtonEnabledToolTip;
                            currentEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option3;
                            nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option3;
                            lastEntryVolumeAutoChangeTime = GetDateTimeNow();
                        }
                        else if (lastToggleEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option3)
                        {
                            lastToggleEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option4;
                            button.Content = ToggleAutoEntryVolOption4ButtonEnabledText;
                            button.ToolTip = ToggleAutoEntryVolOption4ButtonEnabledToolTip;
                            currentEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option4;
                            nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option4;
                            lastEntryVolumeAutoChangeTime = GetDateTimeNow();
                        }
                        else if (lastToggleEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option4)
                        {
                            lastToggleEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option5;
                            button.Content = ToggleAutoEntryVolOption5ButtonEnabledText;
                            button.ToolTip = ToggleAutoEntryVolOption5ButtonEnabledToolTip;
                            currentEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option5;
                            nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option5;
                            lastEntryVolumeAutoChangeTime = GetDateTimeNow();
                        }
                        else
                        {
                            lastToggleEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;
                            button.Content = ToggleAutoEntryVolOption1ButtonEnabledText;
                            button.ToolTip = ToggleAutoEntryVolOption1ButtonEnabledToolTip;
                            currentEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;
                            nextEntryVolumeAutoStatus = TickHunterEntryVolumeAutoTypes.Option1;
                            lastEntryVolumeAutoChangeTime = GetDateTimeNow();
                        }
                    }

                }
                else if (button == toggleEntryVolumeMaxButton && button.Name == HHToggleEntryVolumeMaxButtonName)
                {
                    RealLogger.PrintOutput("Volume max button clicked");

                    if (IsCtrlKeyDown())
                    {
                        lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                        button.Content = ToggleEntryVolMaxOption1ButtonEnabledText;
                        button.ToolTip = ToggleEntryVolMaxOption1ButtonEnabledToolTip;
                        currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                        nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                        lastEntryVolumeMaxChangeTime = GetDateTimeNow();
                    }
                    else
                    {
                        if (lastToggleEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option1)
                        {
                            lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option2;
                            button.Content = ToggleEntryVolMaxOption2ButtonEnabledText;
                            button.ToolTip = ToggleEntryVolMaxOption2ButtonEnabledToolTip;
                            currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option2;
                            nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option2;
                            lastEntryVolumeMaxChangeTime = GetDateTimeNow();
                        }
                        else if (lastToggleEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option2)
                        {
                            lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option3;
                            button.Content = ToggleEntryVolMaxOption3ButtonEnabledText;
                            button.ToolTip = ToggleEntryVolMaxOption3ButtonEnabledToolTip;
                            currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option3;
                            nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option3;
                            lastEntryVolumeMaxChangeTime = GetDateTimeNow();
                        }
                        else if (lastToggleEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option3)
                        {
                            lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option4;
                            button.Content = ToggleEntryVolMaxOption4ButtonEnabledText;
                            button.ToolTip = ToggleEntryVolMaxOption4ButtonEnabledToolTip;
                            currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option4;
                            nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option4;
                            lastEntryVolumeMaxChangeTime = GetDateTimeNow();
                        }
                        else if (lastToggleEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option4)
                        {
                            lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option5;
                            button.Content = ToggleEntryVolMaxOption5ButtonEnabledText;
                            button.ToolTip = ToggleEntryVolMaxOption5ButtonEnabledToolTip;
                            currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option5;
                            nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option5;
                            lastEntryVolumeMaxChangeTime = GetDateTimeNow();
                        }
                        else
                        {
                            lastToggleEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                            button.Content = ToggleEntryVolMaxOption1ButtonEnabledText;
                            button.ToolTip = ToggleEntryVolMaxOption1ButtonEnabledToolTip;
                            currentEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                            nextEntryVolumeMaxStatus = TickHunterEntryVolumeMaxTypes.Option1;
                            lastEntryVolumeMaxChangeTime = GetDateTimeNow();
                        }
                    }
                }
                else if (button == toggleAutoPilotProfileButton && button.Name == HHToggleAutoPilotProfileButtonName)
                {
                    RealLogger.PrintOutput("AutoPilot Profile button clicked");

                    if (IsCtrlKeyDown())
                    {
                        DisableAutoPilotProfileButton(0);
                    }
                    else if (IsShiftKeyDown())
                    {
                        if (autoPilotProfileAutoAdjustFlag)
                        {
                            autoPilotProfileAutoAdjustFlag = false;
                        }
                        else
                        {
                            autoPilotProfileAutoAdjustFlag = false; //not supported at this time
                        }

                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoPilotProfileButtonText(lastToggleAutoPilotProfileStatus, out buttonText, out buttonToolTip);

                        SetAutoPilotProfileButton(button, buttonText, buttonToolTip,
                            lastToggleAutoPilotProfileStatus, 0, Brushes.DimGray);
                    }
                    else
                    {
                        string buttonContent = button.Content.ToString();

                        /*if (lastToggleAutoPilotProfileStatus != TickHunterAutoPilotProfileTypes.Disabled
                            && currentAutoPilotProfileStatus != TickHunterAutoPilotProfileTypes.Disabled
                            && nextAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Disabled)
                        {
                            currentAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Disabled;
                            DisableAutoPilotProfileButton(0);
                        }
                        else*/
                        if (lastToggleAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Disabled)
                        {
                            lastToggleAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Peppy;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoPilotProfileButtonText(lastToggleAutoPilotProfileStatus, out buttonText, out buttonToolTip);

                            SetAutoPilotProfileButton(button, buttonText, buttonToolTip,
                                lastToggleAutoPilotProfileStatus, AutoPilotProfileColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Peppy)
                        {
                            lastToggleAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Sleepy;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoPilotProfileButtonText(lastToggleAutoPilotProfileStatus, out buttonText, out buttonToolTip);

                            SetAutoPilotProfileButton(button, buttonText, buttonToolTip,
                                lastToggleAutoPilotProfileStatus, AutoPilotProfileColorDelaySeconds, Brushes.DimGray);
                        }
                        else
                        {
                            DisableAutoPilotProfileButton(AutoPilotProfileColorDelaySeconds);
                        }
                    }
                }
                else if (button == toggleAutoPilotButton && button.Name == HHToggleAutoPilotButtonName)
                {
                    RealLogger.PrintOutput("AutoPilot button clicked");

                    if (IsCtrlKeyDown())
                    {
                        if (UseAutoPilotLite) { DisableAutoPilotLiteButton(0); } else { DisableAutoPilotButton(0); }
                    }
                    else if (IsShiftKeyDown())
                    {
                        if (useAutoPilotAddOnFlag)
                        {
                            useAutoPilotAddOnFlag = false;
                        }
                        else
                        {
                            useAutoPilotAddOnFlag = true;
                        }

                        if (UseAutoPilotLite)
                        {
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                            SetAutoPilotLiteButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotLiteStatus, 0, Brushes.DimGray);
                        }
                        else
                        {
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                            SetAutoPilotButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotStatus, 0, Brushes.DimGray);
                        }
                    }
                    else
                    {
                        if (UseAutoPilotLite)
                        {
                            string buttonContent = button.Content.ToString();

                            if (lastToggleEntryAutoPilotLiteStatus != TickHunterAutoPilotLiteTypes.Disabled
                                && currentAutoPilotLiteStatus != TickHunterAutoPilotLiteTypes.Disabled
                                && nextAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.Disabled)
                            {
                                lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
                                currentAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
                                DisableAutoPilotLiteButton(0);
                            }
                            else if (lastToggleEntryAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.Disabled)
                            {
                                lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.AlertSetup;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotLiteButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotLiteStatus, AutoPilotLiteColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup)
                            {
                                lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.NextSetup;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotLiteButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotLiteStatus, AutoPilotLiteColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup)
                            {
                                lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.NextFilteredSetup;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotLiteButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotLiteStatus, AutoPilotLiteColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup)
                            {
                                lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.BuySetup;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotLiteButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotLiteStatus, AutoPilotLiteColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup)
                            {
                                lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.SellSetup;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotLiteButtonText(lastToggleEntryAutoPilotLiteStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotLiteButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotLiteStatus, AutoPilotLiteColorDelaySeconds, Brushes.DimGray);
                            }
                            else
                            {
                                lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
                                DisableAutoPilotLiteButton(AutoPilotLiteColorDelaySeconds);
                            }
                        }
                        else
                        {
                            string buttonContent = button.Content.ToString();

                            if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.Disabled)
                            {
                                lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount1;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount1)
                            {
                                lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount2;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount2)
                            {
                                lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount3;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount3)
                            {
                                lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount4;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount4)
                            {
                                lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount5;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount5)
                            {
                                lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount6;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount6)
                            {
                                lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount7;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount7)
                            {
                                lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount8;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount8)
                            {
                                lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount9;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotButton(button, buttonText, buttonToolTip,
                                   lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                            }
                            else if (lastToggleEntryAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount9)
                            {
                                lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount10;
                                string buttonText = "";
                                string buttonToolTip = "";
                                GetAutoPilotButtonText(lastToggleEntryAutoPilotStatus, out buttonText, out buttonToolTip);

                                SetAutoPilotButton(button, buttonText, buttonToolTip,
                                    lastToggleEntryAutoPilotStatus, AutoPilotColorDelaySeconds, Brushes.DimGray);
                            }
                            else
                            {
                                lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
                                DisableAutoPilotButton(AutoPilotColorDelaySeconds);
                            }
                        }
                    }
                }
                else if (button == toggleTradeSignalButton && button.Name == HHToggleTradeSignalButtonName)
                {
                    RealLogger.PrintOutput("Trade Signal button clicked");

                    if (IsCtrlKeyDown())
                    {
                        DisableTradeSignalButton(0);
                    }
                    else
                    {
                        string buttonContent = button.Content.ToString();

                        if (currentTradeSignalStatus != TickHunterTradeSignalTypes.Disabled && nextTradeSignalStatus == TickHunterTradeSignalTypes.Disabled)
                        {
                            currentTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
                            DisableTradeSignalButton(0);
                        }
                        else if (buttonContent == ToggleTradeSignalButtonDisabledText)
                        {
                            SetTradeSignalButton(toggleTradeSignalButton, ToggleTradeSignalBSAButtonEnabledText, ToggleTradeSignalBSAButtonEnabledTextToolTip,
                                TickHunterTradeSignalTypes.BuySellAll, TradeSignalColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (buttonContent == ToggleTradeSignalBSAButtonEnabledText)
                        {
                            SetTradeSignalButton(toggleTradeSignalButton, ToggleTradeSignalBSFButtonEnabledText, ToggleTradeSignalBSFButtonEnabledTextToolTip,
                                TickHunterTradeSignalTypes.BuySellFiltered, TradeSignalColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (buttonContent == ToggleTradeSignalBSFButtonEnabledText)
                        {
                            SetTradeSignalButton(toggleTradeSignalButton, ToggleTradeSignalBOButtonEnabledText, ToggleTradeSignalBOButtonEnabledTextToolTip,
                                TickHunterTradeSignalTypes.BuyOnly, TradeSignalColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (buttonContent == ToggleTradeSignalBOButtonEnabledText)
                        {
                            SetTradeSignalButton(toggleTradeSignalButton, ToggleTradeSignalSOButtonEnabledText, ToggleTradeSignalSOButtonEnabledTextToolTip,
                                TickHunterTradeSignalTypes.SellOnly, TradeSignalColorDelaySeconds, Brushes.DimGray);
                        }
                        else
                        {
                            DisableTradeSignalButton(TradeSignalColorDelaySeconds);
                        }
                    }
                }
                else if (button == toggleAutoAddOnButton && button.Name == HHToggleAutoAddOnButtonName)
                {
                    RealLogger.PrintOutput("Auto AddOn button clicked");

                    if (IsCtrlKeyDown())
                    {
                        DisableAutoAddOnButton(0);
                    }
                    else
                    {
                        string buttonContent = button.Content.ToString();

                        if (currentAutoAddOnStatus != TickHunterAutoAddOnTypes.Disabled && nextAutoAddOnStatus == TickHunterAutoAddOnTypes.Disabled)
                        {
                            currentAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled;
                            DisableAutoAddOnButton(0);
                        }
                        else if (buttonContent == ToggleAutoAddOnButtonDisabledText)
                        {
                            SetAutoAddOnButton(toggleAutoAddOnButton, ToggleAutoAddOnButtonEnabledText, string.Format(ToggleAutoAddOnButtonEnabledToolTip, autoAddOnMaxDollars.ToString("N0")),
                                TickHunterAutoAddOnTypes.Enabled, AutoAddOnColorDelaySeconds, Brushes.DimGray);
                        }
                        else
                        {
                            DisableAutoAddOnButton(AutoAddOnColorDelaySeconds);
                        }
                    }
                }
                else if (button == toggleProfitTargetButton && button.Name == HHToggleProfitTargetButtonName)
                {
                    RealLogger.PrintOutput("Profit Target button clicked");

                    if (IsCtrlKeyDown())
                    {
                        DisableProfitTargetButton(0);
                    }
                    else if (IsShiftKeyDown())
                    {
                        if (bogeyTargetStartWithFullPnLFlag)
                        {
                            bogeyTargetStartWithFullPnLFlag = false;
                        }
                        else
                        {
                            bogeyTargetStartWithFullPnLFlag = true;
                        }

                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBogeyTargetTypeButtonText(lastToggleEntryBogeyTargetMultiplier, out buttonText, out buttonToolTip);

                        SetProfitTargetButton(button, buttonText, buttonToolTip,
                           TickHunterProfitTargetTypes.BogeyTarget, lastToggleEntryBogeyTargetMultiplier, 0, Brushes.DimGray);
                    }
                    else
                    {
                        if (lastToggleProfitTargetStatus == TickHunterProfitTargetTypes.Disabled)
                        {
                            lastToggleProfitTargetStatus = TickHunterProfitTargetTypes.EquityCloseAllTarget;

                            string buttonText = ToggleProfitTargetECAButtonEnabledText;
                            string buttonToolTip = ToggleProfitTargetECAButtonEnabledToolTip;

                            SetProfitTargetButton(button, buttonText, buttonToolTip,
                                TickHunterProfitTargetTypes.EquityCloseAllTarget, BogeyTargetMultiplierDisabled, BogeyTargetColorDelaySeconds, Brushes.DimGray);
                        }
                        else
                        {
                            lastToggleProfitTargetStatus = TickHunterProfitTargetTypes.BogeyTarget;

                            bool hasBogeyTargetSmartJumped = AttemptBogeyTargetSmartJump();

                            if (!hasBogeyTargetSmartJumped)
                            {
                                if (lastToggleEntryBogeyTargetMultiplier >= BogeyTargetMultiplierDisabled)
                                {
                                    lastToggleEntryBogeyTargetMultiplier++;
                                    int nextMultiplier = lastToggleEntryBogeyTargetMultiplier;
                                    string buttonText = "";
                                    string buttonToolTip = "";
                                    GetBogeyTargetTypeButtonText(nextMultiplier, out buttonText, out buttonToolTip);

                                    SetProfitTargetButton(button, buttonText, buttonToolTip,
                                       TickHunterProfitTargetTypes.BogeyTarget, nextMultiplier, BogeyTargetColorDelaySeconds, Brushes.DimGray);
                                }
                                else
                                {
                                    DisableProfitTargetButton(BogeyTargetColorDelaySeconds);
                                }
                            }
                        }
                    }
                }
                else if (button == toggleAutoBEButton && button.Name == HHToggleAutoBEButtonName)
                {
                    RealLogger.PrintOutput("Auto Break-Even button clicked");

                    if (IsCtrlKeyDown())
                    {
                        DisableAutoBEButton(0);
                    }
                    else if (IsShiftKeyDown())
                    {

                        if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                        {
                            breakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.TrailNowBeforeBE;
                        }
                        else if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.TrailNowBeforeBE)
                        {
                            breakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit;
                        }
                        else
                        {
                            breakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.Disabled;
                        }

                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        SetAutoBEButton(button, buttonText, buttonToolTip,
                            lastToggleEntryBreakEvenAutoStatus, 0, Brushes.DimGray);
                    }
                    else
                    {
                        string buttonContent = button.Content.ToString();

                        if (lastToggleEntryBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled
                            && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled
                            && nextBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.Disabled)
                        {
                            currentBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;
                            DisableAutoBEButton(0);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.Disabled)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.HODL;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.HODL)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Enabled;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.Enabled)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailMix;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMix)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailZipLineDual;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLineDual)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailKLineDual;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKLineDual)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailKZ;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKZ)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailDriftMonster;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftMonster)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailMonster;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMonster)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrail5Bar;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail5Bar)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrail3Bar;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail3Bar)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrail2Bar;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail2Bar)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrail1Bar;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail1Bar)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailRushLine;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailStingRay;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailStingRay)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailRiver5;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailRiver1;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailCreek5;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek5)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailCreek1;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek1)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailZipLine2;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLine2)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else if (lastToggleEntryBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
                        {
                            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.CreeperFlipTrail;
                            string buttonText = "";
                            string buttonToolTip = "";
                            GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                            SetAutoBEButton(button, buttonText, buttonToolTip,
                                lastToggleEntryBreakEvenAutoStatus, BeakEvenAutoColorDelaySeconds, Brushes.DimGray);
                        }
                        else
                        {
                            DisableAutoBEButton(BeakEvenAutoColorDelaySeconds);
                        }
                    }
                }
                else if (button == TPButton && button.Name == HHTPButtonName)
                {
                    RealLogger.PrintOutput("TP+ button clicked");
                    string signalName = "TP+ Button";

                    bool positionFound = HandleTakeProfitPlus(signalName);

                    if (!positionFound)
                    {
                        RealLogger.PrintOutput("TP+ Error: No position found for " + attachedInstrument.FullName.ToString());
                    }
                }
                else if (button == BEButton && button.Name == HHBEButtonName)
                {
                    RealLogger.PrintOutput("BE+ button clicked");
                    string signalName = "BE+ Button";

                    bool positionFound = HandleBreakEvenPlus(signalName);

                    if (!positionFound)
                    {
                        RealLogger.PrintOutput("BE+ Error: No position found for " + attachedInstrument.FullName.ToString());
                    }

                }
                else if (button == SLButton && button.Name == HHSLButtonName)
                {
                    RealLogger.PrintOutput("SL+ button clicked");
                    string signalName = "SL+ Button";

                    bool positionFound = HandleStopLossPlus(signalName);

                    if (!positionFound)
                    {
                        RealLogger.PrintOutput("SL+ Error: No position found for " + attachedInstrument.FullName.ToString());
                    }

                }
                else if (button == BuyMarketButton && button.Name == HHBuyMarketButtonName)
                {
                    RealLogger.PrintOutput("Buy Market button clicked");
                    string signalName = "Buy Market Button";

                    HandleBuyMarket(signalName);

                }
                else if (button == SellMarketButton && button.Name == HHSellMarketButtonName)
                {
                    RealLogger.PrintOutput("Sell Market button clicked");
                    string signalName = "Sell Market Button";

                    HandleSellMarket(signalName);

                }
                else if (button == BuyPopButton && button.Name == HHBuyPopButtonName)
                {
                    RealLogger.PrintOutput("Buy Pop button clicked (LimitToPullback=" + popLimitToPullbackFlag.ToString().ToLower() + ")");
                    string signalName = "Pop+ Button";

                    bool isCTRLKeyDown = IsCtrlKeyDown();

                    bool popDelayedEntry = (popCTRLDelayedEntryFlag && isCTRLKeyDown) || (!popCTRLDelayedEntryFlag && !isCTRLKeyDown);

                    if (IsShiftKeyDown())
                    {
                        if (popLimitToPullbackFlag)
                        {
                            popLimitToPullbackFlag = false;
                        }
                        else
                        {
                            popLimitToPullbackFlag = true;
                        }

                        string buttonText = "";
                        string buttonToolTip = "";

                        GetPopButtonText(TickHunterPopTypes.PopPlus, currentBuyPopDelayedStatus, out buttonText, out buttonToolTip);

                        Brush buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.Blue : Brushes.DimGray;

                        if (useBuyPopActivateFlag)
                        {
                            buttonBGColor = Brushes.HotPink;
                        }

                        SetBuyPopButton(button, buttonText, buttonToolTip, currentBuyPopDelayedStatus, 0, buttonBGColor);

                        GetPopButtonText(TickHunterPopTypes.PopMinus, currentSellPopDelayedStatus, out buttonText, out buttonToolTip);

                        SetSellPopButton(SellPopButton, buttonText, buttonToolTip, currentSellPopDelayedStatus, 0, SellPopButton.Background);
                    }
                    else if (popDelayedEntry)
                    {
                        bool cancelledSellPop = HandleBuyPop(signalName, true);

                        if (useSellPopActivateFlag)
                        {
                            DeactivateSellPopButton(signalName);
                        }
                        /*
                        if (useBuyPopActivateFlag)
                        {
                            IncrementBuyPopDelayedTradeCount();

                            if (lastToggleBuyPopDelayedStatus == TickHunterPopDelayedTypes.Disabled)
                                DeactivateBuyPopButton(signalName);
                        }
                        else
                        */
                        if (!cancelledSellPop)
                        {
                            ActivateBuyPopButton(signalName);
                        }
                    }
                    else
                    {
                        if (useBuyPopActivateFlag || useSellPopActivateFlag)
                        {
                            //HandleBuyPop(signalName, true);

                            DeactivatePopDelayedEntryFeatures(signalName);
                        }
                        else
                        {
                            bool positionFound = HandleBuyPop(signalName);
                        }
                    }




                    /*
                    if (positionFound)
                    {
                        RealLogger.PrintOutput("SNAP+ Error: Not supported position found for " + attachedInstrument.FullName.ToString());
                    }
                    */

                }
                else if (button == SellPopButton && button.Name == HHSellPopButtonName)
                {
                    RealLogger.PrintOutput("Sell Pop button clicked (LimitToPullback=" + popLimitToPullbackFlag.ToString().ToLower() + ")");
                    string signalName = "Pop- Button";

                    bool isCTRLKeyDown = IsCtrlKeyDown();

                    bool popDelayedEntry = (popCTRLDelayedEntryFlag && isCTRLKeyDown) || (!popCTRLDelayedEntryFlag && !isCTRLKeyDown);

                    if (IsShiftKeyDown())
                    {
                        if (popLimitToPullbackFlag)
                        {
                            popLimitToPullbackFlag = false;
                        }
                        else
                        {
                            popLimitToPullbackFlag = true;
                        }

                        string buttonText = "";
                        string buttonToolTip = "";
                        GetPopButtonText(TickHunterPopTypes.PopMinus, currentSellPopDelayedStatus, out buttonText, out buttonToolTip);

                        Brush buttonBGColor = (popCTRLDelayedEntryFlag) ? Brushes.OrangeRed : Brushes.DimGray;

                        if (useSellPopActivateFlag)
                        {
                            buttonBGColor = Brushes.HotPink;
                        }

                        SetSellPopButton(button, buttonText, buttonToolTip, currentSellPopDelayedStatus, 0, buttonBGColor);

                        GetPopButtonText(TickHunterPopTypes.PopPlus, currentBuyPopDelayedStatus, out buttonText, out buttonToolTip);

                        SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, currentBuyPopDelayedStatus, 0, BuyPopButton.Background);
                    }
                    else if (popDelayedEntry)
                    {
                        bool cancelledBuyPop = HandleSellPop(signalName, true);

                        if (useBuyPopActivateFlag)
                        {
                            DeactivateBuyPopButton(signalName);
                        }

                        /*
                        if (useSellPopActivateFlag)
                        {
                            IncrementSellPopDelayedTradeCount();

                            if (lastToggleSellPopDelayedStatus == TickHunterPopDelayedTypes.Disabled)
                                DeactivateSellPopButton(signalName);
                        }
                        else
                        */

                        if (!cancelledBuyPop)
                        {
                            ActivateSellPopButton(signalName);
                        }
                    }
                    else
                    {
                        if (useBuyPopActivateFlag || useSellPopActivateFlag)
                        {
                            //HandleSellPop(signalName, true);

                            DeactivatePopDelayedEntryFeatures(signalName);
                        }
                        else
                        {
                            bool positionFound = HandleSellPop(signalName);
                        }
                    }

                    /*
                    if (positionFound)
                    {
                        RealLogger.PrintOutput("SNAP- Error: Not supported when position found for " + attachedInstrument.FullName.ToString());
                    }
                    */

                }
                else if (button == BuyDropButton && button.Name == HHBuyDropButtonName)
                {
                    RealLogger.PrintOutput("Buy Drop button clicked (LimitToPullback=" + popLimitToPullbackFlag.ToString().ToLower() + ")");
                    string signalName = "Drop+ Button";

                    bool positionFound = HandleBuyDrop(signalName);

                    /*
                    if (positionFound)
                    {
                        RealLogger.PrintOutput("SNAP+ Error: Not supported position found for " + attachedInstrument.FullName.ToString());
                    }
                    */

                }
                else if (button == SellDropButton && button.Name == HHSellDropButtonName)
                {
                    RealLogger.PrintOutput("Sell Drop button clicked");
                    string signalName = "Drop- Button";

                    bool positionFound = HandleSellDrop(signalName);

                    /*
                    if (positionFound)
                    {
                        RealLogger.PrintOutput("SNAP- Error: Not supported when position found for " + attachedInstrument.FullName.ToString());
                    }
                    */

                }
            }
        }

        string previousVolumeButtonText = "";
        string previousVolumeButtonToolTipText = "";

        private void ActivateTickHunter(string signalName)
        {
            isTickHunterActivated = true;
            SetButtonPanelVisiblity();
            if (toggleEntryVolumeAutoButton != null && ShowButtonVolume)
            {
                toggleEntryVolumeAutoButton.Content = previousVolumeButtonText;
                toggleEntryVolumeAutoButton.ToolTip = previousVolumeButtonToolTipText;
            }

            RealLogger.PrintOutput("Activated " + FullSystemName + " on " + this.attachedInstrument.FullName + " (" + BarsPeriod + ") via " + signalName, PrintTo.OutputTab1);
            RealLogger.PrintOutput("Activated " + FullSystemName + " on " + this.attachedInstrument.FullName + " (" + BarsPeriod + ") via " + signalName, PrintTo.OutputTab2);
        }

        private void DeactivateTickHunter(string signalName)
        {
            isTickHunterActivated = false;
            activeDayOverMaxLossAutoClose = false;
            SetButtonPanelHidden();
            if (toggleEntryVolumeAutoButton != null && ShowButtonVolume)
            {
                toggleEntryVolumeAutoButton.Visibility = Visibility.Visible;
                previousVolumeButtonText = (string)toggleEntryVolumeAutoButton.Content;
                previousVolumeButtonToolTipText = (string)toggleEntryVolumeAutoButton.ToolTip;

                toggleEntryVolumeAutoButton.Content = "Start";
                toggleEntryVolumeAutoButton.ToolTip = "Click to Activate " + SystemName;
            }

            RealLogger.PrintOutput("Deactivated " + FullSystemName + " on " + this.attachedInstrument.FullName + " (" + BarsPeriod + ") via " + signalName, PrintTo.OutputTab1);
            RealLogger.PrintOutput("Deactivated " + FullSystemName + " on " + this.attachedInstrument.FullName + " (" + BarsPeriod + ") via " + signalName, PrintTo.OutputTab2);
        }

        private void ActivateBuyPopButton(string signalName)
        {
            bool passedMaxCountCheck = ((int)lastToggleBuyPopDelayedStatus < popDelayedEntryMaxCountFlag);

            if (passedMaxCountCheck)
            {
                string buttonText = "";
                string buttonToolTip = "";

                if (lastToggleBuyPopDelayedStatus == TickHunterPopDelayedTypes.Disabled)
                {
                    PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();
                    useBuyPopActivateFlag = true;

                    lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount1;

                    GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else if (lastToggleBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount1)
                {
                    lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount2;

                    GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else if (lastToggleBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount2)
                {
                    lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount3;

                    GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else if (lastToggleBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount3)
                {
                    lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount4;

                    GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else
                {
                    lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount5;

                    GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);
                }

                SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, lastToggleBuyPopDelayedStatus, PopActivateColorDelaySeconds, Brushes.HotPink);

                currentBuyPopDelayedStatus = lastToggleBuyPopDelayedStatus;
                lastBuyPopDelayedChangeTime = GetDateTimeNow(); // no delay

                RealLogger.PrintOutput("Activated pop+ buy stop delayed entry (EntryQueueLength=" + (int)currentBuyPopDelayedStatus + " / LimitToPullback=" + popLimitToPullbackFlag.ToString().ToLower() + ")  via " + signalName);
            }
            else
            {
                RealLogger.PrintOutput("BLOCKED pop+ buy stop delayed entry increment due to CurrentPopDelayedEntryCount=" + ((int)lastToggleBuyPopDelayedStatus).ToString("N0") + " while PopDelayedEntryMaxCount=" + popDelayedEntryMaxCountFlag.ToString("N0") + " via " + signalName);
            }
        }

        private void ActivateSellPopButton(string signalName)
        {
            bool passedMaxCountCheck = ((int)lastToggleSellPopDelayedStatus < popDelayedEntryMaxCountFlag);

            if (passedMaxCountCheck)
            {
                string buttonText = "";
                string buttonToolTip = "";

                if (lastToggleSellPopDelayedStatus == TickHunterPopDelayedTypes.Disabled)
                {
                    PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();
                    useSellPopActivateFlag = true;

                    lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount1;

                    GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else if (lastToggleSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount1)
                {
                    lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount2;

                    GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else if (lastToggleSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount2)
                {
                    lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount3;

                    GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else if (lastToggleSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount3)
                {
                    lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount4;

                    GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);
                }
                else
                {
                    lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount5;

                    GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);
                }

                SetSellPopButton(SellPopButton, buttonText, buttonToolTip, lastToggleSellPopDelayedStatus, PopActivateColorDelaySeconds, Brushes.HotPink);

                currentSellPopDelayedStatus = lastToggleSellPopDelayedStatus;
                lastSellPopDelayedChangeTime = GetDateTimeNow(); // no delay

                RealLogger.PrintOutput("Activated pop- sell stop delayed entry (EntryQueueLength=" + (int)currentSellPopDelayedStatus + " / LimitToPullback=" + popLimitToPullbackFlag.ToString().ToLower() + ")");
            }
            else
            {
                RealLogger.PrintOutput("BLOCKED pop- sell stop delayed entry increment due to CurrentPopDelayedEntryCount=" + ((int)lastToggleSellPopDelayedStatus).ToString("N0") + " while PopDelayedEntryMaxCount=" + popDelayedEntryMaxCountFlag.ToString("N0") + " via " + signalName);
            }
        }

        private void DeactivateBuyPopButton(string signalName)
        {
            RealLogger.PrintOutput("Deactivated pop+ buy stop delayed entry via " + signalName);

            useBuyPopActivateFlag = false;

            if (BuyPopButton != null)
            {
                string buttonText = "";
                string buttonToolTip = "";

                lastToggleBuyPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;

                GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);

                Brush popBgColor = (popCTRLDelayedEntryFlag) ? Brushes.Blue : Brushes.DimGray;
                SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, lastToggleBuyPopDelayedStatus, 0, popBgColor);

                currentBuyPopDelayedStatus = lastToggleBuyPopDelayedStatus;
                lastBuyPopDelayedChangeTime = GetDateTimeNow(); // no delay
            }
        }

        private void DeactivateSellPopButton(string signalName)
        {
            RealLogger.PrintOutput("Deactivated pop- sell stop delayed entry via " + signalName);
            useSellPopActivateFlag = false;

            if (SellPopButton != null)
            {
                string buttonText = "";
                string buttonToolTip = "";

                lastToggleSellPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;

                GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);

                Brush popBgColor = (popCTRLDelayedEntryFlag) ? Brushes.OrangeRed : Brushes.DimGray;
                SetSellPopButton(SellPopButton, buttonText, buttonToolTip, lastToggleSellPopDelayedStatus, 0, popBgColor);

                currentSellPopDelayedStatus = lastToggleSellPopDelayedStatus;
                lastSellPopDelayedChangeTime = GetDateTimeNow(); // no delay
            }
        }

        private void DisableTradeSignalButton(int delaySeconds)
        {
            lastToggleEntryTradeSignalStatus = TickHunterTradeSignalTypes.Disabled;
            SetTradeSignalButton(toggleTradeSignalButton, ToggleTradeSignalButtonDisabledText, ToggleTradeSignalButtonDisabledToolTip,
                lastToggleEntryTradeSignalStatus, delaySeconds, Brushes.DimGray);
        }

        private void DisableAutoCloseButton(int delaySeconds)
        {
            lastToggleEntryCloseAutoStatus = TickHunterCloseAutoTypes.Disabled;
            SetAutoCloseButton(toggleAutoCloseButton, ToggleAutoCloseButtonDisabledText, ToggleAutoCloseButtonDisabledToolTip,
                lastToggleEntryCloseAutoStatus, delaySeconds, Brushes.DimGray);
        }

        private void DisableAutoBEButton(int delaySeconds)
        {
            lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;
            SetAutoBEButton(toggleAutoBEButton, ToggleAutoBEButtonDisabledText, ToggleAutoBEButtonDisabledToolTip,
                lastToggleEntryBreakEvenAutoStatus, delaySeconds, Brushes.DimGray);
        }

        private void DisableProfitTargetButton(int delaySeconds)
        {
            lastToggleProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;
            SetProfitTargetButton(toggleProfitTargetButton, ToggleProfitTargetButtonDisabledText, ToggleProfitTargetButtonDisabledToolTip,
                lastToggleProfitTargetStatus, BogeyTargetMultiplierDisabled, delaySeconds, Brushes.DimGray);
        }

        private void DisableAutoPilotProfileButton(int delaySeconds)
        {
            lastToggleAutoPilotProfileStatus = TickHunterAutoPilotProfileTypes.Disabled;
            SetAutoPilotProfileButton(toggleAutoPilotProfileButton, ToggleAutoPPButtonDisabledText, ToggleAutoPPButtonDisabledToolTip,
                lastToggleAutoPilotProfileStatus, delaySeconds, Brushes.DimGray);
        }

        private void DisableAutoAddOnButton(int delaySeconds)
        {
            lastToggleEntryAutoAddOnStatus = TickHunterAutoAddOnTypes.Disabled;
            SetAutoAddOnButton(toggleAutoAddOnButton, ToggleAutoAddOnButtonDisabledText, string.Format(ToggleAutoAddOnButtonDisabledToolTip, autoAddOnMaxDollars.ToString("N0")),
                lastToggleEntryAutoAddOnStatus, delaySeconds, Brushes.DimGray);
        }
        private void DisableAutoPilotButton(int delaySeconds)
        {
            lastToggleEntryAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
            SetAutoPilotButton(toggleAutoPilotButton, ToggleAutoPilotButtonDisabledText, ToggleAutoPilotButtonDisabledToolTip,
                lastToggleEntryAutoPilotStatus, delaySeconds, Brushes.DimGray);
        }

        private void DisableAutoPilotLiteButton(int delaySeconds)
        {
            lastToggleEntryAutoPilotLiteStatus = TickHunterAutoPilotLiteTypes.Disabled;
            SetAutoPilotLiteButton(toggleAutoPilotButton, ToggleAutoPilotLiteButtonDisabledText, ToggleAutoPilotLiteButtonDisabledToolTip,
                lastToggleEntryAutoPilotLiteStatus, delaySeconds, Brushes.DimGray);
        }

        private void SetAutoAddOnButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterAutoAddOnTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            button.Content = buttonText;
            button.ToolTip = buttonToolTip;
            button.Background = backgroundColor;
            nextAutoAddOnStatus = nextType;
            lastAutoAddOnChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetAutoCloseButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterCloseAutoTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            button.Content = buttonText;
            button.ToolTip = buttonToolTip;
            button.Background = backgroundColor;
            nextCloseAutoStatus = nextType;
            lastCloseAutoChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetAutoPilotLiteButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterAutoPilotLiteTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            if (button != null)
            {
                button.Content = buttonText;
                button.ToolTip = buttonToolTip;
                button.Background = backgroundColor;
            }

            nextAutoPilotLiteStatus = nextType;
            lastAutoPilotLiteChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetAutoPilotButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterAutoPilotTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            if (button != null)
            {
                button.Content = buttonText;
                button.ToolTip = buttonToolTip;
                button.Background = backgroundColor;
            }

            nextAutoPilotStatus = nextType;
            lastAutoPilotChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetTradeSignalButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterTradeSignalTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            button.Content = buttonText;
            button.ToolTip = buttonToolTip;
            button.Background = backgroundColor;
            nextTradeSignalStatus = nextType;
            lastTradeSignalChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetBuyPopButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterPopDelayedTypes nextType, int delaySeconds, Brush backgroundColor)
        {
            if (button != null)
            {
                button.Content = buttonText;
                button.ToolTip = buttonToolTip;
                button.Background = backgroundColor;
            }

            nextBuyPopDelayedStatus = nextType;
            lastBuyPopActivateChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetSellPopButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterPopDelayedTypes nextType, int delaySeconds, Brush backgroundColor)
        {
            if (button != null)
            {
                button.Content = buttonText;
                button.ToolTip = buttonToolTip;
                button.Background = backgroundColor;
            }

            nextSellPopDelayedStatus = nextType;
            lastSellPopActivateChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetProfitTargetButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterProfitTargetTypes nextType,
            int nextMultiplier, int delaySeconds, Brush backgroundColor)
        {
            button.Content = buttonText;
            button.ToolTip = buttonToolTip;
            button.Background = backgroundColor;
            nextProfitTargetStatus = nextType;
            nextBogeyTargetMultiplier = nextMultiplier;
            lastProfitTargetChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetAutoBEButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterBreakEvenAutoTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            button.Content = buttonText;
            button.ToolTip = buttonToolTip;
            button.Background = backgroundColor;
            nextBreakEvenAutoStatus = nextType;
            lastBreakEvenAutoChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private void SetAutoPilotProfileButton(System.Windows.Controls.Button button, string buttonText, string buttonToolTip, TickHunterAutoPilotProfileTypes nextType,
            int delaySeconds, Brush backgroundColor)
        {
            button.Content = buttonText;
            button.ToolTip = buttonToolTip;
            button.Background = backgroundColor;
            nextAutoPilotProfileStatus = nextType;
            lastAutoPilotProfileChangeTime = (GetDateTimeNow()).AddSeconds(delaySeconds);
        }

        private bool AttemptBogeyTargetSmartJump()
        {
            bool returnFlag = false;

            if (BogeyTargetBaseDollars > 0)
            {
                double sessionPnL = Math.Round(account.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar), 2);
                //double currentBogeyTargetMultiplier = currentBogeyTargetMultiplier; // CalculateBogeyTargetMutiplier(currentBogeyTargetStatus);
                double nextBogeyMultiplier = nextBogeyTargetMultiplier; // CalculateBogeyTargetMutiplier(nextBogeyTargetStatus);

                const double toleranceBelowPercent = 0.05;
                double tolerancePercentagetOfMaxProfitDollars = this.BogeyTargetBaseDollars * toleranceBelowPercent;
                double jumpDecimalMultiplier = (sessionPnL + tolerancePercentagetOfMaxProfitDollars) / BogeyTargetBaseDollars;
                int jumpDPMultiplier = (int)Math.Ceiling(jumpDecimalMultiplier);
                if (jumpDPMultiplier <= 0)
                    jumpDPMultiplier = 1;
                else if (jumpDPMultiplier == jumpDecimalMultiplier)
                    jumpDPMultiplier++;

                //TickHunterBogeyTargetTypes jumpBogeyTargetType = GetBogeyTargetTypeByMultiplier(jumpDPMultiplier);
                int jumpBogeyTargetMultiplier = jumpDPMultiplier;// CalculateBogeyTargetMutiplier(jumpBogeyTargetType);

                if (jumpBogeyTargetMultiplier == BogeyTargetMultiplierDisabled)
                {
                    lastToggleProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;
                    nextProfitTargetStatus = TickHunterProfitTargetTypes.Disabled;

                    lastToggleEntryBogeyTargetMultiplier = BogeyTargetMultiplierDisabled;
                    toggleProfitTargetButton.Content = ToggleProfitTargetButtonDisabledText;
                    toggleProfitTargetButton.ToolTip = ToggleProfitTargetButtonDisabledToolTip;
                    toggleProfitTargetButton.Background = Brushes.DimGray;
                    nextBogeyTargetMultiplier = BogeyTargetMultiplierDisabled;
                    lastProfitTargetChangeTime = (GetDateTimeNow()).AddSeconds(BogeyTargetColorDelaySeconds);
                    returnFlag = true;
                }
                else if (jumpBogeyTargetMultiplier > nextBogeyMultiplier)
                {
                    lastToggleProfitTargetStatus = TickHunterProfitTargetTypes.BogeyTarget;
                    nextProfitTargetStatus = TickHunterProfitTargetTypes.BogeyTarget;
                    string buttonText = "";
                    string buttonToolTipText = "";
                    GetBogeyTargetTypeButtonText(jumpBogeyTargetMultiplier, out buttonText, out buttonToolTipText);

                    lastToggleEntryBogeyTargetMultiplier = jumpBogeyTargetMultiplier;
                    toggleProfitTargetButton.Content = buttonText;
                    toggleProfitTargetButton.ToolTip = buttonToolTipText;
                    toggleProfitTargetButton.Background = Brushes.DimGray;
                    nextBogeyTargetMultiplier = jumpBogeyTargetMultiplier;
                    lastProfitTargetChangeTime = (GetDateTimeNow()).AddSeconds(BogeyTargetColorDelaySeconds);
                    returnFlag = true;
                }
            }

            return returnFlag;
        }

        private bool IsTickHunterActivated()
        {
            return isTickHunterActivated;
        }

        private void UnloadAccountEvents(string signalName)
        {
            if (account != null)
            {
                lock (AccountLock)
                {
                    if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** UnloadAccountEvents: Unsubscribing via " + signalName);
                    UnsubscribeToOrderUpdate(account);
                    UnsubscribeToExecutionUpdate(account);
                    UnsubscribeToPositionUpdate(account);

                    //if (this.DebugLogLevel > 10) RealLogger.PrintOutput("*** UnloadAccountEvents: Unsubscribing to PositionUpdate:");
                    //WeakEventManager<Account, PositionEventArgs>.RemoveHandler(account, "PositionUpdate", OnPositionUpdate);





                    //WeakEventManager<Account, AccountStatusEventArgs>.RemoveHandler(account, "AccountStatusUpdate", OnAccountStatusUpdate);
                    //WeakEventManager<Account, AccountItemEventArgs>.RemoveHandler(account, "AccountItemUpdate", OnAccountItemUpdate);


                    account = null;
                }

            }
        }


        private bool HandleReverse(string signalName)
        {
            bool positionFound = false;

            Instrument tempInstrument = null;
            int tempQuantity = 0;
            MarketPosition tempMarketPosition;
            OrderAction revOrderAction;

            RealPosition foundAttachedPosition = null;
            RealPosition foundBlendedPosition = null;

            int foundAttachedQuantity = 0;
            int foundBlendedQuantity = 0;

            OrderAction foundAttachedOrderAction = OrderAction.Buy;
            OrderAction foundBlendedOrderAction = OrderAction.Buy;

            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;

                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    bool isAttachedPosition = RealPositionService.IsValidPosition(position, attachedInstrument);
                    bool isBlendedPosition = IsBlendedInstrumentEnabled() && RealPositionService.IsValidPosition(position, blendedInstrument);

                    if (isAttachedPosition || isBlendedPosition)
                    {
                        position.StoreState();
                        positionFound = true;

                        if (isAttachedPosition)
                        {
                            foundAttachedPosition = position;
                            foundAttachedQuantity = position.Quantity;
                            foundAttachedOrderAction = ConvertMarketPositionToRevOrderAction(position.MarketPosition);
                        }
                        else if (isBlendedPosition)
                        {
                            foundBlendedPosition = position;
                            foundBlendedQuantity = position.Quantity;
                            foundBlendedOrderAction = ConvertMarketPositionToRevOrderAction(position.MarketPosition);
                        }
                    }
                }
            }

            Instrument firstInstrumentReadyToClose = null;
            Instrument secondInstrumentReadyToClose = null;

            bool hasAttachedPositionReadyToClose = foundAttachedPosition != null && !foundAttachedPosition.HasStateChanged() && !foundAttachedPosition.IsFlat();
            bool hasBlendPositionReadyToClose = foundBlendedPosition != null && !foundBlendedPosition.HasStateChanged() && !foundBlendedPosition.IsFlat();

            if (hasAttachedPositionReadyToClose && hasBlendPositionReadyToClose)
            {
                firstInstrumentReadyToClose = foundAttachedPosition.Instrument;
                secondInstrumentReadyToClose = foundBlendedPosition.Instrument;
            }
            else if (hasAttachedPositionReadyToClose && !hasBlendPositionReadyToClose)
            {
                firstInstrumentReadyToClose = foundAttachedPosition.Instrument;
            }
            else if (!hasAttachedPositionReadyToClose && hasBlendPositionReadyToClose)
            {
                firstInstrumentReadyToClose = foundBlendedPosition.Instrument;
            }

            if (firstInstrumentReadyToClose != null)
            {
                FlattenEverything(signalName, true, firstInstrumentReadyToClose, secondInstrumentReadyToClose);

                if (hasAttachedPositionReadyToClose)
                {
                    if (DebugLogLevel > 2) RealLogger.PrintOutput(signalName + " opening " + foundAttachedOrderAction.ToString().ToLower() + " " + foundAttachedPosition.Instrument.FullName + " Quantity=" + foundAttachedQuantity, PrintTo.OutputTab1);
                    SubmitMarketOrder(signalName, foundAttachedPosition.Instrument, foundAttachedOrderAction, OrderEntry.Manual, foundAttachedQuantity);
                }

                if (hasBlendPositionReadyToClose)
                {
                    if (DebugLogLevel > 2) RealLogger.PrintOutput(signalName + " opening " + foundAttachedOrderAction.ToString().ToLower() + " " + foundBlendedPosition.Instrument.FullName + " Quantity=" + foundBlendedQuantity, PrintTo.OutputTab1);
                    SubmitMarketOrder(signalName, foundBlendedPosition.Instrument, foundBlendedOrderAction, OrderEntry.Manual, foundBlendedQuantity);
                }
            }



            return positionFound;
        }

        private bool HandleBreakEvenPlus(string signalName)
        {
            double oldStopLossPrice = 0;
            int oldOrderQuantity = 0;
            double newStopLossPrice = 0;
            int tempQuantity = 0;
            bool positionFound = false;
            bool hasStopLoss = false;
            bool hasValidNewStopLossPrice = false;
            bool hasStopLossPriceMismatch = false;
            int stopLossOrderCount = 0;
            OrderType orderType = OrderType.Unknown;
            double multiPositionAveragePrice = 0;
            bool attachedHasBeenProcessed = false;
            bool blendedHasBeenProcessed = false;
            double tempAttachedInstrumentPositionStopLossPrice = 0;
            double tempBlendedInstrumentPositionStopLossPrice = 0;


            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;

                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                    {
                        position.StoreState();
                        positionFound = true;
                        tempQuantity = position.Quantity;
                        newStopLossPrice = 0;
                        stopLossOrderCount = 0;
                        multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;
                        oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);

                        hasStopLoss = (oldStopLossPrice > 0);

                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Current SL price=" + oldStopLossPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString() + " via " + signalName);
                        if (!hasStopLoss)
                        {
                            newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, multiPositionAveragePrice, position.Quantity);

                            if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionStopLossPrice > 0)
                                newStopLossPrice = tempBlendedInstrumentPositionStopLossPrice;

                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                            if (hasValidNewStopLossPrice && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);
                                    CreatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                }
                            }
                        }
                        else
                        {
                            if (position.MarketPosition == MarketPosition.Long)
                            {
                                newStopLossPrice = GetInitialBreakEvenStopLossPrice(position.MarketPosition, multiPositionAveragePrice);

                                if (newStopLossPrice > multiPositionAveragePrice && oldStopLossPrice >= newStopLossPrice)
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, GetBreakEvenJumpTicks());
                                }

                                if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionStopLossPrice > 0 && blendedHasBeenProcessed)
                                    newStopLossPrice = tempBlendedInstrumentPositionStopLossPrice;

                                double bidPrice = RealInstrumentService.GetBidPrice(position.Instrument);
                                if (newStopLossPrice > bidPrice)
                                {
                                    newStopLossPrice = 0;
                                }
                            }
                            else if (position.MarketPosition == MarketPosition.Short)
                            {
                                newStopLossPrice = GetInitialBreakEvenStopLossPrice(position.MarketPosition, multiPositionAveragePrice);

                                if (newStopLossPrice < multiPositionAveragePrice && oldStopLossPrice <= newStopLossPrice)
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, GetBreakEvenJumpTicks());
                                }

                                if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionStopLossPrice > 0 && blendedHasBeenProcessed)
                                    newStopLossPrice = tempBlendedInstrumentPositionStopLossPrice;

                                double askPrice = RealInstrumentService.GetAskPrice(position.Instrument);
                                if (newStopLossPrice < askPrice)
                                {
                                    newStopLossPrice = 0;
                                }
                            }

                            hasStopLossPriceMismatch = oldStopLossPrice > 0 && newStopLossPrice > 0 && oldStopLossPrice != newStopLossPrice;

                            if (hasStopLossPriceMismatch && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString() + " via " + signalName);
                                    UpdatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, 0, newStopLossPrice);
                                }
                            }
                        }

                        attachedHasBeenProcessed = true;
                        tempAttachedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                        //break; //only one postion per instrument so exit early
                    }
                    else if (IsBlendedInstrumentEnabled() && RealPositionService.IsValidPosition(position, blendedInstrument) && position.IsValid)
                    {
                        position.StoreState();
                        positionFound = true;
                        tempQuantity = position.Quantity;
                        newStopLossPrice = 0;
                        stopLossOrderCount = 0;
                        multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;
                        oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);

                        hasStopLoss = (oldStopLossPrice > 0);

                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Current SL price=" + oldStopLossPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString() + " via " + signalName);
                        if (!hasStopLoss)
                        {
                            newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, multiPositionAveragePrice, position.Quantity);

                            if (attachedInstrumentHasPosition && tempAttachedInstrumentPositionStopLossPrice > 0)
                                newStopLossPrice = tempAttachedInstrumentPositionStopLossPrice;

                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                            if (hasValidNewStopLossPrice && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);
                                    CreatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                }
                            }
                        }
                        else
                        {
                            newStopLossPrice = GetInitialBreakEvenStopLossPrice(position.MarketPosition, multiPositionAveragePrice);

                            if (position.MarketPosition == MarketPosition.Long)
                            {
                                if (newStopLossPrice > multiPositionAveragePrice && oldStopLossPrice >= newStopLossPrice)
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, GetBreakEvenJumpTicks());
                                }

                                if (attachedInstrumentHasPosition && tempAttachedInstrumentPositionStopLossPrice > 0 && attachedHasBeenProcessed)
                                    newStopLossPrice = tempAttachedInstrumentPositionStopLossPrice;

                                double bidPrice = RealInstrumentService.GetBidPrice(position.Instrument);
                                if (newStopLossPrice > bidPrice)
                                {
                                    newStopLossPrice = 0;
                                }
                            }
                            else if (position.MarketPosition == MarketPosition.Short)
                            {
                                if (newStopLossPrice < multiPositionAveragePrice && oldStopLossPrice <= newStopLossPrice)
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, GetBreakEvenJumpTicks());
                                }

                                double askPrice = RealInstrumentService.GetAskPrice(position.Instrument);
                                if (newStopLossPrice < askPrice)
                                {
                                    newStopLossPrice = 0;
                                }
                            }
                            RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString() + " via " + signalName);

                            hasStopLossPriceMismatch = oldStopLossPrice > 0 && newStopLossPrice > 0 && oldStopLossPrice != newStopLossPrice;

                            if (hasStopLossPriceMismatch && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString() + " via " + signalName);
                                    UpdatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, 0, newStopLossPrice);
                                }
                            }
                        }

                        blendedHasBeenProcessed = true;
                        tempBlendedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                        //break; //only one postion per instrument so exit early
                    }
                }
            }


            return positionFound;
        }

        private int GetBreakEvenJumpTicks()
        {
            int jumpTicks = this.BreakEvenJumpTicks;

            if (IsCtrlKeyDown())
            {
                jumpTicks = this.BreakEvenTurboJumpTicks;
            }

            return jumpTicks;
        }

        private bool HandleStopLossPlus(string signalName, double overrideStopLossPrice = 0)
        {
            double oldStopLossPrice = 0;
            int oldOrderQuantity = 0;
            double newStopLossPrice = 0;
            bool positionFound = false;
            bool hasStopLoss = false;
            bool hasValidNewStopLossPrice = false;
            bool hasStopLossPriceMismatch = false;
            int stopLossOrderCount = 0;
            OrderType orderType = OrderType.Unknown;
            int tempQuantity = 0;
            bool isCtrlKeyDown = IsCtrlKeyDown();
            MarketPosition positionFoundMarketPosition = MarketPosition.Flat;
            double multiPositionAveragePrice = 0;
            int positionCount = RealPositionService.PositionCount;
            bool attachedHasBeenProcessed = false;
            bool blendedHasBeenProcessed = false;
            double tempAttachedInstrumentPositionStopLossPrice = 0;
            double tempBlendedInstrumentPositionStopLossPrice = 0;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;
                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    //if (position.Instrument == attachedInstrument)
                    if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                    {
                        position.StoreState();
                        positionFound = true;
                        tempQuantity = position.Quantity;
                        newStopLossPrice = 0;
                        stopLossOrderCount = 0;
                        multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;
                        positionFoundMarketPosition = position.MarketPosition;



                        //if (isCtrlKeyDown && overrideStopLossPrice == 0) break;

                        //oldStopLossPrice = (overrideStopLossPrice != 0) ? overrideStopLossPrice : RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);
                        oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);

                        hasStopLoss = (oldStopLossPrice > 0);

                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Current SL price=" + oldStopLossPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString() + " via " + signalName);

                        if (!hasStopLoss)
                        {
                            if (overrideStopLossPrice != 0)
                                newStopLossPrice = overrideStopLossPrice;
                            else
                                newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, multiPositionAveragePrice, position.Quantity);
                            //newStopLossPrice = (overrideStopLossPrice != 0) ? overrideStopLossPrice : GetInitialStopLossPrice(position.MarketPosition, multiPositionAveragePrice, position.Quantity);

                            if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionStopLossPrice > 0)
                                newStopLossPrice = tempBlendedInstrumentPositionStopLossPrice;

                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                            RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);

                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                            if (hasValidNewStopLossPrice && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);
                                    CreatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                }
                            }
                        }
                        else
                        {
                            if (StopLossCTRLJumpTicks)
                            {
                                if (isCtrlKeyDown)
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, this.StopLossJumpTicks);
                                }
                                else
                                {
                                    newStopLossPrice = GetNextSnapPrice(position.MarketPosition, oldStopLossPrice);
                                }
                            }
                            else
                            {
                                if (isCtrlKeyDown)
                                {
                                    newStopLossPrice = GetNextSnapPrice(position.MarketPosition, oldStopLossPrice);
                                }
                                else
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, this.StopLossJumpTicks);
                                }
                            }

                            if (overrideStopLossPrice != 0) newStopLossPrice = overrideStopLossPrice;

                            //newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, this.StopLossJumpTicks);

                            if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionStopLossPrice > 0 && blendedHasBeenProcessed)
                                newStopLossPrice = tempBlendedInstrumentPositionStopLossPrice;

                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                            hasStopLossPriceMismatch = oldStopLossPrice > 0 && newStopLossPrice > 0 && oldStopLossPrice != newStopLossPrice;

                            if (hasStopLossPriceMismatch && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString() + " via " + signalName);
                                    UpdatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, 0, newStopLossPrice);
                                }
                            }
                        }

                        attachedHasBeenProcessed = true;
                        tempAttachedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                        //break; //only one postion per instrument so exit early
                    }
                    else if (IsBlendedInstrumentEnabled() && RealPositionService.IsValidPosition(position, blendedInstrument) && position.IsValid)
                    {
                        position.StoreState();
                        positionFound = true;
                        tempQuantity = position.Quantity;
                        newStopLossPrice = 0;
                        stopLossOrderCount = 0;
                        multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;
                        positionFoundMarketPosition = position.MarketPosition;

                        //oldStopLossPrice = (overrideStopLossPrice != 0) ? overrideStopLossPrice : RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);
                        oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);
                        hasStopLoss = (oldStopLossPrice > 0);

                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Current SL price=" + oldStopLossPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString() + " via " + signalName);

                        if (!hasStopLoss)
                        {
                            if (overrideStopLossPrice != 0)
                                newStopLossPrice = overrideStopLossPrice;
                            else
                                newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, multiPositionAveragePrice, position.Quantity);

                            //newStopLossPrice = (overrideStopLossPrice != 0) ? overrideStopLossPrice : GetInitialStopLossPrice(position.MarketPosition, multiPositionAveragePrice, position.Quantity);

                            if (attachedInstrumentHasPosition && tempAttachedInstrumentPositionStopLossPrice > 0)
                                newStopLossPrice = tempAttachedInstrumentPositionStopLossPrice;

                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                            RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);

                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                            if (hasValidNewStopLossPrice && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);
                                    CreatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                }
                            }
                        }
                        else
                        {
                            if (StopLossCTRLJumpTicks)
                            {
                                if (isCtrlKeyDown)
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, this.StopLossJumpTicks);
                                }
                                else
                                {
                                    newStopLossPrice = GetNextSnapPrice(position.MarketPosition, oldStopLossPrice);
                                }
                            }
                            else
                            {
                                if (isCtrlKeyDown)
                                {
                                    newStopLossPrice = GetNextSnapPrice(position.MarketPosition, oldStopLossPrice);
                                }
                                else
                                {
                                    newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, this.StopLossJumpTicks);
                                }
                            }

                            if (overrideStopLossPrice != 0) newStopLossPrice = overrideStopLossPrice;

                            //newStopLossPrice = GetStopLossPriceFromJumpTicks(position.MarketPosition, oldStopLossPrice, this.StopLossJumpTicks);

                            if (attachedInstrumentHasPosition && tempAttachedInstrumentPositionStopLossPrice > 0 && attachedHasBeenProcessed)
                                newStopLossPrice = tempAttachedInstrumentPositionStopLossPrice;


                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                            hasStopLossPriceMismatch = oldStopLossPrice > 0 && newStopLossPrice > 0 && oldStopLossPrice != newStopLossPrice;

                            if (hasStopLossPriceMismatch && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString() + " via " + signalName);
                                    UpdatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, 0, newStopLossPrice);
                                }
                            }
                        }

                        blendedHasBeenProcessed = true;
                        tempBlendedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                        //break; //only one postion per instrument so exit early
                    }
                }
            }

            /*
            if (positionFound && isCtrlKeyDown && overrideStopLossPrice == 0)
            {
                if (positionFoundMarketPosition == MarketPosition.Long)
                {
                    HandleBuySnap("HandleStopLossPlus");
                }
                else if (positionFoundMarketPosition == MarketPosition.Short)
                {
                    HandleSellSnap("HandleStopLossPlus");
                }
            }
            */

            return positionFound;
        }

        private double GetNextSnapPrice(MarketPosition marketPosition, double oldStopLossPrice, bool returnSamePriceWhenPriceIsSame = false)
        {
            double snapStopLossPrice = 0;


            if (marketPosition == MarketPosition.Long)
            {
                double snapPBLevel50 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel50);
                double snapPBLevel40 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel40);
                double snapPBLevel30 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel30);
                double snapPBLevel20 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel20);
                double snapPBLevel10 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel10);
                double snapPBLevel = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel);
                double snapKeltnerInnerRing = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapKeltnerInnerRing);
                double snapRiver5 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapRiver5);
                double snapRiver1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapRiver1);
                double snapCreek5 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapCreek5);
                double snapCreek1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapCreek1);
                double snapZipLine1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapZipLine1);
                double snapZipLine2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapZipLine2);
                double snapDriftLine1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine1);
                double snapDriftLine2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine2);
                double snapDriftLine3 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine3);
                double snapDriftLine4 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine4);
                double snapKineticLine1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapKineticLine1);
                double snapKineticLine2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapKineticLine2);
                double snapSpeedLine = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapSpeedLine);
                double snapRushLine = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapRushLine);
                double snapStingRayLevel1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel1);
                double snapStingRayLevel2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel2);
                double snapStingRayLevel3 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel3);
                double snapStingRayLevel4 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel4);
                double snapStingRayLevel5 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel5);
                double snap20 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap20Bar);
                double snap19 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap19Bar);
                double snap18 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap18Bar);
                double snap17 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap17Bar);
                double snap16 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap16Bar);
                double snap15 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap15Bar);
                double snap14 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap14Bar);
                double snap13 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap13Bar);
                double snap12 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap12Bar);
                double snap11 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap11Bar);
                double snap10 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap10Bar);
                double snap9 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap9Bar);
                double snap8 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap8Bar);
                double snap7 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap7Bar);
                double snap6 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap6Bar);
                double snap5 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap5Bar);
                double snap4 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap4Bar);
                double snap3 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap3Bar);
                double snap2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap2Bar);
                double snap1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap1Bar);

                double min1 = 0;
                double min2 = 0;
                double min3 = 0;
                double min4 = 0;
                double min5 = 0;
                double min6 = 0;
                double min7 = 0;
                double min8 = 0;
                double min9 = 0;
                double min10 = 0;
                double min11 = 0;
                double min12 = 0;
                double min13 = 0;
                double min14 = 0;
                double min15 = 0;
                double min16 = 0;
                double min17 = 0;
                double min18 = 0;
                double min19 = 0;
                double min20 = 0;
                double min21 = 0;
                double min22 = 0;
                double min23 = 0;
                double min24 = 0;
                double min25 = 0;
                double min26 = 0;
                double min27 = 0;
                double min28 = 0;
                double min29 = 0;
                double min30 = 0;
                double min31 = 0;
                double min32 = 0;
                double min33 = 0;
                double min34 = 0;
                double min35 = 0;
                double min36 = 0;
                double min37 = 0;
                double min38 = 0;
                double min39 = 0;
                double min40 = 0;
                double min41 = 0;
                double min42 = 0;
                double min43 = 0;
                double min44 = 0;
                double min45 = 0;
                double min46 = 0;

                List<double> minList = new List<double>();
                minList.Add(snapPBLevel50);
                minList.Add(snapPBLevel40);
                minList.Add(snapPBLevel30);
                minList.Add(snapPBLevel20);
                minList.Add(snapPBLevel10);
                minList.Add(snapPBLevel);
                minList.Add(snapKeltnerInnerRing);
                minList.Add(snapRiver5);
                minList.Add(snapRiver1);
                minList.Add(snapCreek5);
                minList.Add(snapCreek1);
                minList.Add(snapZipLine2);
                minList.Add(snapZipLine1);
                minList.Add(snapStingRayLevel1);
                minList.Add(snapStingRayLevel2);
                minList.Add(snapStingRayLevel3);
                minList.Add(snapStingRayLevel4);
                minList.Add(snapStingRayLevel5);
                minList.Add(snapKineticLine1);
                minList.Add(snapKineticLine2);
                minList.Add(snapDriftLine4);
                minList.Add(snapDriftLine3);
                minList.Add(snapDriftLine2);
                minList.Add(snapDriftLine1);
                minList.Add(snapSpeedLine);
                minList.Add(snapRushLine);
                minList.Add(snap20);
                minList.Add(snap19);
                minList.Add(snap18);
                minList.Add(snap17);
                minList.Add(snap16);
                minList.Add(snap15);
                minList.Add(snap14);
                minList.Add(snap13);
                minList.Add(snap12);
                minList.Add(snap11);
                minList.Add(snap10);
                minList.Add(snap9);
                minList.Add(snap8);
                minList.Add(snap7);
                minList.Add(snap6);
                minList.Add(snap5);
                minList.Add(snap4);
                minList.Add(snap3);
                minList.Add(snap2);
                minList.Add(snap1);
                minList.Sort();

                /*
                RealLogger.PrintOutput("*** DEBUG before snapPBLevel=" + snapPBLevel);
                RealLogger.PrintOutput("*** DEBUG before snapRiver5=" + snapRiver5);
                RealLogger.PrintOutput("*** DEBUG before snapRiver1=" + snapRiver1);
                RealLogger.PrintOutput("*** DEBUG before snap8=" + snap8);
                RealLogger.PrintOutput("*** DEBUG before snap5=" + snap5);
                RealLogger.PrintOutput("*** DEBUG before snap2=" + snap2);
                RealLogger.PrintOutput("*** DEBUG before min1=" + min1);
                */

                int index = 0;
                bool foundSnap1 = false;
                foreach (double item in minList)
                {
                    index++;

                    if (index == 1)
                    {
                        min1 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min1 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 2)
                    {
                        min2 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min2 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 3)
                    {
                        min3 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min3 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 4)
                    {
                        min4 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min4 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 5)
                    {
                        min5 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min5 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 6)
                    {
                        min6 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min6 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 7)
                    {
                        min7 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min7 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 8)
                    {
                        min8 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min8 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 9)
                    {
                        min9 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min9 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 10)
                    {
                        min10 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min10 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 11)
                    {
                        min11 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min11 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 12)
                    {
                        min12 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min12 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 13)
                    {
                        min13 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min13 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 14)
                    {
                        min14 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min14 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 15)
                    {
                        min15 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min15 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 16)
                    {
                        min16 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min16 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 17)
                    {
                        min17 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min17 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 18)
                    {
                        min18 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min18 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 19)
                    {
                        min19 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min19 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 20)
                    {
                        min20 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min20 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 21)
                    {
                        min21 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min21 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 22)
                    {
                        min22 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min22 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 23)
                    {
                        min23 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min23 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 24)
                    {
                        min24 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min24 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 25)
                    {
                        min25 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min25 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 26)
                    {
                        min26 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min26 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 27)
                    {
                        min27 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min27 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 28)
                    {
                        min28 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min28 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 29)
                    {
                        min29 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min29 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 30)
                    {
                        min30 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min30 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 31)
                    {
                        min31 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min31 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 32)
                    {
                        min32 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min32 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 33)
                    {
                        min33 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min33 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 34)
                    {
                        min34 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min34 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 35)
                    {
                        min35 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min35 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 36)
                    {
                        min36 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min36 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 37)
                    {
                        min37 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min37 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 38)
                    {
                        min38 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min38 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 39)
                    {
                        min39 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min39 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 40)
                    {
                        min40 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min40 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 41)
                    {
                        min41 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min41 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 42)
                    {
                        min42 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min42 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 43)
                    {
                        min43 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min43 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 44)
                    {
                        min44 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min44 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 45)
                    {
                        min45 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min45 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 46)
                    {
                        min46 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min46 = snap1;
                            foundSnap1 = true;
                        }
                    }
                }

                /*
                RealLogger.PrintOutput("*** DEBUG after min8=" + min8);
                RealLogger.PrintOutput("*** DEBUG after min7=" + min7);
                RealLogger.PrintOutput("*** DEBUG after min6=" + min6);
                RealLogger.PrintOutput("*** DEBUG after min5=" + min5);
                RealLogger.PrintOutput("*** DEBUG after min4=" + min4);
                RealLogger.PrintOutput("*** DEBUG after min3=" + min3);
                RealLogger.PrintOutput("*** DEBUG after min2=" + min2);
                RealLogger.PrintOutput("*** DEBUG after min1=" + min1);
                */

                snapStopLossPrice = min1;

                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                {
                    snapStopLossPrice = min2;

                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                    {
                        snapStopLossPrice = min3;

                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                        {
                            snapStopLossPrice = min4;

                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                            {
                                snapStopLossPrice = min5;

                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                {
                                    snapStopLossPrice = min6;

                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                    {
                                        snapStopLossPrice = min7;

                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                        {
                                            snapStopLossPrice = min8;

                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                            {
                                                snapStopLossPrice = min9;

                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                {
                                                    snapStopLossPrice = min10;

                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                    {
                                                        snapStopLossPrice = min11;

                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                        {
                                                            snapStopLossPrice = min12;

                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                            {
                                                                snapStopLossPrice = min13;

                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                {
                                                                    snapStopLossPrice = min14;

                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                    {
                                                                        snapStopLossPrice = min15;

                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                        {
                                                                            snapStopLossPrice = min16;

                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                            {
                                                                                snapStopLossPrice = min17;

                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                {
                                                                                    snapStopLossPrice = min17;

                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                    {
                                                                                        snapStopLossPrice = min18;

                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                        {
                                                                                            snapStopLossPrice = min19;

                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                            {
                                                                                                snapStopLossPrice = min20;

                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                {
                                                                                                    snapStopLossPrice = min21;

                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                    {
                                                                                                        snapStopLossPrice = min22;

                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                        {
                                                                                                            snapStopLossPrice = min23;

                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                            {
                                                                                                                snapStopLossPrice = min24;

                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                {
                                                                                                                    snapStopLossPrice = min25;

                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                    {
                                                                                                                        snapStopLossPrice = min26;

                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                        {
                                                                                                                            snapStopLossPrice = min27;

                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                            {
                                                                                                                                snapStopLossPrice = min28;

                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                {
                                                                                                                                    snapStopLossPrice = min29;

                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                    {
                                                                                                                                        snapStopLossPrice = min30;

                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                        {
                                                                                                                                            snapStopLossPrice = min31;

                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                            {
                                                                                                                                                snapStopLossPrice = min32;

                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                {
                                                                                                                                                    snapStopLossPrice = min33;

                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                    {
                                                                                                                                                        snapStopLossPrice = min34;

                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                        {
                                                                                                                                                            snapStopLossPrice = min35;

                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                            {
                                                                                                                                                                snapStopLossPrice = min36;

                                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                {
                                                                                                                                                                    snapStopLossPrice = min37;

                                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                    {
                                                                                                                                                                        snapStopLossPrice = min38;

                                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                        {
                                                                                                                                                                            snapStopLossPrice = min39;

                                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                            {
                                                                                                                                                                                snapStopLossPrice = min40;

                                                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                {
                                                                                                                                                                                    snapStopLossPrice = min41;

                                                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                    {
                                                                                                                                                                                        snapStopLossPrice = min42;

                                                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                        {
                                                                                                                                                                                            snapStopLossPrice = min43;

                                                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                            {
                                                                                                                                                                                                snapStopLossPrice = min44;

                                                                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                                {
                                                                                                                                                                                                    snapStopLossPrice = min45;

                                                                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                                                                                                                                    {
                                                                                                                                                                                                        snapStopLossPrice = min46;
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else if (marketPosition == MarketPosition.Short)
            {
                double snapPBLevel50 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel50);
                double snapPBLevel40 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel40);
                double snapPBLevel30 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel30);
                double snapPBLevel20 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel20);
                double snapPBLevel10 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel10);
                double snapPBLevel = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel);
                double snapSpeedLine = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapSpeedLine);
                double snapRushLine = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapRushLine);
                double snapZipLine1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapZipLine1);
                double snapZipLine2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapZipLine2);
                double snapDriftLine1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine1);
                double snapDriftLine2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine2);
                double snapDriftLine3 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine3);
                double snapDriftLine4 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine4);
                double snapKineticLine1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapKineticLine1);
                double snapKineticLine2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapKineticLine2);
                double snapKeltnerInnerRing = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapKeltnerInnerRing);
                double snapRiver1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapRiver1);
                double snapRiver5 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapRiver5);
                double snapCreek1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapCreek1);
                double snapCreek5 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapCreek5);
                double snapStingRayLevel1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel1);
                double snapStingRayLevel2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel2);
                double snapStingRayLevel3 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel3);
                double snapStingRayLevel4 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel4);
                double snapStingRayLevel5 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapStingRayLevel5);
                double snap20 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap20Bar);
                double snap19 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap19Bar);
                double snap18 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap18Bar);
                double snap17 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap17Bar);
                double snap16 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap16Bar);
                double snap15 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap15Bar);
                double snap14 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap14Bar);
                double snap13 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap13Bar);
                double snap12 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap12Bar);
                double snap11 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap11Bar);
                double snap10 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap10Bar);
                double snap9 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap9Bar);
                double snap8 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap8Bar);
                double snap7 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap7Bar);
                double snap6 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap6Bar);
                double snap5 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap5Bar);
                double snap4 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap4Bar);
                double snap3 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap3Bar);
                double snap2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap2Bar);
                double snap1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap1Bar);


                double max1 = 0;
                double max2 = 0;
                double max3 = 0;
                double max4 = 0;
                double max5 = 0;
                double max6 = 0;
                double max7 = 0;
                double max8 = 0;
                double max9 = 0;
                double max10 = 0;
                double max11 = 0;
                double max12 = 0;
                double max13 = 0;
                double max14 = 0;
                double max15 = 0;
                double max16 = 0;
                double max17 = 0;
                double max18 = 0;
                double max19 = 0;
                double max20 = 0;
                double max21 = 0;
                double max22 = 0;
                double max23 = 0;
                double max24 = 0;
                double max25 = 0;
                double max26 = 0;
                double max27 = 0;
                double max28 = 0;
                double max29 = 0;
                double max30 = 0;
                double max31 = 0;
                double max32 = 0;
                double max33 = 0;
                double max34 = 0;
                double max35 = 0;
                double max36 = 0;
                double max37 = 0;
                double max38 = 0;
                double max39 = 0;
                double max40 = 0;
                double max41 = 0;
                double max42 = 0;
                double max43 = 0;
                double max44 = 0;
                double max45 = 0;
                double max46 = 0;

                List<double> maxList = new List<double>();
                maxList.Add(snapPBLevel50);
                maxList.Add(snapPBLevel40);
                maxList.Add(snapPBLevel30);
                maxList.Add(snapPBLevel20);
                maxList.Add(snapPBLevel10);
                maxList.Add(snapPBLevel);
                maxList.Add(snapStingRayLevel5);
                maxList.Add(snapStingRayLevel4);
                maxList.Add(snapStingRayLevel3);
                maxList.Add(snapStingRayLevel2);
                maxList.Add(snapStingRayLevel1);
                maxList.Add(snapKeltnerInnerRing);
                maxList.Add(snapRiver5);
                maxList.Add(snapRiver1);
                maxList.Add(snapCreek5);
                maxList.Add(snapCreek1);
                maxList.Add(snapZipLine2);
                maxList.Add(snapZipLine1);
                maxList.Add(snapKineticLine1);
                maxList.Add(snapKineticLine2);
                maxList.Add(snapDriftLine4);
                maxList.Add(snapDriftLine3);
                maxList.Add(snapDriftLine2);
                maxList.Add(snapDriftLine1);
                maxList.Add(snapSpeedLine);
                maxList.Add(snapRushLine);
                maxList.Add(snap20);
                maxList.Add(snap19);
                maxList.Add(snap18);
                maxList.Add(snap17);
                maxList.Add(snap16);
                maxList.Add(snap15);
                maxList.Add(snap14);
                maxList.Add(snap13);
                maxList.Add(snap12);
                maxList.Add(snap11);
                maxList.Add(snap10);
                maxList.Add(snap9);
                maxList.Add(snap8);
                maxList.Add(snap7);
                maxList.Add(snap6);
                maxList.Add(snap5);
                maxList.Add(snap4);
                maxList.Add(snap3);
                maxList.Add(snap2);
                maxList.Add(snap1);
                maxList.Sort();
                maxList.Reverse();

                int index = 0;
                bool foundSnap1 = false;
                foreach (double item in maxList)
                {
                    index++;

                    if (index == 1)
                    {
                        max1 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max1 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 2)
                    {
                        max2 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max2 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 3)
                    {
                        max3 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max3 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 4)
                    {
                        max4 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max4 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 5)
                    {
                        max5 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max5 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 6)
                    {
                        max6 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max6 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 7)
                    {
                        max7 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max7 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 8)
                    {
                        max8 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max8 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 9)
                    {
                        max9 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max9 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 10)
                    {
                        max10 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max10 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 11)
                    {
                        max11 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max11 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 12)
                    {
                        max12 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max12 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 13)
                    {
                        max13 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max13 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 14)
                    {
                        max14 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max14 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 15)
                    {
                        max15 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max15 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 16)
                    {
                        max16 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max16 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 17)
                    {
                        max17 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max17 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 18)
                    {
                        max18 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max18 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 19)
                    {
                        max19 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max19 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 20)
                    {
                        max20 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max20 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 21)
                    {
                        max21 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max21 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 22)
                    {
                        max22 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max22 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 23)
                    {
                        max23 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max23 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 24)
                    {
                        max24 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max24 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 25)
                    {
                        max25 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max25 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 26)
                    {
                        max26 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max26 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 27)
                    {
                        max27 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max27 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 28)
                    {
                        max28 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max28 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 29)
                    {
                        max29 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max29 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 30)
                    {
                        max30 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max30 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 31)
                    {
                        max31 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max31 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 32)
                    {
                        max32 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max32 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 33)
                    {
                        max33 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max33 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 34)
                    {
                        max34 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max34 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 35)
                    {
                        max35 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max35 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 36)
                    {
                        max36 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max36 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 37)
                    {
                        max37 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max37 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 38)
                    {
                        max38 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max38 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 39)
                    {
                        max39 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max39 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 40)
                    {
                        max40 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max40 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 41)
                    {
                        max41 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max41 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 42)
                    {
                        max42 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max42 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 43)
                    {
                        max43 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max43 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 44)
                    {
                        max44 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max44 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 45)
                    {
                        max45 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max45 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 46)
                    {
                        max46 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max46 = snap1;
                            foundSnap1 = true;
                        }
                    }
                }

                /*
                RealLogger.PrintOutput("*** DEBUG after max1=" + max1);
                RealLogger.PrintOutput("*** DEBUG after max2=" + max2);
                RealLogger.PrintOutput("*** DEBUG after max3=" + max3);
                RealLogger.PrintOutput("*** DEBUG after max4=" + max4);
                RealLogger.PrintOutput("*** DEBUG after max5=" + max5);
                RealLogger.PrintOutput("*** DEBUG after max6=" + max6);
                RealLogger.PrintOutput("*** DEBUG after max7=" + max7);
                RealLogger.PrintOutput("*** DEBUG after max8=" + max8);
                RealLogger.PrintOutput("*** DEBUG after max9=" + max9);
                RealLogger.PrintOutput("*** DEBUG after max10=" + max10);
                RealLogger.PrintOutput("*** DEBUG after max11=" + max11);
                RealLogger.PrintOutput("*** DEBUG after max12=" + max12);
                RealLogger.PrintOutput("*** DEBUG after max13=" + max13);
                RealLogger.PrintOutput("*** DEBUG after max14=" + max14);
                RealLogger.PrintOutput("*** DEBUG after max15=" + max15);
                */

                snapStopLossPrice = max1;

                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                {
                    snapStopLossPrice = max2;

                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                    {
                        snapStopLossPrice = max3;

                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                        {
                            snapStopLossPrice = max4;

                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                            {
                                snapStopLossPrice = max5;

                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                {
                                    snapStopLossPrice = max6;

                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                    {
                                        snapStopLossPrice = max7;

                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                        {
                                            snapStopLossPrice = max8;

                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                            {
                                                snapStopLossPrice = max9;

                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                {
                                                    snapStopLossPrice = max10;

                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                    {
                                                        snapStopLossPrice = max11;

                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                        {
                                                            snapStopLossPrice = max12;

                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                            {
                                                                snapStopLossPrice = max13;

                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                {
                                                                    snapStopLossPrice = max14;

                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                    {
                                                                        snapStopLossPrice = max15;

                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                        {
                                                                            snapStopLossPrice = max16;

                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                            {
                                                                                snapStopLossPrice = max17;

                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                {
                                                                                    snapStopLossPrice = max18;

                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                    {
                                                                                        snapStopLossPrice = max19;

                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                        {
                                                                                            snapStopLossPrice = max20;

                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                            {
                                                                                                snapStopLossPrice = max21;

                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                {
                                                                                                    snapStopLossPrice = max22;

                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                    {
                                                                                                        snapStopLossPrice = max23;

                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                        {
                                                                                                            snapStopLossPrice = max24;

                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                            {
                                                                                                                snapStopLossPrice = max25;

                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                {
                                                                                                                    snapStopLossPrice = max26;

                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                    {
                                                                                                                        snapStopLossPrice = max27;

                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                        {
                                                                                                                            snapStopLossPrice = max28;

                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                            {
                                                                                                                                snapStopLossPrice = max29;

                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                {
                                                                                                                                    snapStopLossPrice = max30;

                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                    {
                                                                                                                                        snapStopLossPrice = max31;

                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                        {
                                                                                                                                            snapStopLossPrice = max32;

                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                            {
                                                                                                                                                snapStopLossPrice = max33;

                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                {
                                                                                                                                                    snapStopLossPrice = max34;

                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                    {
                                                                                                                                                        snapStopLossPrice = max35;

                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                        {
                                                                                                                                                            snapStopLossPrice = max36;

                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                            {
                                                                                                                                                                snapStopLossPrice = max37;

                                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                {
                                                                                                                                                                    snapStopLossPrice = max38;

                                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                    {
                                                                                                                                                                        snapStopLossPrice = max39;

                                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                        {
                                                                                                                                                                            snapStopLossPrice = max40;

                                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                            {
                                                                                                                                                                                snapStopLossPrice = max41;

                                                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                                {
                                                                                                                                                                                    snapStopLossPrice = max42;

                                                                                                                                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                                    {
                                                                                                                                                                                        snapStopLossPrice = max43;

                                                                                                                                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                                        {
                                                                                                                                                                                            snapStopLossPrice = max44;

                                                                                                                                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                                            {
                                                                                                                                                                                                snapStopLossPrice = max45;

                                                                                                                                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                                                                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                                                                                                                                {
                                                                                                                                                                                                    snapStopLossPrice = max46;
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return snapStopLossPrice;
        }

        private double GetNextDriftLinePrice(MarketPosition marketPosition, double oldStopLossPrice, bool returnSamePriceWhenPriceIsSame = false)
        {
            double snapStopLossPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                double snapPBLevel50 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel50);
                double snapPBLevel40 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel40);
                double snapPBLevel30 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel30);
                double snapPBLevel20 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel20);
                double snapPBLevel10 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel10);
                double snapPBLevel = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapPBLevel);
                double snapRushLine = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapRushLine);
                double snapDriftLine1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine1);
                double snapDriftLine2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine2);
                double snapDriftLine3 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine3);
                double snapDriftLine4 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.SnapDriftLine4);
                double snap7 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap7Bar);
                double snap6 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap6Bar);
                double snap5 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap5Bar);
                double snap4 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap4Bar);
                double snap3 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap3Bar);
                double snap2 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap2Bar);
                double snap1 = CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes.Snap1Bar);

                double min1 = 0;
                double min2 = 0;
                double min3 = 0;
                double min4 = 0;
                double min5 = 0;
                double min6 = 0;
                double min7 = 0;
                double min8 = 0;
                double min9 = 0;
                double min10 = 0;
                double min11 = 0;
                double min12 = 0;
                double min13 = 0;
                double min14 = 0;
                double min15 = 0;
                double min16 = 0;
                double min17 = 0;
                double min18 = 0;

                List<double> minList = new List<double>();
                minList.Add(snapPBLevel50);
                minList.Add(snapPBLevel40);
                minList.Add(snapPBLevel30);
                minList.Add(snapPBLevel20);
                minList.Add(snapPBLevel10);
                minList.Add(snapPBLevel);
                minList.Add(snapDriftLine4);
                minList.Add(snapDriftLine3);
                minList.Add(snapDriftLine2);
                minList.Add(snapDriftLine1);
                minList.Add(snapRushLine);
                minList.Add(snap7);
                minList.Add(snap6);
                minList.Add(snap5);
                minList.Add(snap4);
                minList.Add(snap3);
                minList.Add(snap2);
                minList.Add(snap1);
                minList.Sort();

                /*
                RealLogger.PrintOutput("*** DEBUG before snapPBLevel=" + snapPBLevel);
                RealLogger.PrintOutput("*** DEBUG before snapRiver5=" + snapRiver5);
                RealLogger.PrintOutput("*** DEBUG before snapRiver1=" + snapRiver1);
                RealLogger.PrintOutput("*** DEBUG before snap8=" + snap8);
                RealLogger.PrintOutput("*** DEBUG before snap5=" + snap5);
                RealLogger.PrintOutput("*** DEBUG before snap2=" + snap2);
                RealLogger.PrintOutput("*** DEBUG before min1=" + min1);
                */

                int index = 0;
                bool foundSnap1 = false;
                foreach (double item in minList)
                {
                    index++;

                    if (index == 1)
                    {
                        min1 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min1 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 2)
                    {
                        min2 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min2 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 3)
                    {
                        min3 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min3 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 4)
                    {
                        min4 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min4 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 5)
                    {
                        min5 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min5 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 6)
                    {
                        min6 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min6 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 7)
                    {
                        min7 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min7 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 8)
                    {
                        min8 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min8 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 9)
                    {
                        min9 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min9 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 10)
                    {
                        min10 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min10 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 11)
                    {
                        min11 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min11 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 12)
                    {
                        min12 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min12 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 13)
                    {
                        min13 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min13 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 14)
                    {
                        min14 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min14 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 15)
                    {
                        min15 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min15 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 16)
                    {
                        min16 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min16 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 17)
                    {
                        min17 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min17 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 18)
                    {
                        min18 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            min18 = snap1;
                            foundSnap1 = true;
                        }
                    }
                }

                /*
                RealLogger.PrintOutput("*** DEBUG after min8=" + min8);
                RealLogger.PrintOutput("*** DEBUG after min7=" + min7);
                RealLogger.PrintOutput("*** DEBUG after min6=" + min6);
                RealLogger.PrintOutput("*** DEBUG after min5=" + min5);
                RealLogger.PrintOutput("*** DEBUG after min4=" + min4);
                RealLogger.PrintOutput("*** DEBUG after min3=" + min3);
                RealLogger.PrintOutput("*** DEBUG after min2=" + min2);
                RealLogger.PrintOutput("*** DEBUG after min1=" + min1);
                */

                snapStopLossPrice = min1;

                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                {
                    snapStopLossPrice = min2;

                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                    {
                        snapStopLossPrice = min3;

                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                        {
                            snapStopLossPrice = min4;

                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                            {
                                snapStopLossPrice = min5;

                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                {
                                    snapStopLossPrice = min6;

                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                    {
                                        snapStopLossPrice = min7;

                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                        {
                                            snapStopLossPrice = min8;

                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                            {
                                                snapStopLossPrice = min9;

                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                {
                                                    snapStopLossPrice = min10;

                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                    {
                                                        snapStopLossPrice = min11;

                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                        {
                                                            snapStopLossPrice = min12;

                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                            {
                                                                snapStopLossPrice = min13;

                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                {
                                                                    snapStopLossPrice = min14;

                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                    {
                                                                        snapStopLossPrice = min15;

                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                        {
                                                                            snapStopLossPrice = min16;

                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                            {
                                                                                snapStopLossPrice = min17;

                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice <= oldStopLossPrice)
                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice < oldStopLossPrice))
                                                                                {
                                                                                    snapStopLossPrice = min18;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else if (marketPosition == MarketPosition.Short)
            {
                double snapPBLevel50 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel50);
                double snapPBLevel40 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel40);
                double snapPBLevel30 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel30);
                double snapPBLevel20 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel20);
                double snapPBLevel10 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel10);
                double snapPBLevel = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapPBLevel);
                double snapRushLine = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapRushLine);
                double snapDriftLine1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine1);
                double snapDriftLine2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine2);
                double snapDriftLine3 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine3);
                double snapDriftLine4 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.SnapDriftLine4);
                double snap7 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap7Bar);
                double snap6 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap6Bar);
                double snap5 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap5Bar);
                double snap4 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap4Bar);
                double snap3 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap3Bar);
                double snap2 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap2Bar);
                double snap1 = CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes.Snap1Bar);

                double max1 = 0;
                double max2 = 0;
                double max3 = 0;
                double max4 = 0;
                double max5 = 0;
                double max6 = 0;
                double max7 = 0;
                double max8 = 0;
                double max9 = 0;
                double max10 = 0;
                double max11 = 0;
                double max12 = 0;
                double max13 = 0;
                double max14 = 0;
                double max15 = 0;
                double max16 = 0;
                double max17 = 0;
                double max18 = 0;

                List<double> maxList = new List<double>();
                maxList.Add(snapPBLevel50);
                maxList.Add(snapPBLevel40);
                maxList.Add(snapPBLevel30);
                maxList.Add(snapPBLevel20);
                maxList.Add(snapPBLevel10);
                maxList.Add(snapPBLevel);
                maxList.Add(snapDriftLine4);
                maxList.Add(snapDriftLine3);
                maxList.Add(snapDriftLine2);
                maxList.Add(snapDriftLine1);
                maxList.Add(snapRushLine);
                maxList.Add(snap7);
                maxList.Add(snap6);
                maxList.Add(snap5);
                maxList.Add(snap4);
                maxList.Add(snap3);
                maxList.Add(snap2);
                maxList.Add(snap1);
                maxList.Sort();
                maxList.Reverse();

                int index = 0;
                bool foundSnap1 = false;
                foreach (double item in maxList)
                {
                    index++;

                    if (index == 1)
                    {
                        max1 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max1 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 2)
                    {
                        max2 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max2 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 3)
                    {
                        max3 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max3 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 4)
                    {
                        max4 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max4 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 5)
                    {
                        max5 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max5 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 6)
                    {
                        max6 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max6 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 7)
                    {
                        max7 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max7 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 8)
                    {
                        max8 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max8 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 9)
                    {
                        max9 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max9 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 10)
                    {
                        max10 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max10 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 11)
                    {
                        max11 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max11 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 12)
                    {
                        max12 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max12 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 13)
                    {
                        max13 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max13 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 14)
                    {
                        max14 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max14 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 15)
                    {
                        max15 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max15 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 16)
                    {
                        max16 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max16 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 17)
                    {
                        max17 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max17 = snap1;
                            foundSnap1 = true;
                        }
                    }
                    else if (index == 18)
                    {
                        max18 = item;

                        if (item == snap1 || foundSnap1)
                        {
                            max18 = snap1;
                            foundSnap1 = true;
                        }
                    }
                }

                /*
                RealLogger.PrintOutput("*** DEBUG after max1=" + max1);
                RealLogger.PrintOutput("*** DEBUG after max2=" + max2);
                RealLogger.PrintOutput("*** DEBUG after max3=" + max3);
                RealLogger.PrintOutput("*** DEBUG after max4=" + max4);
                RealLogger.PrintOutput("*** DEBUG after max5=" + max5);
                RealLogger.PrintOutput("*** DEBUG after max6=" + max6);
                RealLogger.PrintOutput("*** DEBUG after max7=" + max7);
                RealLogger.PrintOutput("*** DEBUG after max8=" + max8);
                */

                snapStopLossPrice = max1;

                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                {
                    snapStopLossPrice = max2;

                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                    {
                        snapStopLossPrice = max3;

                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                        {
                            snapStopLossPrice = max4;

                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                            {
                                snapStopLossPrice = max5;

                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                {
                                    snapStopLossPrice = max6;

                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                    {
                                        snapStopLossPrice = max7;

                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                        {
                                            snapStopLossPrice = max8;

                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                            {
                                                snapStopLossPrice = max9;

                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                {
                                                    snapStopLossPrice = max10;

                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                    {
                                                        snapStopLossPrice = max11;

                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                        {
                                                            snapStopLossPrice = max12;

                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                            {
                                                                snapStopLossPrice = max13;

                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                {
                                                                    snapStopLossPrice = max14;

                                                                    if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                        || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                    {
                                                                        snapStopLossPrice = max15;

                                                                        if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                            || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                        {
                                                                            snapStopLossPrice = max16;

                                                                            if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                            {
                                                                                snapStopLossPrice = max17;

                                                                                if ((!returnSamePriceWhenPriceIsSame && snapStopLossPrice >= oldStopLossPrice)
                                                                                    || (returnSamePriceWhenPriceIsSame && snapStopLossPrice > oldStopLossPrice))
                                                                                {
                                                                                    snapStopLossPrice = max18;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return snapStopLossPrice;
        }


        private bool HandleTPSLRefresh(string signalName)
        {
            double oldStopLossPrice = 0;
            double oldTakeProfitPrice = 0;
            int oldOrderQuantity = 0;
            double newStopLossPrice = 0;
            double newTakeProfitPrice = 0;
            double triggerStopLossPrice = 0;
            bool hasPosition = false;
            bool hasStopLoss = false;
            bool hasTakeProfit = false;
            bool hasProfitLocked = false;
            bool hasHitPriceTrigger = false;
            bool hasTakeProfitPriceMismatch = false;
            bool hasStopLossPriceMismatch = false;
            bool hasValidNewTakeProfitPrice = false;
            bool hasValidNewStopLossPrice = false;
            int stopLossOrderCount = 0;
            int takeProfitOrderCount = 0;
            int tempQuantity = 0;
            OrderType orderType = OrderType.Unknown;
            bool hasStopLossQuantityMismatch = false;
            bool hasTakeProfitQuantityMismatch = false;

            var lockTimeout = TimeSpan.FromMilliseconds(250);
            bool lockTaken = false;

            try
            {

                Monitor.TryEnter(RefreshTPSLLock, lockTimeout, ref lockTaken);

                if (lockTaken)
                {
                    if ((!IsAccountFlat(attachedInstrument) || (IsBlendedInstrumentEnabled() && !IsAccountFlat(blendedInstrument)))
                        && RealOrderService.AreAllOrderUpdateCyclesComplete()
                        && !HasPositionTPSLOrderDelay())
                    {
                        double multiPositionAveragePrice = 0;
                        int positionCount = RealPositionService.PositionCount;

                        for (int index = 0; index < positionCount; index++)
                        {
                            RealPosition position = null;
                            if (RealPositionService.TryGetByIndex(index, out position))
                            {
                                if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                                {
                                    position.StoreState();
                                    tempQuantity = position.Quantity;

                                    hasPosition = true;
                                    multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;

                                    MarketPosition reversedMarketPosition = MarketPosition.Flat;

                                    if (position.MarketPosition == MarketPosition.Long)
                                        reversedMarketPosition = MarketPosition.Short;
                                    else
                                        reversedMarketPosition = MarketPosition.Long;

                                    if (CancelPositionTPSLOrders("TPSLRefresh-Rev", attachedInstrument, ConvertMarketPositionToSLOrderAction(reversedMarketPosition))) return hasPosition; //exit very early

                                    hasProfitLocked = false;
                                    hasHitPriceTrigger = false;
                                    triggerStopLossPrice = 0;
                                    newStopLossPrice = 0;
                                    stopLossOrderCount = 0;
                                    oldOrderQuantity = 0;

                                    oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);

                                    hasStopLoss = (oldStopLossPrice > 0);
                                    hasStopLossQuantityMismatch = oldOrderQuantity != tempQuantity;

                                    if (this.StopLossRefreshManagementEnabled)
                                    {
                                        if (hasStopLoss && !hasStopLossQuantityMismatch) validateAttachedPositionStopLossQuantity = false;

                                        if (!hasStopLoss && IsAutoPositionStopLossEnabled())
                                        {
                                            if (DebugLogLevel > 2) RealLogger.PrintOutput("refresh SL price=" + oldStopLossPrice.ToString() + " auto=" + (IsAutoPositionStopLossEnabled()).ToString() + " oldquan=" + oldOrderQuantity.ToString() + " orderType=" + orderType + " via " + signalName);
                                            newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, multiPositionAveragePrice, position.Quantity);

                                            if (blendedInstrumentHasPosition && blendedInstrumentPositionStopLossPrice > 0)
                                                newStopLossPrice = blendedInstrumentPositionStopLossPrice;

                                            if (IsDayOverMaxLossEnabled())
                                            {
                                                if (lastDayOverMaxLossLinePrice > 0)
                                                {
                                                    newStopLossPrice = FilterStopLossByPriceMax(position.MarketPosition, lastDayOverMaxLossLinePrice, newStopLossPrice);
                                                }
                                                else
                                                {
                                                    newStopLossPrice = 0;
                                                }
                                            }

                                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                                            if (hasValidNewStopLossPrice && !position.HasStateChanged() && !position.IsFlat() && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);

                                                    CreatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                                }

                                                if (hasStopLossQuantityMismatch)
                                                {
                                                    validateAttachedPositionStopLossQuantity = false;
                                                }
                                            }
                                        }
                                        else if (hasStopLoss && hasStopLossQuantityMismatch && validateAttachedPositionStopLossQuantity)
                                        {
                                            if (DebugLogLevel > 0) RealLogger.PrintOutput("SLQuanMismatch Current SL price=" + oldStopLossPrice.ToString() + " oldSLQuantity=" + oldOrderQuantity.ToString() + " PosQuantity=" + tempQuantity.ToString() + " SLOrderCount=" + stopLossOrderCount.ToString() + " attachedIn=" + attachedInstrument.FullName + " barPeriod=" + BarsPeriod.ToString() + " via " + signalName);
                                            if (this.StopLossRefreshOnVolumeChange)
                                            {
                                                newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, multiPositionAveragePrice, position.Quantity, oldStopLossPrice);
                                            }
                                            else
                                            {
                                                newStopLossPrice = oldStopLossPrice;
                                            }


                                            if (blendedInstrumentHasPosition && blendedInstrumentPositionStopLossPrice > 0)
                                                newStopLossPrice = blendedInstrumentPositionStopLossPrice;

                                            if (IsDayOverMaxLossEnabled() && lastDayOverMaxLossLinePrice > 0)
                                            {
                                                newStopLossPrice = FilterStopLossByPriceMax(position.MarketPosition, lastDayOverMaxLossLinePrice, newStopLossPrice);
                                            }

                                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasValidNewStopLossPrice
                                                && hasStopLossQuantityMismatch
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    bool hasMultipleStopLossOrders = (stopLossOrderCount > 1);

                                                    if (hasMultipleStopLossOrders)
                                                    {
                                                        ConsolidatePositionTPSLOrders("HandleTPSLRefresh", position.Instrument);
                                                    }

                                                    UpdatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);

                                                    if (hasStopLossQuantityMismatch)
                                                    {
                                                        validateAttachedPositionStopLossQuantity = false;
                                                    }
                                                }
                                            }
                                        }
                                        else if (hasStopLoss && IsDayOverMaxLossEnabled() && lastDayOverMaxLossLinePrice > 0 && !validateAttachedPositionStopLossQuantity)
                                        {
                                            newStopLossPrice = FilterStopLossByPriceMax(position.MarketPosition, lastDayOverMaxLossLinePrice, oldStopLossPrice);

                                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                                            hasStopLossPriceMismatch = oldStopLossPrice > 0 && newStopLossPrice > 0 && oldStopLossPrice != newStopLossPrice;

                                            if (hasStopLossPriceMismatch
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    UpdatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                                }
                                            }
                                        }
                                    }

                                    /*
                                    if ((BreakEvenAutoTriggerTicks > 0 || BreakEvenAutoTriggerATRMultiplier > 0
                                        || currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail
                                        || currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail
                                        || currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
                                        && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled)
                                    */
                                    if (currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled && !IsHODLEnabled())
                                    {
                                        signalName = "AutoBreakEven";
                                        if (hasStopLoss)
                                        {
                                            if (position.MarketPosition == MarketPosition.Long)
                                            {
                                                if (oldStopLossPrice > multiPositionAveragePrice)
                                                {
                                                    hasProfitLocked = true;
                                                }

                                                if (BreakEvenAutoTriggerTicks > 0 || BreakEvenAutoTriggerATRMultiplier > 0)
                                                {
                                                    triggerStopLossPrice = GetTriggerBreakEvenStopLossPrice(position.MarketPosition, multiPositionAveragePrice);

                                                    double bidPrice = RealInstrumentService.GetBidPrice(position.Instrument);
                                                    if (triggerStopLossPrice <= bidPrice)
                                                    {
                                                        hasHitPriceTrigger = true;
                                                    }
                                                }
                                            }
                                            else if (position.MarketPosition == MarketPosition.Short)
                                            {
                                                if (oldStopLossPrice < multiPositionAveragePrice)
                                                {
                                                    hasProfitLocked = true;
                                                }

                                                if (BreakEvenAutoTriggerTicks > 0 || BreakEvenAutoTriggerATRMultiplier > 0)
                                                {
                                                    triggerStopLossPrice = GetTriggerBreakEvenStopLossPrice(position.MarketPosition, multiPositionAveragePrice);

                                                    double askPrice = RealInstrumentService.GetAskPrice(position.Instrument);
                                                    if (triggerStopLossPrice >= askPrice)
                                                    {
                                                        hasHitPriceTrigger = true;
                                                    }
                                                }
                                            }
                                        }

                                        if (hasPosition
                                            && hasStopLoss
                                            && !position.HasStateChanged()
                                            && !position.IsFlat()
                                            && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                        {
                                            TickHunterBreakEvenAutoTrailNowTypes localBreakEvenAutoTrailNowFlag = breakEvenAutoTrailNowFlag;

                                            bool waitForBreakEvenAutoTrailNowAfterPushFlag = WaitBreakEvenAutoTrailNowAfterProfit(position.Instrument,
                                                position.MarketPosition,
                                                position.AveragePrice);

                                            if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit && waitForBreakEvenAutoTrailNowAfterPushFlag)
                                            {
                                                localBreakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.Disabled;
                                            }

                                            if (!hasProfitLocked && hasHitPriceTrigger
                                                && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail
                                                && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperFlipTrail
                                                && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
                                            {
                                                if (DebugLogLevel > 0) RealLogger.PrintOutput("Auto BE hit trigger price of " + triggerStopLossPrice.ToString("N2") + " via " + signalName, PrintTo.OutputTab1, false);
                                                HandleBreakEvenPlus(signalName);
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            double entryPrice = CalculateTrailLowPrice(position.MarketPosition, false);

                                                            if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                            if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ProfilePeppy)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                {
                                                    AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                    double newProfileStopLossPrice = 0;

                                                    if (position.MarketPosition == MarketPosition.Long)
                                                    {
                                                        newProfileStopLossPrice = FilterSurgePriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging)
                                                            newProfileStopLossPrice = FilterGush1PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1)
                                                            newProfileStopLossPrice = FilterFlow1PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1 && !attachedInstrumentPositionFlowing1)
                                                            newProfileStopLossPrice = FilterFlow2PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1 && !attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2)
                                                            newProfileStopLossPrice = FilterFlow3PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1 && !attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2 && !attachedInstrumentPositionFlowing3)
                                                            newProfileStopLossPrice = FilterFlow4PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (newProfileStopLossPrice > 0 && newProfileStopLossPrice > oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, newProfileStopLossPrice);
                                                        }
                                                    }
                                                    else if (position.MarketPosition == MarketPosition.Short)
                                                    {
                                                        newProfileStopLossPrice = FilterSurgePriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging)
                                                            newProfileStopLossPrice = FilterGush1PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1)
                                                            newProfileStopLossPrice = FilterFlow1PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1 && !attachedInstrumentPositionFlowing1)
                                                            newProfileStopLossPrice = FilterFlow2PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1 && !attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2)
                                                            newProfileStopLossPrice = FilterFlow3PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (!attachedInstrumentPositionCreeperSurging && !attachedInstrumentPositionCreeperGushing1 && !attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2 && !attachedInstrumentPositionFlowing3)
                                                            newProfileStopLossPrice = FilterFlow4PriceMovement(signalName, position.Instrument, position.MarketPosition, position.AveragePrice, oldStopLossPrice, newProfileStopLossPrice);

                                                        if (newProfileStopLossPrice > 0 && newProfileStopLossPrice < oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, newProfileStopLossPrice);
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ProfileSleepy)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                //if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();
                                                        /*
                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            double entryPrice = CalculateTrailLowPrice(position.MarketPosition, false);

                                                            if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                            if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        */
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailStingRay)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            bool recentNewHigh = stingRayRecentHigherHighValue == StingRayHigherHighCode;
                                                            bool buyCreeperContinuation = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2;

                                                            if (recentNewHigh && buyCreeperContinuation)
                                                            {
                                                                double entryPrice = GetStingRayLevel1Price(position.MarketPosition, AutoCloseAndTrailOffsetTicks);

                                                                if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                                {
                                                                    HandleStopLossPlus(signalName, entryPrice);
                                                                }
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            bool recentNewLow = stingRayRecentLowerLowValue == StingRayLowerLowCode;
                                                            bool sellCreeperContinuation = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2;

                                                            if (recentNewLow && sellCreeperContinuation)
                                                            {
                                                                double entryPrice = GetStingRayLevel1Price(position.MarketPosition, AutoCloseAndTrailOffsetTicks);

                                                                if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                                {
                                                                    HandleStopLossPlus(signalName, entryPrice);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMonster)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            double entryPrice = GetNextSnapPrice(position.MarketPosition, oldStopLossPrice, true);

                                                            if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            double entryPrice = GetNextSnapPrice(position.MarketPosition, oldStopLossPrice, true);

                                                            if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftMonster)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            double entryPrice = GetNextDriftLinePrice(position.MarketPosition, oldStopLossPrice, true);

                                                            if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            double entryPrice = GetNextDriftLinePrice(position.MarketPosition, oldStopLossPrice, true);

                                                            if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail
                                                || currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (position.MarketPosition == MarketPosition.Long)
                                                    {
                                                        double entryPrice = CalculateTrailLowPrice(position.MarketPosition);

                                                        if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                    else if (position.MarketPosition == MarketPosition.Short)
                                                    {
                                                        double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                        if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Enabled)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (position.MarketPosition == MarketPosition.Long)
                                                    {
                                                        double entryPrice = CalculateTrailLowPrice(position.MarketPosition, false);

                                                        if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                    else if (position.MarketPosition == MarketPosition.Short)
                                                    {
                                                        double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                        if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    newTakeProfitPrice = 0;
                                    takeProfitOrderCount = 0;
                                    oldOrderQuantity = 0;
                                    oldTakeProfitPrice = RealOrderService.GetTakeProfitInfo(position.Account, position.Instrument, ConvertMarketPositionToTPOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out takeProfitOrderCount);

                                    hasTakeProfit = (oldTakeProfitPrice > 0);
                                    hasTakeProfitQuantityMismatch = oldOrderQuantity != tempQuantity;

                                    if (TakeProfitRefreshManagementEnabled)
                                    {
                                        if (hasTakeProfit && !hasTakeProfitQuantityMismatch) validateAttachedPositionTakeProfitQuantity = false;

                                        if (!hasTakeProfit && IsAutoPositionTakeProfitEnabled())
                                        {
                                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Refresh tp price=" + oldTakeProfitPrice.ToString() + " auto=" + (IsAutoPositionTakeProfitEnabled()).ToString() + " oldquan=" + oldOrderQuantity.ToString() + " via " + signalName);
                                            newTakeProfitPrice = GetInitialTakeProfitPrice(position.MarketPosition, multiPositionAveragePrice);

                                            if (blendedInstrumentHasPosition && blendedInstrumentPositionTakeProfitPrice > 0)
                                                newTakeProfitPrice = blendedInstrumentPositionTakeProfitPrice;

                                            if (!IsHODLEnabled())
                                            {
                                                if (IsECATPEnabled())
                                                {
                                                    if (lastECATakeProfitLinePrice > 0)
                                                    {
                                                        newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastECATakeProfitLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                        newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncECATargetPrice, lastECATakeProfitLinePrice, newTakeProfitPrice);
                                                    }
                                                    else
                                                    {
                                                        newTakeProfitPrice = 0;
                                                    }
                                                }
                                                else
                                                {
                                                    if (IsBogeyTargetEnabled())
                                                    {
                                                        if (lastBogeyTargetLinePrice > 0)
                                                        {
                                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastBogeyTargetLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncBogeyTargetPrice, lastBogeyTargetLinePrice, newTakeProfitPrice);
                                                        }
                                                        else
                                                        {
                                                            newTakeProfitPrice = 0;
                                                        }
                                                    }
                                                }
                                            }

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasValidNewTakeProfitPrice = newTakeProfitPrice > 0;

                                            if (hasValidNewTakeProfitPrice
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New TP price=" + newTakeProfitPrice.ToString() + " via " + signalName);
                                                    CreatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                }

                                                if (hasTakeProfitQuantityMismatch)
                                                {
                                                    validateAttachedPositionTakeProfitQuantity = false;
                                                }
                                            }
                                        }
                                        else if (hasTakeProfit && hasTakeProfitQuantityMismatch && validateAttachedPositionTakeProfitQuantity)
                                        {
                                            if (DebugLogLevel > 0) RealLogger.PrintOutput("TPQuanMismatch Current TP price=" + oldTakeProfitPrice.ToString() + " oldTPQuantity=" + oldOrderQuantity.ToString() + " PosQuantity=" + tempQuantity.ToString() + " TPOrderCount=" + takeProfitOrderCount.ToString() + " attachedIn=" + attachedInstrument.FullName + " barPeriod=" + BarsPeriod.ToString() + " via " + signalName);
                                            //RealLogger.PrintOutput("Current SL price=" + oldStopLossPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString());

                                            newTakeProfitPrice = oldTakeProfitPrice;

                                            if (blendedInstrumentHasPosition && blendedInstrumentPositionTakeProfitPrice > 0)
                                                newTakeProfitPrice = blendedInstrumentPositionTakeProfitPrice;

                                            if (!IsHODLEnabled())
                                            {
                                                if (IsECATPEnabled())
                                                {
                                                    if (lastECATakeProfitLinePrice > 0)
                                                    {
                                                        newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastECATakeProfitLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                        newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncECATargetPrice, lastECATakeProfitLinePrice, newTakeProfitPrice);
                                                    }
                                                }
                                                else
                                                {
                                                    if (IsBogeyTargetEnabled())
                                                    {
                                                        if (lastBogeyTargetLinePrice > 0)
                                                        {
                                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastBogeyTargetLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncBogeyTargetPrice, lastBogeyTargetLinePrice, newTakeProfitPrice);
                                                        }
                                                    }
                                                }
                                            }

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasValidNewTakeProfitPrice = newTakeProfitPrice > 0;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasValidNewTakeProfitPrice
                                                && hasTakeProfitQuantityMismatch
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    bool hasMultipleTakeProfitOrders = (takeProfitOrderCount > 1);

                                                    if (hasMultipleTakeProfitOrders)
                                                    {
                                                        ConsolidatePositionTPSLOrders("HandleTPSLRefresh", position.Instrument);
                                                    }

                                                    UpdatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);

                                                    if (hasTakeProfitQuantityMismatch)
                                                    {
                                                        validateAttachedPositionTakeProfitQuantity = false;
                                                    }
                                                }
                                            }
                                        }
                                        else if (hasTakeProfit
                                            && IsBogeyTargetEnabled()
                                            && lastBogeyTargetLinePrice > 0
                                            && !IsECATPEnabled()
                                            && !validateAttachedPositionTakeProfitQuantity
                                            && !IsHODLEnabled())
                                        {
                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastBogeyTargetLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncBogeyTargetPrice, lastBogeyTargetLinePrice, newTakeProfitPrice);

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasTakeProfitPriceMismatch = oldTakeProfitPrice > 0 && newTakeProfitPrice > 0 && oldTakeProfitPrice != newTakeProfitPrice;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasTakeProfitPriceMismatch && !position.HasStateChanged() && !position.IsFlat() && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    UpdatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                }
                                            }
                                        }
                                        else if (hasTakeProfit
                                            && IsECATPEnabled()
                                            && lastECATakeProfitLinePrice > 0
                                            && !validateAttachedPositionTakeProfitQuantity
                                            && !IsHODLEnabled())
                                        {
                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastECATakeProfitLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncECATargetPrice, lastECATakeProfitLinePrice, newTakeProfitPrice);

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasTakeProfitPriceMismatch = oldTakeProfitPrice > 0 && newTakeProfitPrice > 0 && oldTakeProfitPrice != newTakeProfitPrice;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasTakeProfitPriceMismatch && !position.HasStateChanged() && !position.IsFlat() && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    UpdatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                }
                                            }
                                        }
                                    }

                                    //attachedInstrumentHasPosition = true;
                                    //attachedInstrumentMarketPosition = position.MarketPosition;
                                    //attachedInstrumentPositionQuantity = tempQuantity;
                                    //attachedInstrumentPositionPrice = position.AveragePrice;
                                    attachedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                                    attachedInstrumentPositionTakeProfitPrice = (newTakeProfitPrice == 0) ? oldTakeProfitPrice : newTakeProfitPrice;
                                    attachedInstrumentHasChanged = true;
                                    attachedInstrumentPositionPnL = GetPositionProfit(position);

                                    //riskInfoMarketPosition = position.MarketPosition;
                                    //riskInfoQuantity = tempQuantity;
                                    //riskInfoPositionPrice = position.AveragePrice;
                                    riskInfoHasChanged = true;

                                    //dayOverMaxLossMarketPosition = position.MarketPosition;
                                    //dayOverMaxLossPositionQuantity = tempQuantity;
                                    //dayOverMaxLossPositionPrice = position.AveragePrice;
                                    dayOverMaxLossHasChanged = true;

                                    //bogeyTargetMarketPosition = position.MarketPosition;
                                    //bogeyTargetPositionQuantity = tempQuantity;
                                    //bogeyTargetPositionPrice = position.AveragePrice;
                                    bogeyTargetHasChanged = true;

                                    //dayOverAccountBalanceFloorMarketPosition = position.MarketPosition;
                                    //dayOverAccountBalanceFloorPositionQuantity = tempQuantity;
                                    //dayOverAccountBalanceFloorPositionPrice = position.AveragePrice;
                                    dayOverAccountBalanceFloorHasChanged = true;

                                    //ecaTakeProfitMarketPosition = position.MarketPosition;
                                    //ecaTakeProfitPositionQuantity = tempQuantity;
                                    //ecaTakeProfitPositionPrice = position.AveragePrice;
                                    ecaTakeProfitHasChanged = true;

                                    //averagePriceMarketPosition = position.MarketPosition;
                                    //averagePricePositionQuantity = tempQuantity;
                                    //averagePricePositionPrice = position.AveragePrice;
                                    averagePriceHasChanged = true;

                                    //break; //only one postion per instrument so exit early
                                }
                                else if (IsBlendedInstrumentEnabled() && RealPositionService.IsValidPosition(position, blendedInstrument) && position.IsValid)
                                {
                                    position.StoreState();
                                    tempQuantity = position.Quantity;

                                    hasPosition = true;
                                    multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;

                                    MarketPosition reversedMarketPosition = MarketPosition.Flat;

                                    if (position.MarketPosition == MarketPosition.Long)
                                        reversedMarketPosition = MarketPosition.Short;
                                    else
                                        reversedMarketPosition = MarketPosition.Long;

                                    if (CancelPositionTPSLOrders("TPSLRefresh-Rev", blendedInstrument, ConvertMarketPositionToSLOrderAction(reversedMarketPosition))) return hasPosition; //exit very early

                                    hasProfitLocked = false;
                                    hasHitPriceTrigger = false;
                                    triggerStopLossPrice = 0;
                                    newStopLossPrice = 0;
                                    stopLossOrderCount = 0;
                                    oldOrderQuantity = 0;

                                    oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);

                                    hasStopLoss = (oldStopLossPrice > 0);
                                    hasStopLossQuantityMismatch = oldOrderQuantity != tempQuantity;

                                    if (this.StopLossRefreshManagementEnabled)
                                    {
                                        if (hasStopLoss && !hasStopLossQuantityMismatch) validateBlendedPositionStopLossQuantity = false;

                                        if (!hasStopLoss && IsAutoPositionStopLossEnabled())
                                        {
                                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Refresh SL price=" + oldStopLossPrice.ToString() + " auto=" + (IsAutoPositionStopLossEnabled()).ToString() + " oldquan=" + oldOrderQuantity.ToString() + " orderType=" + orderType + " via " + signalName);
                                            newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, position.AveragePrice, position.Quantity);

                                            if (attachedInstrumentHasPosition && attachedInstrumentPositionStopLossPrice > 0)
                                                newStopLossPrice = attachedInstrumentPositionStopLossPrice;

                                            if (IsDayOverMaxLossEnabled())
                                            {
                                                if (lastDayOverMaxLossLinePrice > 0)
                                                {
                                                    newStopLossPrice = FilterStopLossByPriceMax(position.MarketPosition, lastDayOverMaxLossLinePrice, newStopLossPrice);
                                                }
                                                else
                                                {
                                                    newStopLossPrice = 0;
                                                }
                                            }

                                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                                            if (hasValidNewStopLossPrice && !position.HasStateChanged() && !position.IsFlat() && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New SL price=" + newStopLossPrice.ToString() + " via " + signalName);
                                                    CreatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                                }

                                                if (hasStopLossQuantityMismatch)
                                                {
                                                    validateBlendedPositionStopLossQuantity = false;
                                                }
                                            }

                                        }
                                        else if (hasStopLoss && hasStopLossQuantityMismatch && validateBlendedPositionStopLossQuantity)
                                        {
                                            if (DebugLogLevel > 0) RealLogger.PrintOutput("SLQuanMismatch Current SL price=" + oldStopLossPrice.ToString() + " oldSLQuantity=" + oldOrderQuantity.ToString() + " PosQuantity=" + tempQuantity.ToString() + " SLOrderCount=" + stopLossOrderCount.ToString() + " attachedIn=" + attachedInstrument.FullName + " barPeriod=" + BarsPeriod.ToString() + " via " + signalName);
                                            if (this.StopLossRefreshOnVolumeChange)
                                            {
                                                newStopLossPrice = GetInitialStopLossPrice(position.Instrument, position.MarketPosition, position.AveragePrice, position.Quantity, oldStopLossPrice);
                                            }
                                            else
                                            {
                                                newStopLossPrice = oldStopLossPrice;
                                            }

                                            if (IsDayOverMaxLossEnabled() && lastDayOverMaxLossLinePrice > 0)
                                            {
                                                newStopLossPrice = FilterStopLossByPriceMax(position.MarketPosition, lastDayOverMaxLossLinePrice, newStopLossPrice);
                                            }

                                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                                            hasValidNewStopLossPrice = newStopLossPrice > 0;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasValidNewStopLossPrice
                                                && hasStopLossQuantityMismatch
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    bool hasMultipleStopLossOrders = (stopLossOrderCount > 1);

                                                    if (hasMultipleStopLossOrders)
                                                    {
                                                        ConsolidatePositionTPSLOrders("HandleTPSLRefresh", position.Instrument);
                                                    }

                                                    UpdatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);

                                                    if (hasStopLossQuantityMismatch)
                                                    {
                                                        validateBlendedPositionStopLossQuantity = false;
                                                    }
                                                }
                                            }
                                        }
                                        else if (hasStopLoss && IsDayOverMaxLossEnabled() && lastDayOverMaxLossLinePrice > 0 && !validateBlendedPositionStopLossQuantity)
                                        {
                                            newStopLossPrice = FilterStopLossByPriceMax(position.MarketPosition, lastDayOverMaxLossLinePrice, newStopLossPrice);

                                            newStopLossPrice = FilterStopLossByMarketPrice(position.Instrument, position.MarketPosition, newStopLossPrice);

                                            hasStopLossPriceMismatch = oldStopLossPrice > 0 && newStopLossPrice > 0 && oldStopLossPrice != newStopLossPrice;

                                            if (hasStopLossPriceMismatch && !position.HasStateChanged() && !position.IsFlat() && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToSLOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidStopLossPrice(position.Instrument, orderAction, newStopLossPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    UpdatePositionStopLoss(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newStopLossPrice);
                                                }
                                            }

                                        }
                                    }

                                    /*
                                    if ((BreakEvenAutoTriggerTicks > 0 || BreakEvenAutoTriggerATRMultiplier > 0
                                        || currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail
                                        || currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail
                                        || currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
                                        && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled)
                                        */
                                    if (currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled
                                        && !IsHODLEnabled())
                                    {
                                        if (hasStopLoss)
                                        {
                                            if (position.MarketPosition == MarketPosition.Long)
                                            {
                                                if (oldStopLossPrice > position.AveragePrice)
                                                {
                                                    hasProfitLocked = true;
                                                }

                                                if (BreakEvenAutoTriggerTicks > 0 || BreakEvenAutoTriggerATRMultiplier > 0)
                                                {
                                                    triggerStopLossPrice = GetTriggerBreakEvenStopLossPrice(position.MarketPosition, position.AveragePrice);

                                                    double bidPrice = RealInstrumentService.GetBidPrice(position.Instrument);
                                                    if (triggerStopLossPrice <= bidPrice)
                                                    {
                                                        hasHitPriceTrigger = true;
                                                    }
                                                }
                                            }
                                            else if (position.MarketPosition == MarketPosition.Short)
                                            {
                                                if (oldStopLossPrice < position.AveragePrice)
                                                {
                                                    hasProfitLocked = true;
                                                }

                                                if (BreakEvenAutoTriggerTicks > 0 || BreakEvenAutoTriggerATRMultiplier > 0)
                                                {
                                                    triggerStopLossPrice = GetTriggerBreakEvenStopLossPrice(position.MarketPosition, position.AveragePrice);

                                                    double askPrice = RealInstrumentService.GetAskPrice(position.Instrument);
                                                    if (triggerStopLossPrice >= askPrice)
                                                    {
                                                        hasHitPriceTrigger = true;
                                                    }
                                                }
                                            }
                                        }

                                        if (hasPosition
                                            && hasStopLoss
                                            && !position.HasStateChanged()
                                            && !position.IsFlat()
                                            && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                        {
                                            TickHunterBreakEvenAutoTrailNowTypes localBreakEvenAutoTrailNowFlag = breakEvenAutoTrailNowFlag;

                                            bool waitForBreakEvenAutoTrailAfterProfitFlag = WaitBreakEvenAutoTrailNowAfterProfit(position.Instrument,
                                                position.MarketPosition,
                                                position.AveragePrice);

                                            if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit
                                                && waitForBreakEvenAutoTrailAfterProfitFlag)
                                            {
                                                localBreakEvenAutoTrailNowFlag = TickHunterBreakEvenAutoTrailNowTypes.Disabled;
                                            }

                                            if (!hasProfitLocked && hasHitPriceTrigger
                                                && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail
                                                && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.CreeperFlipTrail
                                                && currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
                                            {
                                                if (DebugLogLevel > 0) RealLogger.PrintOutput("Auto BE hit trigger price of " + triggerStopLossPrice.ToString("N2") + " via " + signalName, PrintTo.OutputTab1, false);
                                                HandleBreakEvenPlus(signalName);
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (AutoBreakEvenRunOncePerBar.IsFirstRunThisBar)
                                                    {
                                                        AutoBreakEvenRunOncePerBar.SetRunCompletedThisBar();

                                                        if (position.MarketPosition == MarketPosition.Long)
                                                        {
                                                            double entryPrice = CalculateTrailLowPrice(position.MarketPosition, false);

                                                            if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                        else if (position.MarketPosition == MarketPosition.Short)
                                                        {
                                                            double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                            if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                            {
                                                                HandleStopLossPlus(signalName, entryPrice);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail
                                                || currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (position.MarketPosition == MarketPosition.Long)
                                                    {
                                                        double entryPrice = CalculateTrailLowPrice(position.MarketPosition);

                                                        if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                    else if (position.MarketPosition == MarketPosition.Short)
                                                    {
                                                        double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                        if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                }
                                            }
                                            else if (currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Enabled)
                                            {
                                                signalName = currentBreakEvenAutoStatus.ToString();

                                                if (hasProfitLocked || localBreakEvenAutoTrailNowFlag != TickHunterBreakEvenAutoTrailNowTypes.Disabled)
                                                {
                                                    if (position.MarketPosition == MarketPosition.Long)
                                                    {
                                                        double entryPrice = CalculateTrailLowPrice(position.MarketPosition, false);

                                                        if (entryPrice != 0 && entryPrice > oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                    else if (position.MarketPosition == MarketPosition.Short)
                                                    {
                                                        double entryPrice = CalculateTrailHighPrice(position.MarketPosition);

                                                        if (entryPrice != 0 && entryPrice < oldStopLossPrice)
                                                        {
                                                            HandleStopLossPlus(signalName, entryPrice);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    newTakeProfitPrice = 0;
                                    takeProfitOrderCount = 0;
                                    oldOrderQuantity = 0;
                                    oldTakeProfitPrice = RealOrderService.GetTakeProfitInfo(position.Account, position.Instrument, ConvertMarketPositionToTPOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out takeProfitOrderCount);

                                    hasTakeProfit = (oldTakeProfitPrice > 0);
                                    hasTakeProfitQuantityMismatch = oldOrderQuantity != tempQuantity;

                                    if (TakeProfitRefreshManagementEnabled)
                                    {
                                        if (hasTakeProfit && !hasTakeProfitQuantityMismatch) validateBlendedPositionTakeProfitQuantity = false;

                                        if (!hasTakeProfit && IsAutoPositionTakeProfitEnabled())
                                        {
                                            if (DebugLogLevel > 2) RealLogger.PrintOutput("Refresh tp price=" + oldTakeProfitPrice.ToString() + " auto=" + (IsAutoPositionTakeProfitEnabled()).ToString() + " oldquan=" + oldOrderQuantity.ToString() + " via " + signalName);
                                            newTakeProfitPrice = GetInitialTakeProfitPrice(position.MarketPosition, position.AveragePrice);

                                            if (attachedInstrumentHasPosition && attachedInstrumentPositionTakeProfitPrice > 0)
                                                newTakeProfitPrice = attachedInstrumentPositionTakeProfitPrice;

                                            if (!IsHODLEnabled())
                                            {
                                                if (IsECATPEnabled())
                                                {
                                                    if (lastECATakeProfitLinePrice > 0)
                                                    {
                                                        newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastECATakeProfitLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                        newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncECATargetPrice, lastECATakeProfitLinePrice, newTakeProfitPrice);
                                                    }
                                                    else
                                                    {
                                                        newTakeProfitPrice = 0;
                                                    }
                                                }
                                                else
                                                {
                                                    if (IsBogeyTargetEnabled())
                                                    {
                                                        if (lastBogeyTargetLinePrice > 0)
                                                        {
                                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastBogeyTargetLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncBogeyTargetPrice, lastBogeyTargetLinePrice, newTakeProfitPrice);
                                                        }
                                                        else
                                                        {
                                                            newTakeProfitPrice = 0;
                                                        }
                                                    }
                                                }
                                            }

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasValidNewTakeProfitPrice = newTakeProfitPrice > 0;

                                            if (hasValidNewTakeProfitPrice && !position.HasStateChanged() && !position.IsFlat() && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New TP price=" + newTakeProfitPrice.ToString() + " via " + signalName);
                                                    CreatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                }

                                                if (hasTakeProfitQuantityMismatch)
                                                {
                                                    validateBlendedPositionTakeProfitQuantity = false;
                                                }
                                            }
                                        }
                                        else if (hasTakeProfit && hasTakeProfitQuantityMismatch && validateBlendedPositionTakeProfitQuantity)
                                        {
                                            if (DebugLogLevel > 0) RealLogger.PrintOutput("TPQuanMismatch Current TP price=" + oldTakeProfitPrice.ToString() + " oldTPQuantity=" + oldOrderQuantity.ToString() + " PosQuantity=" + tempQuantity.ToString() + " TPOrderCount=" + takeProfitOrderCount.ToString() + " attachedIn=" + attachedInstrument.FullName + " barPeriod=" + BarsPeriod.ToString() + " via " + signalName);
                                            //RealLogger.PrintOutput("Current SL price=" + oldStopLossPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString());

                                            newTakeProfitPrice = oldTakeProfitPrice;

                                            if (!IsHODLEnabled())
                                            {
                                                if (IsECATPEnabled())
                                                {
                                                    if (lastECATakeProfitLinePrice > 0)
                                                    {
                                                        newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastECATakeProfitLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                        newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncECATargetPrice, lastECATakeProfitLinePrice, newTakeProfitPrice);
                                                    }
                                                }
                                                else
                                                {
                                                    if (IsBogeyTargetEnabled())
                                                    {
                                                        if (lastBogeyTargetLinePrice > 0)
                                                        {
                                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastBogeyTargetLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncBogeyTargetPrice, lastBogeyTargetLinePrice, newTakeProfitPrice);
                                                        }
                                                    }
                                                }
                                            }

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasValidNewTakeProfitPrice = newTakeProfitPrice > 0;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasValidNewTakeProfitPrice
                                                && hasTakeProfitQuantityMismatch
                                                && !position.HasStateChanged()
                                                && !position.IsFlat()
                                                && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    bool hasMultipleTakeProfitOrders = (takeProfitOrderCount > 1);

                                                    if (hasMultipleTakeProfitOrders)
                                                    {
                                                        ConsolidatePositionTPSLOrders("HandleTPSLRefresh", position.Instrument);
                                                    }

                                                    UpdatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);

                                                    if (hasTakeProfitQuantityMismatch)
                                                    {
                                                        validateBlendedPositionTakeProfitQuantity = false;
                                                    }
                                                }
                                            }

                                        }
                                        else if (hasTakeProfit
                                            && IsBogeyTargetEnabled()
                                            && lastBogeyTargetLinePrice > 0
                                            && !IsECATPEnabled()
                                            && !validateBlendedPositionTakeProfitQuantity
                                            && !IsHODLEnabled())
                                        {
                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastBogeyTargetLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncBogeyTargetPrice, lastBogeyTargetLinePrice, newTakeProfitPrice);

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasTakeProfitPriceMismatch = oldTakeProfitPrice > 0 && newTakeProfitPrice > 0 && oldTakeProfitPrice != newTakeProfitPrice;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasTakeProfitPriceMismatch && !position.HasStateChanged() && !position.IsFlat() && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    UpdatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                }
                                            }
                                        }
                                        else if (hasTakeProfit
                                            && IsECATPEnabled()
                                            && lastECATakeProfitLinePrice > 0
                                            && !validateBlendedPositionTakeProfitQuantity
                                            && !IsHODLEnabled())
                                        {
                                            newTakeProfitPrice = FilterTakeProfitByPriceMax(position.MarketPosition, lastECATakeProfitLinePrice, oldTakeProfitPrice, newTakeProfitPrice);
                                            newTakeProfitPrice = FilterTakeProfitByForceSync(TakeProfitSyncECATargetPrice, lastECATakeProfitLinePrice, newTakeProfitPrice);

                                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                                            hasTakeProfitPriceMismatch = oldTakeProfitPrice > 0 && newTakeProfitPrice > 0 && oldTakeProfitPrice != newTakeProfitPrice;

                                            //RealLogger.PrintOutput("Updated SL price=" + newStopLossPrice.ToString() + " old=" + oldStopLossPrice.ToString());
                                            if (hasTakeProfitPriceMismatch && !position.HasStateChanged() && !position.IsFlat() && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                                if (isPriceValid)
                                                {
                                                    UpdatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                                }
                                            }
                                        }
                                    }

                                    //blendedInstrumentHasPosition = true;
                                    //blendedInstrumentMarketPosition = position.MarketPosition;
                                    //blendedInstrumentPositionQuantity = position.Quantity;
                                    //blendedInstrumentPositionPrice = position.AveragePrice;
                                    blendedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                                    blendedInstrumentPositionTakeProfitPrice = (newTakeProfitPrice == 0) ? oldTakeProfitPrice : newTakeProfitPrice;
                                    blendedInstrumentHasChanged = true;
                                }


                            }
                        }
                    }


                    if (IsAccountFlat(attachedInstrument) && RealOrderService.AreAllOrderUpdateCyclesComplete())
                    {
                        PositionCloseCleanUp(attachedInstrument);

                        /*
                        CancelPositionTPSLOrders("TPSLRefresh-All", attachedInstrument);
                        */
                    }


                    if ((IsBlendedInstrumentEnabled() && IsAccountFlat(blendedInstrument)) && RealOrderService.AreAllOrderUpdateCyclesComplete())
                    {
                        PositionCloseCleanUp(attachedInstrument);

                        /*
                        CancelPositionTPSLOrders("TPSLRefresh-All", blendedInstrument);

                        
                        ExitCloseAlertWindows();

                        blendedInstrumentHasPosition = false;
                        blendedInstrumentPositionCreeperCycleCount = 0;
                        blendedInstrumentPositionCreeperSurging = false;
                        blendedInstrumentMarketPosition = MarketPosition.Flat;
                        blendedInstrumentPositionPrice = 0;
                        blendedInstrumentPositionQuantity = 0;
                        blendedInstrumentPositionStopLossPrice = 0;
                        blendedInstrumentPositionTakeProfitPrice = 0;
                        blendedInstrumentHasChanged = true;

                        bogeyTargetHasChanged = true;

                        ecaTakeProfitHasChanged = true;

                        averagePriceHasChanged = true;
                        */
                    }
                }
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception calling HandleTPSLRefresh:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                throw;
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(RefreshTPSLLock);
            }


            return hasPosition;
        }

        private bool WaitBreakEvenAutoTrailNowAfterProfit(Instrument instrument, MarketPosition marketPosition, double positionAveragePrice)
        {
            bool waitBeforeTrailFlag = false;

            if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit)
            {
                if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1
                    || currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2
                    || currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                {
                    int offsetTicks = 0;
                    double maDL1Price = GetDriftLine1Price(marketPosition, offsetTicks);
                    double maDL2Price = GetDriftLine2Price(marketPosition, offsetTicks);
                    double maDL3Price = GetDriftLine3Price(marketPosition, offsetTicks);
                    double maBigPrice = Math.Max(Math.Max(maDL1Price, maDL2Price), maDL3Price);
                    double maLilPrice = Math.Min(Math.Min(maDL1Price, maDL2Price), maDL3Price);
                    const double MAMinATRMultiplier = 1.0;
                    double atrMinTicks = CalculateATRTicks(atrValue, MAMinATRMultiplier, attachedInstrumentTicksPerPoint);
                    bool maStackWideEnough = (maBigPrice - maLilPrice) > (atrMinTicks * attachedInstrumentTickSize);

                    if (marketPosition == MarketPosition.Long)
                    {
                        bool maStacked = maDL1Price > maDL2Price && maDL2Price > maDL3Price;
                        double maPrice = CalculateTrailMAPrice(marketPosition, offsetTicks);
                        double maPriceWithBETicks = maPrice + (BreakEvenInitialTicks * attachedInstrumentTickSize);
                        double positionAveragePriceWithBETicks = positionAveragePrice + (BreakEvenInitialTicks * attachedInstrumentTickSize);

                        if (maPrice > 0)
                        {
                            double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                            if (maStacked && maStackWideEnough && previous1CandleBullish && maPrice > positionAveragePriceWithBETicks && maPriceWithBETicks < previous1LowPrice && maPriceWithBETicks < bidPrice)
                            {
                                waitBeforeTrailFlag = false;
                            }
                            else
                            {
                                waitBeforeTrailFlag = true;
                            }
                        }
                        else
                        {
                            waitBeforeTrailFlag = true;
                        }
                    }
                    else if (marketPosition == MarketPosition.Short)
                    {
                        bool maStacked = maDL1Price < maDL2Price && maDL2Price < maDL3Price;
                        double maPrice = CalculateTrailMAPrice(marketPosition, offsetTicks);
                        double maPriceWithBETicks = maPrice - (BreakEvenInitialTicks * attachedInstrumentTickSize);
                        double positionAveragePriceWithBETicks = positionAveragePrice - (BreakEvenInitialTicks * attachedInstrumentTickSize);

                        if (maPrice > 0)
                        {
                            double askPrice = RealInstrumentService.GetAskPrice(instrument);

                            if (maStacked && maStackWideEnough && !previous1CandleBullish && maPrice < positionAveragePriceWithBETicks && maPriceWithBETicks > previous1HighPrice && maPriceWithBETicks > askPrice)
                            {
                                waitBeforeTrailFlag = false;
                            }
                            else
                            {
                                waitBeforeTrailFlag = true;
                            }
                        }
                        else
                        {
                            waitBeforeTrailFlag = true;
                        }
                    }
                }
                else
                {
                    int offsetTicks = 0;

                    if (marketPosition == MarketPosition.Long)
                    {
                        double maPrice = CalculateTrailLowPrice(marketPosition);
                        double maPriceWithBETicks = maPrice + (BreakEvenInitialTicks * attachedInstrumentTickSize);
                        double positionAveragePriceWithBETicks = positionAveragePrice + (BreakEvenInitialTicks * attachedInstrumentTickSize);

                        if (maPrice > 0)
                        {
                            double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                            if (maPrice > positionAveragePriceWithBETicks && maPriceWithBETicks < bidPrice)
                            {
                                waitBeforeTrailFlag = false;
                            }
                            else
                            {
                                waitBeforeTrailFlag = true;
                            }
                        }
                        else
                        {
                            waitBeforeTrailFlag = true;
                        }
                    }
                    else if (marketPosition == MarketPosition.Short)
                    {
                        double maPrice = CalculateTrailHighPrice(marketPosition);
                        double maPriceWithBETicks = maPrice - (BreakEvenInitialTicks * attachedInstrumentTickSize);
                        double positionAveragePriceWithBETicks = positionAveragePrice - (BreakEvenInitialTicks * attachedInstrumentTickSize);

                        if (maPrice > 0)
                        {
                            double askPrice = RealInstrumentService.GetAskPrice(instrument);

                            if (maPrice < positionAveragePriceWithBETicks && maPriceWithBETicks > askPrice)
                            {
                                waitBeforeTrailFlag = false;
                            }
                            else
                            {
                                waitBeforeTrailFlag = true;
                            }
                        }
                        else
                        {
                            waitBeforeTrailFlag = true;
                        }
                    }
                }
            }

            return waitBeforeTrailFlag;
        }

        private bool HandlePositionInfoRefresh(string signalName)
        {
            bool hasPosition = false;

            var lockTimeout = TimeSpan.FromMilliseconds(250);
            bool lockTaken = false;

            try
            {
                Monitor.TryEnter(RefreshPositionInfoLock, lockTimeout, ref lockTaken);

                if (lockTaken)
                {
                    if ((!IsAccountFlat(attachedInstrument) || (IsBlendedInstrumentEnabled() && !IsAccountFlat(blendedInstrument)))
                        && RealOrderService.AreAllOrderUpdateCyclesComplete())
                    {
                        double multiPositionAveragePrice = 0;
                        int positionCount = RealPositionService.PositionCount;

                        for (int index = 0; index < positionCount; index++)
                        {
                            RealPosition position = null;
                            if (RealPositionService.TryGetByIndex(index, out position))
                            {
                                if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                                {
                                    hasPosition = true;
                                    multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;

                                    attachedInstrumentHasPosition = true;

                                    if (attachedInstrumentPositionCreeperCycleCount == 0) attachedInstrumentPositionCreeperCycleCount = stingRayCreeperCycleCountValue;
                                    if (attachedInstrumentPositionBarCount == 0) attachedInstrumentPositionBarCount = currentBarCount;
                                    attachedInstrumentMarketPosition = position.MarketPosition;
                                    attachedInstrumentPositionQuantity = position.Quantity;
                                    attachedInstrumentPositionPrice = position.AveragePrice;
                                    //attachedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                                    //attachedInstrumentPositionTakeProfitPrice = (newTakeProfitPrice == 0) ? oldTakeProfitPrice : newTakeProfitPrice;
                                    attachedInstrumentHasChanged = true;

                                    riskInfoMarketPosition = position.MarketPosition;
                                    riskInfoQuantity = position.Quantity;
                                    riskInfoPositionPrice = position.AveragePrice;
                                    riskInfoHasChanged = true;

                                    profitInfoMarketPosition = position.MarketPosition;
                                    profitInfoQuantity = position.Quantity;
                                    profitInfoPositionPrice = position.AveragePrice;
                                    profitInfoHasChanged = true;

                                    dayOverMaxLossMarketPosition = position.MarketPosition;
                                    dayOverMaxLossPositionQuantity = position.Quantity;
                                    dayOverMaxLossPositionPrice = position.AveragePrice;
                                    dayOverMaxLossHasChanged = true;

                                    bogeyTargetMarketPosition = position.MarketPosition;
                                    bogeyTargetPositionQuantity = position.Quantity;
                                    bogeyTargetPositionPrice = position.AveragePrice;
                                    bogeyTargetHasChanged = true;

                                    dayOverAccountBalanceFloorMarketPosition = position.MarketPosition;
                                    dayOverAccountBalanceFloorPositionQuantity = position.Quantity;
                                    dayOverAccountBalanceFloorPositionPrice = position.AveragePrice;
                                    dayOverAccountBalanceFloorHasChanged = true;

                                    ecaTakeProfitMarketPosition = position.MarketPosition;
                                    ecaTakeProfitPositionQuantity = position.Quantity;
                                    ecaTakeProfitPositionPrice = position.AveragePrice;
                                    ecaTakeProfitHasChanged = true;

                                    averagePriceMarketPosition = position.MarketPosition;
                                    averagePricePositionQuantity = position.Quantity;
                                    averagePricePositionPrice = position.AveragePrice;
                                    averagePriceHasChanged = true;

                                    //break; //only one postion per instrument so exit early
                                }
                                else if (IsBlendedInstrumentEnabled() && RealPositionService.IsValidPosition(position, blendedInstrument) && position.IsValid)
                                {
                                    hasPosition = true;
                                    multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;

                                    blendedInstrumentHasPosition = true;
                                    if (blendedInstrumentPositionCreeperCycleCount == 0) blendedInstrumentPositionCreeperCycleCount = stingRayCreeperCycleCountValue;
                                    blendedInstrumentMarketPosition = position.MarketPosition;
                                    blendedInstrumentPositionQuantity = position.Quantity;
                                    blendedInstrumentPositionPrice = position.AveragePrice;
                                    //blendedInstrumentPositionStopLossPrice = (newStopLossPrice == 0) ? oldStopLossPrice : newStopLossPrice;
                                    //blendedInstrumentPositionTakeProfitPrice = (newTakeProfitPrice == 0) ? oldTakeProfitPrice : newTakeProfitPrice;
                                    blendedInstrumentHasChanged = true;
                                }
                            }
                        }
                    }

                    if (IsBlendedInstrumentEnabled())
                    {
                        if (attachedInstrumentHasChanged || blendedInstrumentHasChanged)
                        {
                            MarketPosition mixedInstrumentMarketPosition = (attachedInstrumentHasPosition) ? attachedInstrumentMarketPosition : blendedInstrumentMarketPosition;

                            double newWeightedAveragePrice = (attachedInstrumentHasPosition) ? attachedInstrumentPositionPrice : blendedInstrumentPositionPrice;
                            int mixedInstrumentQuantitySum = (attachedInstrumentHasPosition) ? attachedInstrumentPositionQuantity : blendedInstrumentPositionQuantity;

                            if (attachedInstrumentHasPosition && blendedInstrumentHasPosition)
                            {
                                int eminiQuantity = 0;
                                double eminiAveragePrice = 0;
                                int microQuantity = 0;
                                double microAveragePrice = 0;

                                if (attachedInstrumentIsEmini)
                                {
                                    microQuantity = blendedInstrumentPositionQuantity;
                                    microAveragePrice = blendedInstrumentPositionPrice;

                                    eminiQuantity = attachedInstrumentPositionQuantity * MICRO_TO_EMINI_MULTIPLIER;
                                    eminiAveragePrice = attachedInstrumentPositionPrice;
                                }
                                else
                                {
                                    microQuantity = attachedInstrumentPositionQuantity;
                                    microAveragePrice = attachedInstrumentPositionPrice;

                                    eminiQuantity = blendedInstrumentPositionQuantity * MICRO_TO_EMINI_MULTIPLIER;
                                    eminiAveragePrice = blendedInstrumentPositionPrice;
                                }

                                mixedInstrumentQuantitySum = microQuantity + eminiQuantity;
                                newWeightedAveragePrice = ((microAveragePrice * microQuantity) + (eminiAveragePrice * eminiQuantity)) / mixedInstrumentQuantitySum;
                            }
                            else if (attachedInstrumentHasPosition && !blendedInstrumentHasPosition)
                            {
                                if (attachedInstrumentIsEmini)
                                {
                                    mixedInstrumentQuantitySum = attachedInstrumentPositionQuantity * MICRO_TO_EMINI_MULTIPLIER;
                                }
                            }
                            else if (!attachedInstrumentHasPosition && blendedInstrumentHasPosition)
                            {
                                if (!attachedInstrumentIsEmini)
                                {
                                    mixedInstrumentQuantitySum = blendedInstrumentPositionQuantity * MICRO_TO_EMINI_MULTIPLIER;
                                }
                            }

                            riskInfoMarketPosition = mixedInstrumentMarketPosition;
                            riskInfoQuantity = mixedInstrumentQuantitySum;
                            riskInfoPositionPrice = newWeightedAveragePrice;
                            riskInfoHasChanged = true;

                            profitInfoMarketPosition = mixedInstrumentMarketPosition;
                            profitInfoQuantity = mixedInstrumentQuantitySum;
                            profitInfoPositionPrice = newWeightedAveragePrice;
                            profitInfoHasChanged = true;

                            dayOverMaxLossMarketPosition = mixedInstrumentMarketPosition;
                            dayOverMaxLossPositionQuantity = mixedInstrumentQuantitySum;
                            dayOverMaxLossPositionPrice = newWeightedAveragePrice;
                            dayOverMaxLossHasChanged = true;

                            dayOverAccountBalanceFloorMarketPosition = mixedInstrumentMarketPosition;
                            dayOverAccountBalanceFloorPositionQuantity = mixedInstrumentQuantitySum;
                            dayOverAccountBalanceFloorPositionPrice = newWeightedAveragePrice;
                            dayOverAccountBalanceFloorHasChanged = true;

                            bogeyTargetMarketPosition = mixedInstrumentMarketPosition;
                            bogeyTargetPositionQuantity = mixedInstrumentQuantitySum;
                            bogeyTargetPositionPrice = newWeightedAveragePrice;
                            bogeyTargetHasChanged = true;

                            averagePriceMarketPosition = mixedInstrumentMarketPosition;
                            averagePricePositionQuantity = mixedInstrumentQuantitySum;
                            averagePricePositionPrice = newWeightedAveragePrice;
                            averagePriceHasChanged = true;

                            ecaTakeProfitMarketPosition = mixedInstrumentMarketPosition;
                            ecaTakeProfitPositionQuantity = mixedInstrumentQuantitySum;
                            ecaTakeProfitPositionPrice = newWeightedAveragePrice;
                            ecaTakeProfitHasChanged = true;
                        }
                    }


                    if (IsAccountFlat(attachedInstrument) && RealOrderService.AreAllOrderUpdateCyclesComplete())
                    {
                        PositionCloseCleanUp(attachedInstrument);

                        /*
                        ExitCloseAlertWindows();

                        attachedInstrumentHasPosition = false;
                        attachedInstrumentPositionBarCount = 0;
                        attachedInstrumentPositionCreeperCycleCount = 0;
                        attachedInstrumentPositionCreeperSurging = false;
                        attachedInstrumentPositionCreeperGushing1 = false;
                        attachedInstrumentPositionFlowing1 = false;
                        attachedInstrumentPositionFlowing2 = false;
                        attachedInstrumentPositionFlowing3 = false;
                        attachedInstrumentPositionFlowing4 = false;
                        attachedInstrumentMarketPosition = MarketPosition.Flat;
                        attachedInstrumentPositionPrice = 0;
                        attachedInstrumentPositionQuantity = 0;
                        attachedInstrumentPositionStopLossPrice = 0;
                        attachedInstrumentPositionTakeProfitPrice = 0;
                        attachedInstrumentHasChanged = true;

                        riskInfoHasChanged = true;

                        profitInfoHasChanged = true;

                        dayOverMaxLossHasChanged = true;

                        bogeyTargetHasChanged = true;

                        dayOverAccountBalanceFloorHasChanged = true;

                        ecaTakeProfitHasChanged = true;

                        averagePriceHasChanged = true;
                        */
                    }

                    if ((IsBlendedInstrumentEnabled() && IsAccountFlat(blendedInstrument)) && RealOrderService.AreAllOrderUpdateCyclesComplete())
                    {
                        PositionCloseCleanUp(blendedInstrument);

                        /*
                        ExitCloseAlertWindows();

                        blendedInstrumentHasPosition = false;
                        blendedInstrumentPositionCreeperCycleCount = 0;
                        blendedInstrumentPositionCreeperSurging = false;
                        blendedInstrumentMarketPosition = MarketPosition.Flat;
                        blendedInstrumentPositionPrice = 0;
                        blendedInstrumentPositionQuantity = 0;
                        blendedInstrumentPositionStopLossPrice = 0;
                        blendedInstrumentPositionTakeProfitPrice = 0;
                        blendedInstrumentHasChanged = true;

                        bogeyTargetHasChanged = true;

                        ecaTakeProfitHasChanged = true;

                        averagePriceHasChanged = true;
                        */
                    }

                }
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception calling HandlePositionInfoRefresh:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                throw;
            }
            finally
            {
                if (lockTaken)
                    Monitor.Exit(RefreshPositionInfoLock);
            }


            return hasPosition;
        }
        //------

        private double FilterStopLossByPriceMax(MarketPosition marketPosition, double filterPrice, double newStopLossPrice)
        {
            if (filterPrice != 0)
            {
                if (marketPosition == MarketPosition.Long)
                {
                    if (newStopLossPrice != 0 && newStopLossPrice < filterPrice)
                    {
                        newStopLossPrice = filterPrice;
                    }
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    if (newStopLossPrice != 0 && newStopLossPrice > filterPrice)
                    {
                        newStopLossPrice = filterPrice;
                    }
                }
            }

            return newStopLossPrice;
        }

        private double FilterStopLossByMarketPrice(Instrument instrument, MarketPosition marketPosition, double newStopLossPrice)
        {
            if (newStopLossPrice != 0)
            {
                if (marketPosition == MarketPosition.Long)
                {
                    double bidPrice = RealInstrumentService.GetBidPrice(instrument);
                    double lastPrice = RealInstrumentService.GetLastPrice(instrument);
                    if (newStopLossPrice >= (Math.Min(bidPrice, lastPrice) - (attachedInstrumentTickSize * RefreshTPSLOffsetTicks)))
                    {
                        newStopLossPrice = 0;
                    }
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    double askPrice = RealInstrumentService.GetAskPrice(instrument);
                    double lastPrice = RealInstrumentService.GetLastPrice(instrument);
                    if (newStopLossPrice <= (Math.Max(askPrice, lastPrice) + (attachedInstrumentTickSize * RefreshTPSLOffsetTicks)))
                    {
                        newStopLossPrice = 0;
                    }
                }
            }

            return newStopLossPrice;
        }

        private double FilterTakeProfitByPriceMax(MarketPosition marketPosition, double filterPrice, double oldTakeProfitPrice, double newTakeProfitPrice)
        {
            if (filterPrice != 0)
            {
                if (marketPosition == MarketPosition.Long)
                {
                    if ((oldTakeProfitPrice != 0 && oldTakeProfitPrice > filterPrice)
                        || (newTakeProfitPrice != 0 && newTakeProfitPrice > filterPrice))
                    {
                        newTakeProfitPrice = filterPrice;
                    }
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    if ((oldTakeProfitPrice != 0 && oldTakeProfitPrice < filterPrice)
                        || (newTakeProfitPrice != 0 && newTakeProfitPrice < filterPrice))
                    {
                        newTakeProfitPrice = filterPrice;
                    }
                }
            }

            return newTakeProfitPrice;
        }
        private double FilterTakeProfitByMarketPrice(Instrument instrument, MarketPosition marketPosition, double newTakeProfitPrice)
        {
            if (newTakeProfitPrice != 0)
            {
                if (marketPosition == MarketPosition.Long)
                {
                    double askPrice = RealInstrumentService.GetAskPrice(instrument);
                    double lastPrice = RealInstrumentService.GetLastPrice(instrument);
                    if (newTakeProfitPrice <= (Math.Max(askPrice, lastPrice) + (attachedInstrumentTickSize * RefreshTPSLOffsetTicks)))
                    {
                        newTakeProfitPrice = 0;
                    }
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    double bidPrice = RealInstrumentService.GetBidPrice(instrument);
                    double lastPrice = RealInstrumentService.GetLastPrice(instrument);
                    if (newTakeProfitPrice >= (Math.Min(bidPrice, lastPrice) - (attachedInstrumentTickSize * RefreshTPSLOffsetTicks)))
                    {
                        newTakeProfitPrice = 0;
                    }
                }
            }

            return newTakeProfitPrice;
        }

        private double FilterTakeProfitByForceSync(bool applyForceSync, double forcePrice, double newTakeProfitPrice)
        {
            if (applyForceSync)
            {
                newTakeProfitPrice = forcePrice;
            }

            return newTakeProfitPrice;
        }

        private bool HandleTakeProfitPlus(string signalName, double overrideTakeProfitPrice = 0)
        {
            double oldTakeProfitPrice = 0;
            int oldOrderQuantity = 0;
            double newTakeProfitPrice = 0;
            bool positionFound = false;
            bool hasTakeProfit = false;
            bool hasValidNewTakeProfitPrice = false;
            bool hasTakeProfitPriceMismatch = false;
            int takeProfitOrderCount = 0;
            OrderType orderType = OrderType.Unknown;
            int tempQuantity = 0;
            bool isCtrlKeyDown = false;
            MarketPosition positionFoundMarketPosition = MarketPosition.Flat;
            double multiPositionAveragePrice = 0;
            bool attachedHasBeenProcessed = false;
            bool blendedHasBeenProcessed = false;
            double tempAttachedInstrumentPositionTakeProfitPrice = 0;
            double tempBlendedInstrumentPositionTakeProfitPrice = 0;

            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;
                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    //if (position.Instrument == attachedInstrument)
                    if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                    {
                        position.StoreState();
                        positionFound = true;
                        tempQuantity = position.Quantity;
                        newTakeProfitPrice = 0;
                        takeProfitOrderCount = 0;
                        positionFoundMarketPosition = position.MarketPosition;
                        multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;

                        isCtrlKeyDown = IsCtrlKeyDown();

                        if (isCtrlKeyDown && overrideTakeProfitPrice == 0) break;

                        oldTakeProfitPrice = RealOrderService.GetTakeProfitInfo(position.Account, position.Instrument, ConvertMarketPositionToTPOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out takeProfitOrderCount);
                        hasTakeProfit = oldTakeProfitPrice == 0;

                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Current TP price=" + oldTakeProfitPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString() + " position quantity=" + tempQuantity.ToString() + " via " + signalName);

                        if (hasTakeProfit)
                        {
                            newTakeProfitPrice = (overrideTakeProfitPrice != 0) ? overrideTakeProfitPrice : GetInitialTakeProfitPrice(position.MarketPosition, multiPositionAveragePrice);

                            if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionTakeProfitPrice > 0)
                                newTakeProfitPrice = tempBlendedInstrumentPositionTakeProfitPrice;

                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                            hasValidNewTakeProfitPrice = newTakeProfitPrice > 0;

                            if (hasValidNewTakeProfitPrice && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New TP price=" + newTakeProfitPrice.ToString() + " via " + signalName);
                                    CreatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                }
                            }
                        }
                        else
                        {
                            newTakeProfitPrice = (overrideTakeProfitPrice != 0) ? overrideTakeProfitPrice : GetTakeProfitPriceFromJumpTicks(position.MarketPosition, oldTakeProfitPrice, this.TakeProfitJumpTicks);

                            if (blendedInstrumentHasPosition && tempBlendedInstrumentPositionTakeProfitPrice > 0 && blendedHasBeenProcessed)
                                newTakeProfitPrice = tempBlendedInstrumentPositionTakeProfitPrice;

                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                            hasTakeProfitPriceMismatch = oldTakeProfitPrice > 0 && newTakeProfitPrice > 0 && oldTakeProfitPrice != newTakeProfitPrice;

                            if (hasTakeProfitPriceMismatch && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                if (isPriceValid)
                                {

                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated TP price=" + newTakeProfitPrice.ToString() + " old=" + oldTakeProfitPrice.ToString() + " via " + signalName);
                                    UpdatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, 0, newTakeProfitPrice);
                                }
                            }
                        }

                        attachedHasBeenProcessed = true;
                        tempAttachedInstrumentPositionTakeProfitPrice = (newTakeProfitPrice == 0) ? oldTakeProfitPrice : newTakeProfitPrice;
                        //break; //only one postion per instrument so exit early
                    }
                    else if (IsBlendedInstrumentEnabled() && RealPositionService.IsValidPosition(position, blendedInstrument) && position.IsValid)
                    {
                        position.StoreState();
                        positionFound = true;
                        tempQuantity = position.Quantity;
                        newTakeProfitPrice = 0;
                        takeProfitOrderCount = 0;
                        positionFoundMarketPosition = position.MarketPosition;
                        multiPositionAveragePrice = (lastAveragePriceLinePrice != 0) ? lastAveragePriceLinePrice : position.AveragePrice;

                        isCtrlKeyDown = IsCtrlKeyDown();

                        if (isCtrlKeyDown && overrideTakeProfitPrice == 0) break;

                        oldTakeProfitPrice = RealOrderService.GetTakeProfitInfo(position.Account, position.Instrument, ConvertMarketPositionToTPOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out takeProfitOrderCount);
                        hasTakeProfit = oldTakeProfitPrice == 0;

                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Current TP price=" + oldTakeProfitPrice.ToString() + " ticksize=" + attachedInstrumentTickSize.ToString() + " ticks/point=" + attachedInstrumentTicksPerPoint.ToString() + " position quantity=" + tempQuantity.ToString() + " via " + signalName);

                        if (hasTakeProfit)
                        {
                            newTakeProfitPrice = (overrideTakeProfitPrice != 0) ? overrideTakeProfitPrice : GetInitialTakeProfitPrice(position.MarketPosition, multiPositionAveragePrice);

                            if (attachedInstrumentHasPosition && tempAttachedInstrumentPositionTakeProfitPrice > 0)
                                newTakeProfitPrice = tempAttachedInstrumentPositionTakeProfitPrice;

                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                            hasValidNewTakeProfitPrice = newTakeProfitPrice > 0;

                            if (hasValidNewTakeProfitPrice && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                if (isPriceValid)
                                {
                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New TP price=" + newTakeProfitPrice.ToString() + " via " + signalName);
                                    CreatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, tempQuantity, newTakeProfitPrice);
                                }
                            }
                        }
                        else
                        {
                            newTakeProfitPrice = (overrideTakeProfitPrice != 0) ? overrideTakeProfitPrice : GetTakeProfitPriceFromJumpTicks(position.MarketPosition, oldTakeProfitPrice, this.TakeProfitJumpTicks);

                            if (attachedInstrumentHasPosition && tempAttachedInstrumentPositionTakeProfitPrice > 0 && attachedHasBeenProcessed)
                                newTakeProfitPrice = tempAttachedInstrumentPositionTakeProfitPrice;

                            newTakeProfitPrice = FilterTakeProfitByMarketPrice(position.Instrument, position.MarketPosition, newTakeProfitPrice);

                            hasTakeProfitPriceMismatch = oldTakeProfitPrice > 0 && newTakeProfitPrice > 0 && oldTakeProfitPrice != newTakeProfitPrice;

                            if (hasTakeProfitPriceMismatch && !position.HasStateChanged() && !position.IsFlat())
                            {
                                OrderAction orderAction = ConvertMarketPositionToTPOrderAction(position.MarketPosition);
                                double lastPrice = RealInstrumentService.GetLastPrice(position.Instrument);
                                bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(position.Instrument, orderAction, newTakeProfitPrice, lastPrice);

                                if (isPriceValid)
                                {

                                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Updated TP price=" + newTakeProfitPrice.ToString() + " old=" + oldTakeProfitPrice.ToString() + " via " + signalName);
                                    UpdatePositionTakeProfit(signalName, position.Instrument, orderAction, OrderEntry.Manual, 0, newTakeProfitPrice);
                                }
                            }
                        }

                        blendedHasBeenProcessed = true;
                        tempBlendedInstrumentPositionTakeProfitPrice = (newTakeProfitPrice == 0) ? oldTakeProfitPrice : newTakeProfitPrice;
                        //break; //only one postion per instrument so exit early
                    }
                }
            }

            if (positionFound && isCtrlKeyDown && overrideTakeProfitPrice == 0)
            {
                if (positionFoundMarketPosition == MarketPosition.Long)
                {
                    HandleSellSnap("HandleTakeProfitPlus");
                }
                else if (positionFoundMarketPosition == MarketPosition.Short)
                {
                    HandleBuySnap("HandleTakeProfitPlus");
                }
            }

            return positionFound;
        }

        private bool HandleSellSnap(string signalName)
        {
            double newSellSnapPrice = 0;
            bool positionFound = false;
            bool isShortPosition = false;
            bool orderFound = false;
            double oldStopLossPrice = 0;
            double takeProfitPrice = 0;
            int stopLossOrderCount = 0;
            OrderType orderType = OrderType.Unknown;

            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;
                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    //if (position.Instrument == attachedInstrument)
                    if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                    {
                        isShortPosition = (position.MarketPosition == MarketPosition.Short);
                        positionFound = true;

                        int oldOrderQuantity = 0;
                        stopLossOrderCount = 0;

                        oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);
                        int stopLossTicks = CalculateStopLossTicks(position.MarketPosition, position.AveragePrice, oldStopLossPrice, attachedInstrumentTickSize);
                        int stopLossMultipliedTicks = (int)(stopLossTicks * TakeProfitCtrlSLMultiplier);
                        takeProfitPrice = CalculateTakeProfitPrice(position.MarketPosition, position.AveragePrice, stopLossMultipliedTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

                        break;
                    }
                }
            }

            if (!isShortPosition && positionFound && CheckSnapPositionTPSL())
            {
                if (takeProfitPrice > 0)
                {
                    HandleTakeProfitPlus("SellSnap", takeProfitPrice);
                }
                positionFound = false;
            }
            else if (isShortPosition && positionFound && CheckSnapPositionTPSL())
            {
                TrailSellPositionStopLoss("SellSnap", true);
            }
            else if (!positionFound || !CheckSnapPositionTPSL())
            {
                orderFound = CancelPopDropOrders("SellSnap");

                if (!orderFound)
                {
                    newSellSnapPrice = CalculateTrailLowPrice(MarketPosition.Short, true);

                    double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                    if (newSellSnapPrice >= bidPrice)
                    {
                        newSellSnapPrice = 0;
                    }


                    if (newSellSnapPrice != 0)
                    {
                        if (DebugLogLevel > 2) RealLogger.PrintOutput("New Snap- price=" + newSellSnapPrice.ToString() + " via " + signalName);
                        int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                        CreateSellStop(signalName, attachedInstrument, OrderAction.SellShort, OrderEntry.Manual, autoEntryVolume, newSellSnapPrice);
                    }
                }

            }

            return positionFound;
        }

        private void TrailSellPositionStopLoss(string signalName, bool force1Bar = false)
        {
            double newEntryPrice = CalculateTrailHighPrice(MarketPosition.Short, force1Bar);

            double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
            double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);

            if (newEntryPrice <= (Math.Max(askPrice, lastPrice) + (attachedInstrumentTickSize * RefreshTPSLOffsetTicks)))
            {
                newEntryPrice = 0;
            }

            if (newEntryPrice != 0)
            {
                //if (DebugLogLevel > 2) RealLogger.PrintOutput("New Snap- price=" + newSellSnapPrice.ToString());

                HandleStopLossPlus(signalName, newEntryPrice);
            }
        }

        private void TrailBuyPositionStopLoss(string signalName, bool force1Bar = false)
        {
            double newEntryPrice = CalculateTrailLowPrice(MarketPosition.Long, force1Bar);

            double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
            double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);

            if (newEntryPrice >= (Math.Min(bidPrice, lastPrice) - (attachedInstrumentTickSize * RefreshTPSLOffsetTicks)))
            {
                newEntryPrice = 0;
            }

            if (newEntryPrice != 0)
            {
                //if (DebugLogLevel > 2) RealLogger.PrintOutput("New trail price=" + newEntryPrice.ToString());

                HandleStopLossPlus(signalName, newEntryPrice);
            }
        }

        private double CalculateTrailMAPrice(MarketPosition positionType, int offsetTicks)
        {
            double maPrice = 0;

            if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
                maPrice = GetSpeedLineFilterPrice(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                maPrice = GetRushLinePrice(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
                maPrice = GetMovingAverage1Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
                maPrice = GetMovingAverage2Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
                maPrice = GetMovingAverage3Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
                maPrice = GetMovingAverage4Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
                maPrice = GetDriftLine1Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
                maPrice = GetDriftLine2Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                maPrice = GetDriftLine3Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                maPrice = GetDriftLine4Price(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
                maPrice = GetRiver1EdgePrice(positionType, offsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
                maPrice = GetRiver5EdgePrice(positionType, offsetTicks);

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, maPrice);

            return normalizedPrice;
        }

        private double CalculateTrailLowPrice(MarketPosition positionType, bool force1Bar = false)
        {
            double entryPrice = 0;

            if (force1Bar || currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail1Bar)
                entryPrice = previous1LowPrice - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail2Bar)
                entryPrice = Math.Min(previous1LowPrice, previous2LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail3Bar)
                entryPrice = Math.Min(Math.Min(previous1LowPrice, previous2LowPrice), previous3LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail5Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(previous1LowPrice, previous2LowPrice), previous3LowPrice), previous4LowPrice), previous5LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMix)
            {
                bool lastTwoCandlesForward = previous1CandleBullish && previous2CandleBullish;
                bool lastTwoCandlesBackForwardPlusHigher = previous1CandleBullish && !previous2CandleBullish && previous1HighPrice >= previous2HighPrice;

                if (lastTwoCandlesForward || lastTwoCandlesBackForwardPlusHigher)
                {
                    entryPrice = previous1LowPrice - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else
                {
                    entryPrice = 0;
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
                entryPrice = GetSpeedLineFilterPrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                entryPrice = GetRushLinePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
                entryPrice = GetMovingAverage1Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
                entryPrice = GetMovingAverage2Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
                entryPrice = GetMovingAverage3Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
                entryPrice = GetMovingAverage4Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
                entryPrice = GetRiver1EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
                entryPrice = GetRiver5EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek1)
                entryPrice = GetCreek1EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek5)
                entryPrice = GetCreek5EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLine2)
                entryPrice = GetZipLine2Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLineDual)
            {
                entryPrice = Math.Min(GetZipLine1Price(positionType, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(positionType, AutoCloseAndTrailOffsetTicks));
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKLineDual)
            {
                if (autoPilotSetupZombieBuyContinuation1 && autoPilotSetupZombie2BuyContinuation1)
                {
                    entryPrice = Math.Min(GetKineticLine1Price(positionType, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(positionType, AutoCloseAndTrailOffsetTicks));
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKZ)
            {
                if (autoPilotSetupZombieBuyContinuation1 && autoPilotSetupZombie2BuyContinuation1)
                {
                    entryPrice = Math.Min(Math.Min(Math.Min(GetKineticLine1Price(positionType, AutoCloseAndTrailOffsetTicks),
                        GetKineticLine2Price(positionType, AutoCloseAndTrailOffsetTicks)),
                        GetZipLine1Price(positionType, AutoCloseAndTrailOffsetTicks)),
                        GetZipLine2Price(positionType, AutoCloseAndTrailOffsetTicks));
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                entryPrice = GetRushLinePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
                entryPrice = GetDriftLine1Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
                entryPrice = GetDriftLine2Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                entryPrice = GetDriftLine3Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                entryPrice = GetDriftLine4Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
            {
                bool buyZombieSetup = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                if (buyZombieSetup)
                {
                    entryPrice = CalculateSnapBarLowPrice(BreakEvenAutoZombieFlipResumeSnapType);
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail)
            {
                bool sellZombieSetupContinuation = autoPilotSetupZombieValue == ZombieSetupSellCode;
                bool sellCreeperSetupContinuation = (autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2);
                if (sellZombieSetupContinuation && sellCreeperSetupContinuation)
                {
                    entryPrice = CalculateSnapBarLowPrice(BreakEvenAutoCreeperFlipSnapType);
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
            {
                bool sellCreeperSetupContinuation = (autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2);
                if (sellCreeperSetupContinuation)
                {
                    entryPrice = CalculateSnapBarLowPrice(BreakEvenAutoCreeperFlipSnapType);
                }
            }


            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, entryPrice);

            return normalizedPrice;
        }

        private double CalculateTrailHighPrice(MarketPosition positionType, bool force1Bar = false)
        {
            double entryPrice = 0;

            if (force1Bar || currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail1Bar)
                entryPrice = previous1HighPrice + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail2Bar)
                entryPrice = Math.Max(previous1HighPrice, previous2HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail3Bar)
                entryPrice = Math.Max(Math.Max(previous1HighPrice, previous2HighPrice), previous3HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail5Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(previous1HighPrice, previous2HighPrice), previous3HighPrice), previous4HighPrice), previous5HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMix)
            {
                bool lastTwoCandlesForward = !previous1CandleBullish && !previous2CandleBullish;
                bool lastTwoCandlesBackForwardPlusLower = !previous1CandleBullish && previous2CandleBullish && previous1LowPrice <= previous2LowPrice;

                if (lastTwoCandlesForward || lastTwoCandlesBackForwardPlusLower)
                {
                    entryPrice = previous1HighPrice + (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else
                {
                    entryPrice = 0;
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
                entryPrice = GetSpeedLineFilterPrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                entryPrice = GetRushLinePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
                entryPrice = GetMovingAverage1Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
                entryPrice = GetMovingAverage2Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
                entryPrice = GetMovingAverage3Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
                entryPrice = GetMovingAverage4Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
                entryPrice = GetRiver1EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
                entryPrice = GetRiver5EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek1)
                entryPrice = GetCreek1EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek5)
                entryPrice = GetCreek5EdgePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLine2)
                entryPrice = GetZipLine2Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLineDual)
            {
                entryPrice = Math.Max(GetZipLine1Price(positionType, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(positionType, AutoCloseAndTrailOffsetTicks));
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKLineDual)
            {
                if (autoPilotSetupZombieSellContinuation1 && autoPilotSetupZombie2SellContinuation1)
                    entryPrice = Math.Max(GetKineticLine1Price(positionType, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(positionType, AutoCloseAndTrailOffsetTicks));
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKZ)
            {
                if (autoPilotSetupZombieSellContinuation1 && autoPilotSetupZombie2SellContinuation1)
                    entryPrice = Math.Max(Math.Max(Math.Max(GetKineticLine1Price(positionType, AutoCloseAndTrailOffsetTicks),
                        GetKineticLine2Price(positionType, AutoCloseAndTrailOffsetTicks)),
                        GetZipLine1Price(positionType, AutoCloseAndTrailOffsetTicks)),
                        GetZipLine2Price(positionType, AutoCloseAndTrailOffsetTicks));
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                entryPrice = GetRushLinePrice(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
                entryPrice = GetDriftLine1Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
                entryPrice = GetDriftLine2Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                entryPrice = GetDriftLine3Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                entryPrice = GetDriftLine4Price(positionType, AutoCloseAndTrailOffsetTicks);
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
            {
                bool sellZombieSetup = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
                if (sellZombieSetup)
                {
                    entryPrice = CalculateSnapBarHighPrice(BreakEvenAutoZombieFlipResumeSnapType);
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail)
            {
                bool buyZombieSetupContinuation = autoPilotSetupZombieValue == ZombieSetupBuyCode;
                bool buyCreeperSetupContinuation = (autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2);
                if (buyZombieSetupContinuation && buyCreeperSetupContinuation)
                {
                    entryPrice = CalculateSnapBarHighPrice(BreakEvenAutoCreeperFlipSnapType);
                }
            }
            else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
            {
                bool buyCreeperSetupContinuation = (autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2);
                if (buyCreeperSetupContinuation)
                {
                    entryPrice = CalculateSnapBarHighPrice(BreakEvenAutoCreeperFlipSnapType);
                }
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, entryPrice);

            return normalizedPrice;
        }

        private double CalculateSnapBarLowPrice(TickHunterStopLossSnapTypes stopLossSnapType)
        {
            double entryPrice = 0;

            if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap1Bar)
                entryPrice = previous1LowPrice - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap2Bar)
                entryPrice = Math.Min(previous1LowPrice, previous2LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap3Bar)
                entryPrice = Math.Min(Math.Min(previous1LowPrice, previous2LowPrice), previous3LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap4Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap5Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap6Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap7Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap8Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap9Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap10Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap11Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap12Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap13Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap14Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap15Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice),
                    previous15LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap16Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice),
                    previous15LowPrice),
                    previous16LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap17Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice),
                    previous15LowPrice),
                    previous16LowPrice),
                    previous17LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap18Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice),
                    previous15LowPrice),
                    previous16LowPrice),
                    previous17LowPrice),
                    previous18LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap19Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice),
                    previous15LowPrice),
                    previous16LowPrice),
                    previous17LowPrice),
                    previous18LowPrice),
                    previous19LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap20Bar)
                entryPrice = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(
                    previous1LowPrice,
                    previous2LowPrice),
                    previous3LowPrice),
                    previous4LowPrice),
                    previous5LowPrice),
                    previous6LowPrice),
                    previous7LowPrice),
                    previous8LowPrice),
                    previous9LowPrice),
                    previous10LowPrice),
                    previous11LowPrice),
                    previous12LowPrice),
                    previous13LowPrice),
                    previous14LowPrice),
                    previous15LowPrice),
                    previous16LowPrice),
                    previous17LowPrice),
                    previous18LowPrice),
                    previous19LowPrice),
                    previous20LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapSpeedLine)
                entryPrice = GetSpeedLineFilterPrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapRushLine)
                entryPrice = GetRushLinePrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel)
                entryPrice = (Math.Floor(snapPowerBoxLowerValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel10)
                entryPrice = (Math.Floor(snapPowerBoxLowerValue10 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel20)
                entryPrice = (Math.Floor(snapPowerBoxLowerValue20 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel30)
                entryPrice = (Math.Floor(snapPowerBoxLowerValue30 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel40)
                entryPrice = (Math.Floor(snapPowerBoxLowerValue40 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel50)
                entryPrice = (Math.Floor(snapPowerBoxLowerValue50 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapKeltnerInnerRing)
                entryPrice = GetKeltnerInnerRingPrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapRiver1)
                entryPrice = GetRiver1EdgePrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapRiver5)
                entryPrice = GetRiver5EdgePrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapCreek1)
                entryPrice = GetCreek1EdgePrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapCreek5)
                entryPrice = GetCreek5EdgePrice(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapZipLine1)
                entryPrice = GetZipLine1Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapZipLine2)
                entryPrice = GetZipLine2Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine1)
                entryPrice = GetDriftLine1Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine2)
                entryPrice = GetDriftLine2Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine3)
                entryPrice = GetDriftLine3Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine4)
                entryPrice = GetDriftLine4Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapKineticLine1)
                entryPrice = GetKineticLine1Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapKineticLine2)
                entryPrice = GetKineticLine2Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel1)
                entryPrice = GetStingRayLevel1Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel2)
                entryPrice = GetStingRayLevel2Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel3)
                entryPrice = GetStingRayLevel3Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel4)
                entryPrice = GetStingRayLevel4Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel5)
                entryPrice = GetStingRayLevel5Price(MarketPosition.Long, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayXLevel)
            {
                const int InitialStopLossOffsetTicks = 5;
                double stingRayLevel1Price = GetStingRayLevel1Price(MarketPosition.Long, InitialStopLossOffsetTicks);
                double stingRayLevel2Price = GetStingRayLevel1Price(MarketPosition.Long, InitialStopLossOffsetTicks);
                double driftLine4Price = GetDriftLine4Price(MarketPosition.Long, InitialStopLossOffsetTicks);

                const double minATRMultiplier = 2.0;
                double atrMinTicks = CalculateATRTicks(atrValue, minATRMultiplier, attachedInstrumentTicksPerPoint);
                double lowestStopLossPrice = stingRayLevel1Price - (atrMinTicks * attachedInstrumentTickSize);

                const double bigATRMultiplier = 4.0;
                double atrBigTicks = CalculateATRTicks(atrValue, bigATRMultiplier, attachedInstrumentTicksPerPoint);
                double bigStopLossPrice = previous1ClosePrice - (atrBigTicks * attachedInstrumentTickSize);


                //Print("*** DEBUG atr1=" + CalculateATRTicks(atrValue, 1, attachedInstrumentTicksPerPoint) + " atr2=" + CalculateATRTicks(atrValue, 2, attachedInstrumentTicksPerPoint) + " atr3=" + CalculateATRTicks(atrValue, 3, attachedInstrumentTicksPerPoint) + " atr4=" + CalculateATRTicks(atrValue, 4, attachedInstrumentTicksPerPoint));

                if (stingRayLevel1Price <= bigStopLossPrice)
                {
                    entryPrice = Math.Max(stingRayLevel1Price, driftLine4Price);
                }
                else if (stingRayLevel1Price < driftLine4Price)
                {
                    //Print("*** DEBUG 1 - stingRayLevel1Price=" + stingRayLevel1Price + " stingRayLevel2Price=" + stingRayLevel2Price + " driftLine4Price=" + driftLine4Price);
                    entryPrice = stingRayLevel1Price;
                }
                else if (stingRayLevel2Price >= lowestStopLossPrice && driftLine4Price >= lowestStopLossPrice)
                {
                    //Print("*** DEBUG 2 - stingRayLevel1Price=" + stingRayLevel1Price + " stingRayLevel2Price=" + stingRayLevel2Price + " driftLine4Price=" + driftLine4Price);
                    entryPrice = Math.Min(stingRayLevel2Price, driftLine4Price);
                }
                else if (stingRayLevel2Price >= lowestStopLossPrice)
                {
                    //Print("*** DEBUG 3 - stingRayLevel1Price=" + stingRayLevel1Price + " stingRayLevel2Price=" + stingRayLevel2Price + " driftLine4Price=" + driftLine4Price);
                    entryPrice = stingRayLevel2Price;
                }
                else if (driftLine4Price >= lowestStopLossPrice)
                {
                    //Print("*** DEBUG 4 - stingRayLevel1Price=" + stingRayLevel1Price + " stingRayLevel2Price=" + stingRayLevel2Price + " driftLine4Price=" + driftLine4Price);
                    entryPrice = driftLine4Price;
                }
                else
                {
                    //Print("*** DEBUG 5 - stingRayLevel1Price=" + stingRayLevel1Price + " stingRayLevel2Price=" + stingRayLevel2Price + " driftLine4Price=" + driftLine4Price);
                    entryPrice = stingRayLevel1Price;
                }
            }
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapProfilePeppy)
            {
                if (recentZombieBuyLowPrice != 0 && recentCreeperBuyLowPrice != 0)
                {
                    entryPrice = Math.Min(Math.Min(recentZombieBuyLowPrice, recentCreeperBuyLowPrice), previous1LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else if (recentZombieBuyLowPrice != 0)
                {
                    entryPrice = Math.Min(recentZombieBuyLowPrice, previous1LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);

                }
                else if (recentCreeperBuyLowPrice != 0)
                {
                    entryPrice = Math.Min(recentCreeperBuyLowPrice, previous1LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else
                {
                    entryPrice = previous1LowPrice - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
            }
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapProfileSleepy)
            {
                if (recentZombieBuyLowPrice != 0 && recentCreeperBuyLowPrice != 0)
                {
                    entryPrice = Math.Min(Math.Min(recentZombieBuyLowPrice, recentCreeperBuyLowPrice), previous1LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else if (recentZombieBuyLowPrice != 0)
                {
                    entryPrice = Math.Min(recentZombieBuyLowPrice, previous1LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);

                }
                else if (recentCreeperBuyLowPrice != 0)
                {
                    entryPrice = Math.Min(recentCreeperBuyLowPrice, previous1LowPrice) - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else
                {
                    entryPrice = previous1LowPrice - (attachedInstrumentTickSize * SnapOffsetTicks);
                }
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, entryPrice);

            return normalizedPrice;
        }

        private double CalculateSnapBarHighPrice(TickHunterStopLossSnapTypes stopLossSnapType)
        {
            double entryPrice = 0;

            if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap1Bar)
                entryPrice = previous1HighPrice + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap2Bar)
                entryPrice = Math.Max(previous1HighPrice, previous2HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap3Bar)
                entryPrice = Math.Max(Math.Max(previous1HighPrice, previous2HighPrice), previous3HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap4Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap5Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap6Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap7Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap8Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap9Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap10Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap11Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap12Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap13Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap14Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap15Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice),
                    previous15HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap16Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice),
                    previous15HighPrice),
                    previous16HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap17Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice),
                    previous15HighPrice),
                    previous16HighPrice),
                    previous17HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap18Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice),
                    previous15HighPrice),
                    previous16HighPrice),
                    previous17HighPrice),
                    previous18HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap19Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice),
                    previous15HighPrice),
                    previous16HighPrice),
                    previous17HighPrice),
                    previous18HighPrice),
                    previous19HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.Snap20Bar)
                entryPrice = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(
                    previous1HighPrice,
                    previous2HighPrice),
                    previous3HighPrice),
                    previous4HighPrice),
                    previous5HighPrice),
                    previous6HighPrice),
                    previous7HighPrice),
                    previous8HighPrice),
                    previous9HighPrice),
                    previous10HighPrice),
                    previous11HighPrice),
                    previous12HighPrice),
                    previous13HighPrice),
                    previous14HighPrice),
                    previous15HighPrice),
                    previous16HighPrice),
                    previous17HighPrice),
                    previous18HighPrice),
                    previous19HighPrice),
                    previous20HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapSpeedLine)
                entryPrice = GetSpeedLineFilterPrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapRushLine)
                entryPrice = GetRushLinePrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel)
                entryPrice = (Math.Ceiling(snapPowerBoxUpperValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel10)
                entryPrice = (Math.Ceiling(snapPowerBoxUpperValue10 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel20)
                entryPrice = (Math.Ceiling(snapPowerBoxUpperValue20 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel30)
                entryPrice = (Math.Ceiling(snapPowerBoxUpperValue30 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel40)
                entryPrice = (Math.Ceiling(snapPowerBoxUpperValue40 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapPBLevel50)
                entryPrice = (Math.Ceiling(snapPowerBoxUpperValue50 * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapKeltnerInnerRing)
                entryPrice = GetKeltnerInnerRingPrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapRiver1)
                entryPrice = GetRiver1EdgePrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapRiver5)
                entryPrice = GetRiver5EdgePrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapCreek1)
                entryPrice = GetCreek1EdgePrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapCreek5)
                entryPrice = GetCreek5EdgePrice(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapZipLine1)
                entryPrice = GetZipLine1Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapZipLine2)
                entryPrice = GetZipLine2Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine1)
                entryPrice = GetDriftLine1Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine2)
                entryPrice = GetDriftLine2Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine3)
                entryPrice = GetDriftLine3Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapDriftLine4)
                entryPrice = GetDriftLine4Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapKineticLine1)
                entryPrice = GetKineticLine1Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapKineticLine2)
                entryPrice = GetKineticLine2Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel1)
                entryPrice = GetStingRayLevel1Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel2)
                entryPrice = GetStingRayLevel2Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel3)
                entryPrice = GetStingRayLevel3Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel4)
                entryPrice = GetStingRayLevel4Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayLevel5)
                entryPrice = GetStingRayLevel5Price(MarketPosition.Short, SnapOffsetTicks);
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapStingRayXLevel)
            {
                const int InitialStopLossOffsetTicks = 5;
                double stingRayLevel1Price = GetStingRayLevel1Price(MarketPosition.Short, InitialStopLossOffsetTicks);
                double stingRayLevel2Price = GetStingRayLevel1Price(MarketPosition.Short, InitialStopLossOffsetTicks);
                double driftLine4Price = GetDriftLine4Price(MarketPosition.Short, InitialStopLossOffsetTicks);

                const double minATRMultiplier = 2.0;
                double atrMinTicks = CalculateATRTicks(atrValue, minATRMultiplier, attachedInstrumentTicksPerPoint);
                double lowestStopLossPrice = stingRayLevel1Price + (atrMinTicks * attachedInstrumentTickSize);

                const double bigATRMultiplier = 4.0;
                double atrBigTicks = CalculateATRTicks(atrValue, bigATRMultiplier, attachedInstrumentTicksPerPoint);
                double bigStopLossPrice = previous1ClosePrice + (atrBigTicks * attachedInstrumentTickSize);

                if (stingRayLevel1Price >= bigStopLossPrice)
                {
                    entryPrice = Math.Min(stingRayLevel1Price, driftLine4Price);
                }
                else if (stingRayLevel1Price > driftLine4Price)
                {
                    entryPrice = stingRayLevel1Price;
                }
                else if (stingRayLevel2Price <= lowestStopLossPrice && driftLine4Price <= lowestStopLossPrice)
                {
                    entryPrice = Math.Max(stingRayLevel2Price, driftLine4Price);
                }
                else if (stingRayLevel2Price <= lowestStopLossPrice)
                {
                    entryPrice = stingRayLevel2Price;
                }
                else if (driftLine4Price <= lowestStopLossPrice)
                {
                    entryPrice = driftLine4Price;
                }
                else
                {
                    entryPrice = stingRayLevel1Price;
                }
            }
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapProfilePeppy)
            {
                if (recentZombieSellHighPrice != 0 && recentCreeperSellHighPrice != 0)
                {
                    entryPrice = Math.Max(Math.Max(recentZombieSellHighPrice, recentCreeperSellHighPrice), previous1HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);

                }
                else if (recentZombieSellHighPrice != 0)
                {
                    entryPrice = Math.Max(recentZombieSellHighPrice, previous1HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);

                }
                else if (recentCreeperSellHighPrice != 0)
                {
                    entryPrice = Math.Max(recentCreeperSellHighPrice, previous1HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else
                {
                    entryPrice = previous1HighPrice + (attachedInstrumentTickSize * SnapOffsetTicks);
                }
            }
            else if (stopLossSnapType == TickHunterStopLossSnapTypes.SnapProfileSleepy)
            {
                if (recentZombieSellHighPrice != 0 && recentCreeperSellHighPrice != 0)
                {
                    entryPrice = Math.Max(Math.Max(recentZombieSellHighPrice, recentCreeperSellHighPrice), previous1HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);

                }
                else if (recentZombieSellHighPrice != 0)
                {
                    entryPrice = Math.Max(recentZombieSellHighPrice, previous1HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);

                }
                else if (recentCreeperSellHighPrice != 0)
                {
                    entryPrice = Math.Max(recentCreeperSellHighPrice, previous1HighPrice) + (attachedInstrumentTickSize * SnapOffsetTicks);
                }
                else
                {
                    entryPrice = previous1HighPrice + (attachedInstrumentTickSize * SnapOffsetTicks);
                }
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, entryPrice);

            return normalizedPrice;
        }

        private double GetZipLine1Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailZL1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailZL1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetZipLine2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailZL2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailZL2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetStingRayLevel1Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
            {
                double stringRayLowValue = Math.Min(stingRayLowLevel1Value, previous1LowPrice);
                maValue = (Math.Floor(stringRayLowValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            }
            else
            {
                double stringRayHighValue = Math.Max(stingRayHighLevel1Value, previous1HighPrice);
                maValue = (Math.Ceiling(stringRayHighValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);
            }

            return maValue;
        }

        private double GetStingRayLevel2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
            {
                double stringRayLowValue = Math.Min(Math.Min(stingRayLowLevel2Value, stingRayLowLevel1Value), previous1LowPrice);
                maValue = (Math.Floor(stringRayLowValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            }
            else
            {
                double stringRayHighValue = Math.Max(Math.Max(stingRayHighLevel2Value, stingRayHighLevel1Value), previous1HighPrice);
                maValue = (Math.Ceiling(stringRayHighValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);
            }

            return maValue;
        }

        private double GetStingRayLevel3Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
            {
                double stringRayLowValue = Math.Min(Math.Min(Math.Min(stingRayLowLevel3Value, stingRayLowLevel2Value), stingRayLowLevel1Value), previous1LowPrice);
                maValue = (Math.Floor(stringRayLowValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            }
            else
            {
                double stringRayHighValue = Math.Max(Math.Max(Math.Max(stingRayHighLevel3Value, stingRayHighLevel2Value), stingRayHighLevel1Value), previous1HighPrice);
                maValue = (Math.Ceiling(stringRayHighValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);
            }

            return maValue;
        }

        private double GetStingRayLevel4Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
            {
                double stringRayLowValue = Math.Min(Math.Min(Math.Min(Math.Min(stingRayLowLevel4Value, stingRayLowLevel3Value), stingRayLowLevel2Value), stingRayLowLevel1Value), previous1LowPrice);
                maValue = (Math.Floor(stringRayLowValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            }
            else
            {
                double stringRayHighValue = Math.Max(Math.Max(Math.Max(Math.Max(stingRayHighLevel4Value, stingRayHighLevel3Value), stingRayHighLevel2Value), stingRayHighLevel1Value), previous1HighPrice);
                maValue = (Math.Ceiling(stringRayHighValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);
            }

            return maValue;
        }

        private double GetStingRayLevel5Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
            {
                double stringRayLowValue = Math.Min(Math.Min(Math.Min(Math.Min(Math.Min(stingRayLowLevel5Value, stingRayLowLevel4Value), stingRayLowLevel3Value), stingRayLowLevel2Value), stingRayLowLevel1Value), previous1LowPrice);
                maValue = (Math.Floor(stringRayLowValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            }
            else
            {
                double stringRayHighValue = Math.Max(Math.Max(Math.Max(Math.Max(Math.Max(stingRayHighLevel5Value, stingRayHighLevel4Value), stingRayHighLevel3Value), stingRayHighLevel2Value), stingRayHighLevel1Value), previous1HighPrice);
                maValue = (Math.Ceiling(stringRayHighValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);
            }

            return maValue;
        }

        private double GetRushLinePrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailRLValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailRLValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetDriftLine1Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailDL1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailDL1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetDriftLine2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailDL2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailDL2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetDriftLine3Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailDL3Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailDL3Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetDriftLine4Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailDL4Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailDL4Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetKineticLine1Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailKLine1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailKLine1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetKineticLine2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailKLine2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailKLine2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetSpeedLineFilterPrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoPilotSpeedLineFilterValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoPilotSpeedLineFilterValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetMovingAverage1Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailMA1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailMA1Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetMovingAverage2Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailMA2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailMA2Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetMovingAverage3Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailMA3Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailMA3Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetMovingAverage4Price(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailMA4Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailMA4Value * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetKeltnerInnerRingPrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(keltnerLowerInnerRingValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(keltnerUpperInnerRingValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetRiver1EdgePrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailR1LValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailR1HValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetRiver5EdgePrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailR5LValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailR5HValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetCreek1EdgePrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailDL3LValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailDL3HValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }

        private double GetCreek5EdgePrice(MarketPosition positionType, int offsetTicks)
        {
            double maValue = 0;

            if (positionType == MarketPosition.Long)
                maValue = (Math.Floor(autoCloseAndTrailDL4LValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - (attachedInstrumentTickSize * offsetTicks);
            else
                maValue = (Math.Ceiling(autoCloseAndTrailDL4HValue * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + (attachedInstrumentTickSize * offsetTicks);

            return maValue;
        }


        private bool CheckSnapPositionTPSL()
        {
            bool returnFlag = true; // UseSnapPositionTPSL;

            return returnFlag;
        }

        private int CalculateStopLossTicks(MarketPosition marketPosition, double averagePrice, double stopLossPrice, double tickSize)
        {
            int stopLossTicks = 0;

            if (averagePrice > 0 && stopLossPrice > 0)
            {
                bool isBuyPosition = (marketPosition == MarketPosition.Long);

                if (isBuyPosition)
                {
                    stopLossTicks = (int)Math.Floor((stopLossPrice - averagePrice) / tickSize);
                }
                else
                {
                    stopLossTicks = (int)Math.Ceiling((averagePrice - stopLossPrice) / tickSize);
                }

                if (stopLossTicks < 0)
                {
                    stopLossTicks *= -1;
                }
            }

            return stopLossTicks;

        }

        private bool GetPopDropOrderCount(out int buyCount, out int sellCount)
        {
            bool orderFound = false;
            buyCount = 0;
            sellCount = 0;

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)
                        || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)))
                    {
                        orderFound = true;

                        if (!Order.IsTerminalState(order.OrderState))
                        {
                            if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy))
                            {
                                orderFound = true;
                                buyCount++;
                            }
                            else if (RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell))
                            {
                                orderFound = true;
                                sellCount++;
                            }

                        }
                    }
                }
            }


            return orderFound;
        }


        private void LoadNinjaTraderOrders()
        {
            if (!IsNinjaTraderOrdersAlreadyLoaded)
            {
                lock (account.Orders)
                {
                    if (!IsNinjaTraderOrdersAlreadyLoaded)
                    {
                        ninjaTraderOrders.Clear();

                        foreach (Order orderItem in account.Orders)
                        {
                            if (!Order.IsTerminalState(orderItem.OrderState))
                            {
                                ninjaTraderOrders.Add(orderItem.Id, orderItem);
                            }
                        }

                        IsNinjaTraderOrdersAlreadyLoaded = true;
                    }
                }
            }
        }

        private Order GetNinjaTraderOrder(RealOrder order)
        {
            LoadNinjaTraderOrders();

            Order foundOrder = null;

            ninjaTraderOrders.TryGetValue(order.OrderId, out foundOrder);

            return foundOrder;
        }

        private bool CancelPopDropOrders(string signalName)
        {
            bool orderFound = false;

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)
                        || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)))
                    {
                        orderFound = true;

                        if (!Order.IsTerminalState(order.OrderState))
                        {
                            if (DebugLogLevel > 2) RealLogger.PrintOutput(signalName + " is cancelling pending order " + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " via " + signalName);
                            Order foundNTOrder = GetNinjaTraderOrder(order);

                            if (foundNTOrder != null)
                            {
                                try
                                {
                                    account.Cancel(new[] { foundNTOrder });
                                }
                                catch (Exception ex)
                                {
                                    RealLogger.PrintOutput("Exception in " + signalName + ":" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                }
                            }
                        }

                    }
                }
            }

            return orderFound;
        }

        private bool HandleBuySnap(string signalName)
        {
            double newBuySnapPrice = 0;
            bool positionFound = false;
            bool isLongPosition = false;
            bool orderFound = false;
            double oldStopLossPrice = 0;
            int stopLossOrderCount = 0;
            double takeProfitPrice = 0;
            OrderType orderType = OrderType.Unknown;

            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;
                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    //if (position.Instrument == attachedInstrument)
                    if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                    {
                        isLongPosition = (position.MarketPosition == MarketPosition.Long);
                        positionFound = true;

                        int oldOrderQuantity = 0;
                        stopLossOrderCount = 0;

                        oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out orderType, out oldOrderQuantity, out stopLossOrderCount);
                        int stopLossTicks = CalculateStopLossTicks(position.MarketPosition, position.AveragePrice, oldStopLossPrice, attachedInstrumentTickSize);
                        int stopLossMultipliedTicks = (int)(stopLossTicks * TakeProfitCtrlSLMultiplier);
                        takeProfitPrice = CalculateTakeProfitPrice(position.MarketPosition, position.AveragePrice, stopLossMultipliedTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

                        break;
                    }
                }
            }

            if (!isLongPosition && positionFound && CheckSnapPositionTPSL())
            {
                if (takeProfitPrice > 0)
                {
                    HandleTakeProfitPlus("BuySnap", takeProfitPrice);
                }

                positionFound = false;
            }
            else if (isLongPosition && positionFound && CheckSnapPositionTPSL())
            {
                TrailBuyPositionStopLoss("BuySnap", true);
            }
            else if (!positionFound || !CheckSnapPositionTPSL())
            {
                orderFound = CancelPopDropOrders("BuySnap");

                if (!orderFound)
                {
                    newBuySnapPrice = CalculateTrailHighPrice(MarketPosition.Long, true);

                    double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                    if (newBuySnapPrice <= askPrice)
                    {
                        newBuySnapPrice = 0;
                    }


                    if (newBuySnapPrice != 0)
                    {
                        if (DebugLogLevel > 2) RealLogger.PrintOutput("New Snap+ price=" + newBuySnapPrice.ToString() + " via " + signalName);
                        int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                        CreateBuyStop(signalName, attachedInstrument, OrderAction.BuyToCover, OrderEntry.Manual, autoEntryVolume, newBuySnapPrice);
                    }
                }

            }

            return positionFound;
        }

        private bool HandleBuyMarket(string signalName)
        {
            bool buyMarketSucceeded = false;

            if (HasRanOnceFirstCycle() && RealOrderService.AreAllOrderUpdateCyclesComplete())
            {
                const OrderAction orderAction = OrderAction.Buy;
                double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);

                int autoEntryincrementVolumeSize = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                int limitedIncrementVolumeSize = GetLimitedIncrementVolumeSize(autoEntryincrementVolumeSize, maxInitialTrancheVolumeSize, limitTrancheVolumeToInProfitFlag);

                int buyPositionVolumeSize = 0;
                double buyPositionPrice = 0;
                int sellPositionVolumeSize = 0;
                double sellPositionPrice = 0;
                DateTime positionModifyDate = DateTime.MinValue;

                bool hasPosition = GetPositionVolume(attachedInstrument, out buyPositionVolumeSize, out buyPositionPrice, out sellPositionVolumeSize, out sellPositionPrice, out positionModifyDate);
                bool hasBuyPosition = buyPositionVolumeSize > 0;
                double positionPrice = buyPositionPrice;
                bool isValidPositionMaxVolume = attachedInstrumentPositionMaxVolume > 0;

                bool passedLimitTrancheVolume = false;

                if (limitTrancheVolumePerBarFlag)
                {
                    bool pastTrancheVolumeDelay = positionModifyDate.AddSeconds(MinTrancheVolumeDelaySeconds) <= GetDateTimeNow();

                    if (pastTrancheVolumeDelay)
                    {
                        passedLimitTrancheVolume = true;
                    }
                }
                else
                {
                    passedLimitTrancheVolume = true;
                }

                bool isOverVolumePositionMax = limitedIncrementVolumeSize > attachedInstrumentPositionMaxVolume
                    || (limitedIncrementVolumeSize + buyPositionVolumeSize) > attachedInstrumentPositionMaxVolume;

                if ((!isOverVolumePositionMax && isValidPositionMaxVolume) || (isOverVolumePositionMax && !isValidPositionMaxVolume))
                {
                    bool passedMarginCheck = OrderMarginCheck(attachedInstrument, UseIntradayMarginCheck, orderAction, limitedIncrementVolumeSize, buyPositionVolumeSize, sellPositionVolumeSize);

                    if (passedMarginCheck)
                    {
                        bool isReducingPostion = (hasPosition && !hasBuyPosition);

                        if (passedLimitTrancheVolume || isReducingPostion)
                        {
                            if ((!limitTrancheVolumeToInProfitFlag && !LimitToVolumeMaxOption) || isReducingPostion)
                            {
                                RealLogger.PrintOutput("Send buy order at price (" + askPrice.ToString() + ")" + " via " + signalName);

                                ReducePositionTakeProfitVolume(signalName, sellPositionVolumeSize, autoEntryincrementVolumeSize);

                                SubmitMarketOrder(signalName, attachedInstrument, orderAction, OrderEntry.Manual, autoEntryincrementVolumeSize);
                                buyMarketSucceeded = true;
                            }
                            else
                            {
                                double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);

                                bool positionInProfit = attachedInstrumentPositionPnL > 0;  //bidPrice >= positionPrice;
                                int newVolumeSize = DEFAULT_VOLUME_SIZE;

                                if (TryGetLimitTrancheVolumeSize(buyPositionVolumeSize, positionInProfit, autoEntryincrementVolumeSize, maxInitialTrancheVolumeSize, out newVolumeSize))
                                {
                                    RealLogger.PrintOutput("Send buy order at price (" + askPrice.ToString() + ")" + " via " + signalName);

                                    ReducePositionTakeProfitVolume(signalName, sellPositionVolumeSize, newVolumeSize);

                                    SubmitMarketOrder(signalName, attachedInstrument, orderAction, OrderEntry.Manual, newVolumeSize);
                                    buyMarketSucceeded = true;
                                }
                                else
                                {
                                    RealLogger.PrintOutput("BLOCKED buy order due to LimitTrancheVolumeToInProfit(" + MaxInitialTrancheVolumeSize.ToString("N0") + ") where position price at (" + positionPrice
                                        + ") must be less than market price at (" + askPrice + ")" + " via " + signalName);
                                }
                            }
                        }
                        else
                        {
                            RealLogger.PrintOutput("BLOCKED buy order due to LimitTrancheVolumePerBar(" + MinTrancheVolumeDelaySeconds.ToString("N0") + " sec) via " + signalName);
                        }
                    }
                    else
                    {
                        double intradayMargin = attachedInstrumentIntradayMarginDollars;
                        RealLogger.PrintOutput("BLOCKED: Buy volume attempt greater than margin allowed.  limitedIncrementVolumeSize=" + limitedIncrementVolumeSize.ToString("N0") + " intradayMargin=" + intradayMargin + " via " + signalName);
                    }
                }
                else
                {
                    RealLogger.PrintOutput("BLOCKED: Buy volume attempt greater than instrument position max volume.  attachedInstrumentPositionMaxVolume="
                        + attachedInstrumentPositionMaxVolume + " limitedIncrementVolumeSize=" + limitedIncrementVolumeSize.ToString("N0") + " via " + signalName);
                }
            }

            return buyMarketSucceeded;
        }

        private bool HandleSellMarket(string signalName)
        {
            bool sellMarketSucceeded = false;

            if (HasRanOnceFirstCycle() && RealOrderService.AreAllOrderUpdateCyclesComplete())
            {
                const OrderAction orderAction = OrderAction.Sell;
                double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);

                int autoEntryincrementVolumeSize = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                int limitedIncrementVolumeSize = GetLimitedIncrementVolumeSize(autoEntryincrementVolumeSize, maxInitialTrancheVolumeSize, limitTrancheVolumeToInProfitFlag);

                int buyPositionVolumeSize = 0;
                double buyPositionPrice = 0;
                int sellPositionVolumeSize = 0;
                double sellPositionPrice = 0;
                DateTime positionModifyDate = DateTime.MinValue;

                bool hasPosition = GetPositionVolume(attachedInstrument, out buyPositionVolumeSize, out buyPositionPrice, out sellPositionVolumeSize, out sellPositionPrice, out positionModifyDate);
                bool hasSellPosition = sellPositionVolumeSize > 0;
                double positionPrice = sellPositionPrice;
                bool isValidPositionMaxVolume = attachedInstrumentPositionMaxVolume > 0;

                bool passedLimitTrancheVolume = false;

                if (limitTrancheVolumePerBarFlag)
                {
                    bool pastTrancheVolumeDelay = positionModifyDate.AddSeconds(MinTrancheVolumeDelaySeconds) <= GetDateTimeNow();

                    if (pastTrancheVolumeDelay)
                    {
                        passedLimitTrancheVolume = true;
                    }
                }
                else
                {
                    passedLimitTrancheVolume = true;
                }

                bool isOverVolumePositionMax = limitedIncrementVolumeSize > attachedInstrumentPositionMaxVolume
                    || (limitedIncrementVolumeSize + sellPositionVolumeSize) > attachedInstrumentPositionMaxVolume;

                if ((!isOverVolumePositionMax && isValidPositionMaxVolume) || (isOverVolumePositionMax && !isValidPositionMaxVolume))
                {
                    bool passedMarginCheck = OrderMarginCheck(attachedInstrument, UseIntradayMarginCheck, orderAction, limitedIncrementVolumeSize, buyPositionVolumeSize, sellPositionVolumeSize);

                    if (passedMarginCheck)
                    {
                        bool isReducingPostion = (hasPosition && !hasSellPosition);

                        if (passedLimitTrancheVolume || isReducingPostion)
                        {
                            if ((!limitTrancheVolumeToInProfitFlag && !LimitToVolumeMaxOption) || isReducingPostion)
                            {
                                RealLogger.PrintOutput("Send sell order at price (" + bidPrice.ToString() + ")" + " via " + signalName);

                                ReducePositionTakeProfitVolume(signalName, buyPositionVolumeSize, autoEntryincrementVolumeSize);

                                SubmitMarketOrder(signalName, attachedInstrument, orderAction, OrderEntry.Manual, autoEntryincrementVolumeSize);
                                sellMarketSucceeded = true;
                            }
                            else
                            {
                                double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);

                                bool positionInProfit = attachedInstrumentPositionPnL > 0; //askPrice <= positionPrice;
                                int newVolumeSize = DEFAULT_VOLUME_SIZE;

                                if (TryGetLimitTrancheVolumeSize(sellPositionVolumeSize, positionInProfit, autoEntryincrementVolumeSize, maxInitialTrancheVolumeSize, out newVolumeSize))
                                {
                                    RealLogger.PrintOutput("Send sell order at price (" + bidPrice.ToString() + ")" + " via " + signalName);

                                    ReducePositionTakeProfitVolume(signalName, buyPositionVolumeSize, newVolumeSize);

                                    SubmitMarketOrder(signalName, attachedInstrument, orderAction, OrderEntry.Manual, newVolumeSize);
                                    sellMarketSucceeded = true;
                                }
                                else
                                {
                                    RealLogger.PrintOutput("BLOCKED sell order due to LimitTrancheVolumeToInProfit(" + MaxInitialTrancheVolumeSize.ToString("N0") + ") where position price at (" + positionPrice
                                        + ") must be greater than market price at (" + bidPrice + ")" + " via " + signalName);
                                }
                            }
                        }
                        else
                        {
                            RealLogger.PrintOutput("BLOCKED sell order due to LimitTrancheVolumePerBar(" + MinTrancheVolumeDelaySeconds.ToString("N0") + " sec) via " + signalName);
                        }
                    }
                    else
                    {
                        double intradayMargin = attachedInstrumentIntradayMarginDollars;
                        RealLogger.PrintOutput("BLOCKED: Sell volume attempt greater than margin allowed.  limitedIncrementVolumeSize=" + limitedIncrementVolumeSize.ToString("N0") + " intradayMargin=" + intradayMargin + " via " + signalName);
                    }
                }
                else
                {
                    RealLogger.PrintOutput("BLOCKED: Sell volume attempt greater than instrument position max volume.  attachedInstrumentPositionMaxVolume="
                        + attachedInstrumentPositionMaxVolume + " limitedIncrementVolumeSize=" + limitedIncrementVolumeSize.ToString("N0") + " via " + signalName);
                }
            }

            return sellMarketSucceeded;
        }

        private void ReducePositionTakeProfitVolume(string signalName, int positionVolumeSize, int reduceVolumeSize)
        {
            if (TakeProfitRefreshManagementEnabled)
            {
                bool hasTakeProfit = attachedInstrumentPositionTakeProfitPrice > 0;
                bool isValidPositionMaxVolume = attachedInstrumentPositionMaxVolume > 0;

                if (hasTakeProfit && isValidPositionMaxVolume)
                {
                    int potentialNewVolumeSize = (reduceVolumeSize + positionVolumeSize);
                    bool isOverTotalVolumePositionMax = potentialNewVolumeSize > attachedInstrumentPositionMaxVolume;
                    int volumeOverMax = potentialNewVolumeSize - attachedInstrumentPositionMaxVolume;

                    if (isOverTotalVolumePositionMax)
                    {
                        int newVolumeSize = attachedInstrumentPositionMaxVolume - reduceVolumeSize;
                        bool isValidNewVolumeSize = newVolumeSize > 0;
                        OrderAction takeProfitOrderAction = ConvertMarketPositionToTPOrderAction(attachedInstrumentMarketPosition);
                        double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                        bool isPriceValid = RealOrderService.IsValidTakeProfitPrice(attachedInstrument, takeProfitOrderAction, attachedInstrumentPositionTakeProfitPrice, lastPrice);

                        if (isPriceValid && isValidNewVolumeSize)
                        {
                            UpdatePositionTakeProfit(signalName, attachedInstrument, takeProfitOrderAction, OrderEntry.Manual, newVolumeSize, attachedInstrumentPositionTakeProfitPrice);
                        }
                    }
                }
            }
        }

        private bool HandleBuyPop(string signalName, bool onlyCancelSellPopOrder = false)
        {
            bool returnFlag = false;
            bool buyOrderFound = false;
            bool sellOrderFound = false;
            double oldPopPrice = 0;

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)
                        || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)))
                    {
                        if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover))
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                buyOrderFound = true;
                                oldPopPrice = order.StopPrice;
                            }
                        }

                        if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.SellShort)
                            || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)
                            || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy))
                        {
                            sellOrderFound = true;
                        }

                        if (sellOrderFound)
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                if (DebugLogLevel > 2) RealLogger.PrintOutput(signalName + " is cancelling pending order " + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " via " + signalName);
                                Order foundNTOrder = GetNinjaTraderOrder(order);

                                if (foundNTOrder != null)
                                {
                                    try
                                    {
                                        account.Cancel(new[] { foundNTOrder });
                                    }
                                    catch (Exception ex)
                                    {
                                        RealLogger.PrintOutput("Exception in HandleBuyPop:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (onlyCancelSellPopOrder)
                returnFlag = sellOrderFound;
            else
                returnFlag = buyOrderFound;

            if (!onlyCancelSellPopOrder)
            {

                if (!buyOrderFound && !sellOrderFound)
                {
                    double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                    double highestPrice = askPrice;
                    if (UsePopAutoJumpToSnap)
                    {
                        double highPrice = CalculateTrailHighPrice(MarketPosition.Long, true);
                        highestPrice = Math.Max(askPrice, highPrice);
                    }

                    double newPopPrice = GetInitialPopPrice(MarketPosition.Long, highestPrice);

                    if (newPopPrice <= askPrice)
                    {
                        newPopPrice = 0;
                    }

                    if (newPopPrice != 0)
                    {
                        bool passedPullBackCheck = false;

                        if (popLimitToPullbackFlag)
                        {
                            bool isCTRLKeyDown = IsCtrlKeyDown();
                            bool popDelayedEntry = (!popCTRLDelayedEntryFlag && isCTRLKeyDown);
                            bool isValidPullback = IsInValidBuyPopPullBack();

                            if (isValidPullback || popDelayedEntry)
                            {
                                passedPullBackCheck = true;

                                if (!isValidPullback && popDelayedEntry)
                                    RealLogger.PrintOutput("BYPASSED UsePopLimitToPullback where previous candle must be bearish for buy pop order" + " via " + signalName);
                            }
                            else
                            {
                                RealLogger.PrintOutput("BLOCKED buy pop order due to UsePopLimitToPullback where previous candle must be bearish" + " via " + signalName);
                            }
                        }
                        else
                        {
                            passedPullBackCheck = true;
                        }

                        if (passedPullBackCheck)
                        {
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("New Pop+ price=" + newPopPrice.ToString() + " via " + signalName);
                            int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                            CreateBuyStop(signalName, attachedInstrument, OrderAction.BuyToCover, OrderEntry.Manual, autoEntryVolume, newPopPrice);
                        }
                    }
                }
                else if (buyOrderFound && !sellOrderFound)
                {
                    double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                    double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                    double newPopPrice = GetPopPriceFromJumpTicks(MarketPosition.Long, oldPopPrice, this.PopJumpTicks);

                    if (newPopPrice <= bidPrice || newPopPrice <= lastPrice)
                    {
                        newPopPrice = 0;
                    }

                    if (newPopPrice != 0)
                    {
                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Update Pop+ price=" + newPopPrice.ToString() + " via " + signalName);
                        UpdateStopOrder(signalName, attachedInstrument, OrderAction.BuyToCover, OrderEntry.Manual, newPopPrice);
                    }
                }
            }

            return returnFlag;
        }

        private bool HandleSellPop(string signalName, bool onlyCancelBuyPopOrder = false)
        {
            bool returnFlag = false;
            bool buyOrderFound = false;
            bool sellOrderFound = false;
            double oldPopPrice = 0;

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)
                        || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)))
                    {
                        if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.SellShort))
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                sellOrderFound = true;
                                oldPopPrice = order.StopPrice;
                            }
                        }

                        if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover)
                            || RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy)
                            || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell))
                        {
                            buyOrderFound = true;
                        }

                        if (buyOrderFound)
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                if (DebugLogLevel > 2) RealLogger.PrintOutput(signalName + " is cancelling pending order " + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " via " + signalName);
                                Order foundNTOrder = GetNinjaTraderOrder(order);

                                if (foundNTOrder != null)
                                {
                                    try
                                    {
                                        account.Cancel(new[] { foundNTOrder });
                                    }
                                    catch (Exception ex)
                                    {
                                        RealLogger.PrintOutput("Exception in HandleSellPop:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (onlyCancelBuyPopOrder)
                returnFlag = buyOrderFound;
            else
                returnFlag = sellOrderFound;

            if (!onlyCancelBuyPopOrder)
            {

                if (!sellOrderFound && !buyOrderFound)
                {
                    double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                    double lowestPrice = bidPrice;
                    if (UsePopAutoJumpToSnap)
                    {
                        double lowPrice = CalculateTrailLowPrice(MarketPosition.Short, true);
                        lowestPrice = Math.Min(bidPrice, lowPrice);
                    }

                    double newPopPrice = GetInitialPopPrice(MarketPosition.Short, lowestPrice);

                    if (newPopPrice >= bidPrice)
                    {
                        newPopPrice = 0;
                    }


                    if (newPopPrice != 0)
                    {
                        bool passedPullBackCheck = false;

                        if (popLimitToPullbackFlag)
                        {
                            bool isCTRLKeyDown = IsCtrlKeyDown();
                            bool popDelayedEntry = (!popCTRLDelayedEntryFlag && isCTRLKeyDown);
                            bool isValidPullback = IsInValidSellPopPullBack();

                            if (isValidPullback || popDelayedEntry)
                            {
                                passedPullBackCheck = true;

                                if (!isValidPullback && popDelayedEntry)
                                    RealLogger.PrintOutput("BYPASSED UsePopLimitToPullback where previous candle must be bullish for sell pop order" + " via " + signalName);
                            }
                            else
                            {
                                RealLogger.PrintOutput("BLOCKED sell pop order due to UsePopLimitToPullback where previous candle must be bullish" + " via " + signalName);
                            }
                        }
                        else
                        {
                            passedPullBackCheck = true;
                        }

                        if (passedPullBackCheck)
                        {
                            if (DebugLogLevel > 2) RealLogger.PrintOutput("New Pop- price=" + newPopPrice.ToString() + " via " + signalName);
                            int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                            CreateSellStop(signalName, attachedInstrument, OrderAction.SellShort, OrderEntry.Manual, autoEntryVolume, newPopPrice);
                        }
                    }
                }
                else if (sellOrderFound && !buyOrderFound)
                {
                    double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                    double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                    double newPopPrice = GetPopPriceFromJumpTicks(MarketPosition.Short, oldPopPrice, this.PopJumpTicks);

                    if (newPopPrice >= askPrice || newPopPrice >= lastPrice)
                    {
                        newPopPrice = 0;
                    }

                    if (newPopPrice != 0)
                    {
                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Update Pop- price=" + newPopPrice.ToString() + " via " + signalName);
                        UpdateStopOrder(signalName, attachedInstrument, OrderAction.SellShort, OrderEntry.Manual, newPopPrice);
                    }
                }
            }

            return returnFlag;
        }


        private bool IsInValidBuyPopPullBack()
        {
            bool passedPullBackCheck = false;

            //bool altBuyZombieSetup1 = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
            //bool altBuyCreeperSetup1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;

            if (!previous1CandleBullish)// || altBuyZombieSetup1 || altBuyCreeperSetup1)
            {
                passedPullBackCheck = true;
            }

            return passedPullBackCheck;
        }

        private bool IsInValidSellPopPullBack()
        {
            bool passedPullBackCheck = false;

            //bool altSellZombieSetup1 = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
            //bool altSellCreeperSetup1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;

            if (previous1CandleBullish)// || altSellZombieSetup1 || altSellCreeperSetup1)
            {
                passedPullBackCheck = true;
            }

            return passedPullBackCheck;
        }


        private bool HandleBuyDrop(string signalName)
        {
            bool buyOrderFound = false;
            bool sellOrderFound = false;
            double oldDropPrice = 0;

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy)
                        || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)
                        || RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)))
                    {
                        if (RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy))
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                buyOrderFound = true;
                                oldDropPrice = order.LimitPrice;
                            }
                        }

                        if (RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)
                            || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)
                            || RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover))
                        {
                            sellOrderFound = true;
                        }

                        if (sellOrderFound)
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                if (DebugLogLevel > 2) RealLogger.PrintOutput(signalName + " is cancelling pending order " + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " via " + signalName);
                                Order foundNTOrder = GetNinjaTraderOrder(order);

                                if (foundNTOrder != null)
                                {

                                    try
                                    {
                                        account.Cancel(new[] { foundNTOrder });
                                    }
                                    catch (Exception ex)
                                    {
                                        RealLogger.PrintOutput("Exception in HandleBuyDrop:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                    }
                                }
                            }
                        }
                    }
                }
            }


            if (!buyOrderFound && !sellOrderFound)
            {
                double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                double lowestPrice = bidPrice;
                if (UseDropAutoJumpToSnap)
                {
                    double lowPrice = CalculateTrailLowPrice(MarketPosition.Long, true);
                    lowestPrice = Math.Min(bidPrice, lowPrice);
                }

                double newDropPrice = GetInitialDropPrice(MarketPosition.Long, lowestPrice);

                if (newDropPrice >= bidPrice)
                {
                    newDropPrice = 0;
                }


                if (newDropPrice != 0)
                {
                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New Drop+ price=" + newDropPrice.ToString() + " via " + signalName);
                    int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                    CreateBuyLimit(signalName, attachedInstrument, OrderAction.Buy, OrderEntry.Manual, autoEntryVolume, newDropPrice);
                }
            }
            else if (buyOrderFound && !sellOrderFound)
            {
                double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                double newDropPrice = GetDropPriceFromJumpTicks(MarketPosition.Long, oldDropPrice, this.DropJumpTicks);

                if (newDropPrice >= askPrice || newDropPrice >= lastPrice)
                {
                    newDropPrice = 0;
                }

                if (newDropPrice != 0)
                {
                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Update Drop+ price=" + newDropPrice.ToString() + " lastPrice=" + lastPrice.ToString() + " askPrice=" + askPrice.ToString() + " via " + signalName);
                    UpdateLimitOrder(signalName, attachedInstrument, OrderAction.Buy, OrderEntry.Manual, newDropPrice);
                }

            }

            return buyOrderFound;
        }

        private bool HandleSellDrop(string signalName)
        {
            bool buyOrderFound = false;
            bool sellOrderFound = false;
            double oldDropPrice = 0;

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)
                        || RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)))
                    {
                        if (RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell))
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                sellOrderFound = true;
                                oldDropPrice = order.LimitPrice;
                            }
                        }

                        if (RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy)
                            || RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover)
                            || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort))
                        {
                            buyOrderFound = true;
                        }

                        if (buyOrderFound)
                        {
                            if (!Order.IsTerminalState(order.OrderState))
                            {
                                if (DebugLogLevel > 2) RealLogger.PrintOutput(signalName + " is cancelling pending order " + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " via " + signalName);
                                Order foundNTOrder = GetNinjaTraderOrder(order);

                                if (foundNTOrder != null)
                                {

                                    try
                                    {
                                        account.Cancel(new[] { foundNTOrder });
                                    }
                                    catch (Exception ex)
                                    {
                                        RealLogger.PrintOutput("Exception in HandleBuyDrop:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (!sellOrderFound && !buyOrderFound)
            {
                double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                double highestPrice = askPrice;
                if (UseDropAutoJumpToSnap)
                {
                    double highPrice = CalculateTrailHighPrice(MarketPosition.Short, true);
                    highestPrice = Math.Max(askPrice, highPrice);
                }

                double newDropPrice = GetInitialDropPrice(MarketPosition.Short, highestPrice);

                if (newDropPrice <= askPrice)
                {
                    newDropPrice = 0;
                }

                if (newDropPrice != 0)
                {
                    if (DebugLogLevel > 2) RealLogger.PrintOutput("New Drop- price=" + newDropPrice.ToString() + " via " + signalName);
                    int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                    CreateSellLimit(signalName, attachedInstrument, OrderAction.Sell, OrderEntry.Manual, autoEntryVolume, newDropPrice);
                }

            }
            else if (sellOrderFound && !buyOrderFound)
            {
                double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                double newDropPrice = GetDropPriceFromJumpTicks(MarketPosition.Short, oldDropPrice, this.DropJumpTicks);

                if (newDropPrice <= bidPrice || newDropPrice <= lastPrice)
                {
                    newDropPrice = 0;
                }

                if (newDropPrice != 0)
                {
                    if (DebugLogLevel > 2) RealLogger.PrintOutput("Update Drop- price=" + newDropPrice.ToString() + " lastPrice=" + lastPrice.ToString() + " bidPrice=" + bidPrice.ToString() + " via " + signalName);
                    UpdateLimitOrder(signalName, attachedInstrument, OrderAction.Sell, OrderEntry.Manual, newDropPrice);
                }
            }

            return sellOrderFound;
        }

        private void HandlePopAutoJumpToSnap(string signalName)
        {
            if (UsePopAutoJumpToSnap)
            {
                var lockTimeout = TimeSpan.FromMilliseconds(250);
                bool lockTaken = false;

                try
                {
                    Monitor.TryEnter(PopAutoJumpToSnapLock, lockTimeout, ref lockTaken);

                    if (lockTaken)
                    {
                        if (RealOrderService.AreAllOrderUpdateCyclesComplete()
                            && !HasPositionTPSLOrderDelay())
                        {
                            bool buyOrderFound = false;
                            bool sellOrderFound = false;
                            double oldBuyPopPrice = 0;
                            double oldSellPopPrice = 0;

                            int orderCount = RealOrderService.OrderCount;

                            for (int index = 0; index < orderCount; index++)
                            {
                                RealOrder order = null;

                                if (RealOrderService.TryGetByIndex(index, out order))
                                {
                                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, attachedInstrument, OrderAction.SellShort)))
                                    {
                                        if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.BuyToCover))
                                        {
                                            if (!Order.IsTerminalState(order.OrderState))
                                            {
                                                oldBuyPopPrice = order.StopPrice;
                                                buyOrderFound = true;
                                            }
                                        }

                                        if (RealOrderService.IsValidBuyStopOrder(order, attachedInstrument, OrderAction.SellShort))
                                        {
                                            if (!Order.IsTerminalState(order.OrderState))
                                            {
                                                oldSellPopPrice = order.StopPrice;
                                                sellOrderFound = true;
                                            }
                                        }
                                    }
                                }

                                if (buyOrderFound && !sellOrderFound)
                                {
                                    double newPopPrice = GetPopPriceFromJumpTicks(MarketPosition.Long, oldBuyPopPrice, this.PopJumpTicks);
                                    double snapPrice = CalculateTrailHighPrice(MarketPosition.Long, true);
                                    double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                                    double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                                    //double realBidPrice = GetCurrentBid();

                                    if (oldBuyPopPrice <= snapPrice)
                                    {
                                        newPopPrice = 0;
                                    }
                                    else if (newPopPrice < snapPrice)
                                    {
                                        newPopPrice = snapPrice;
                                    }

                                    if (newPopPrice != 0 && (newPopPrice <= bidPrice || newPopPrice <= lastPrice))// || newPopPrice <= realBidPrice))
                                    {
                                        newPopPrice = 0;
                                    }


                                    //RealLogger.PrintOutput("Update PopAutoJumpToSnap newPopPrice=" + newPopPrice.ToString() + " bidPrice=" + bidPrice.ToString() + " lastPrice=" + lastPrice.ToString());

                                    if (newPopPrice != 0 && oldBuyPopPrice != newPopPrice)
                                    {
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Update PopAutoJumpToSnap buy price=" + newPopPrice.ToString() + " via " + signalName);
                                        UpdateStopOrder(signalName, attachedInstrument, OrderAction.BuyToCover, OrderEntry.Manual, newPopPrice);
                                    }
                                }
                                else if (sellOrderFound && !buyOrderFound)
                                {
                                    double newPopPrice = GetPopPriceFromJumpTicks(MarketPosition.Short, oldSellPopPrice, this.PopJumpTicks);
                                    double snapPrice = CalculateTrailLowPrice(MarketPosition.Short, true);
                                    double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                                    double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                                    //double realAskPrice = GetCurrentAsk();

                                    if (oldSellPopPrice >= snapPrice)
                                    {
                                        newPopPrice = 0;
                                    }
                                    else if (newPopPrice > snapPrice)
                                    {
                                        newPopPrice = snapPrice;
                                    }

                                    if (newPopPrice != 0 && (newPopPrice >= askPrice || newPopPrice >= lastPrice)) // || newPopPrice >= realAskPrice))
                                    {
                                        newPopPrice = 0;
                                    }

                                    //RealLogger.PrintOutput("Update PopAutoJumpToSnap newPopPrice=" + newPopPrice.ToString() + " askPrice=" + askPrice.ToString() + " lastPrice=" + lastPrice.ToString());

                                    if (newPopPrice != 0 && oldSellPopPrice != newPopPrice)
                                    {
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Update PopAutoJumpToSnap sell price=" + newPopPrice.ToString() + " via " + signalName);
                                        UpdateStopOrder(signalName, attachedInstrument, OrderAction.SellShort, OrderEntry.Manual, newPopPrice);
                                    }
                                }

                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception calling HandlePopAutoJumptToSnap:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                    throw;
                }
                finally
                {
                    if (lockTaken)
                    {
                        Monitor.Exit(PopAutoJumpToSnapLock);
                    }
                }
            }
        }

        private void HandleDropAutoJumpToSnap(string signalName)
        {
            if (UseDropAutoJumpToSnap)
            {
                var lockTimeout = TimeSpan.FromMilliseconds(250);
                bool lockTaken = false;

                try
                {
                    Monitor.TryEnter(DropAutoJumpToSnapLock, lockTimeout, ref lockTaken);

                    if (lockTaken)
                    {
                        if (RealOrderService.AreAllOrderUpdateCyclesComplete()
                            && !HasPositionTPSLOrderDelay())
                        {
                            bool buyOrderFound = false;
                            bool sellOrderFound = false;
                            double oldBuyDropPrice = 0;
                            double oldSellDropPrice = 0;

                            int orderCount = RealOrderService.OrderCount;

                            for (int index = 0; index < orderCount; index++)
                            {
                                RealOrder order = null;

                                if (RealOrderService.TryGetByIndex(index, out order))
                                {
                                    if (order.Instrument == attachedInstrument && (RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell)))
                                    {
                                        if (RealOrderService.IsValidBuyLimitOrder(order, attachedInstrument, OrderAction.Buy))
                                        {
                                            if (!Order.IsTerminalState(order.OrderState))
                                            {
                                                oldBuyDropPrice = order.LimitPrice;
                                                buyOrderFound = true;
                                            }
                                        }

                                        if (RealOrderService.IsValidSellLimitOrder(order, attachedInstrument, OrderAction.Sell))
                                        {
                                            if (!Order.IsTerminalState(order.OrderState))
                                            {
                                                oldSellDropPrice = order.LimitPrice;
                                                sellOrderFound = true;
                                            }
                                        }
                                    }
                                }

                                if (buyOrderFound && !sellOrderFound)
                                {
                                    double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                                    double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                                    double newDropPrice = GetDropPriceFromJumpTicks(MarketPosition.Long, oldBuyDropPrice, this.DropJumpTicks);
                                    double snapPrice = CalculateTrailLowPrice(MarketPosition.Long, true);
                                    //double realAskPrice = GetCurrentAsk();

                                    if (oldBuyDropPrice >= snapPrice)
                                    {
                                        newDropPrice = 0;
                                    }
                                    else if (newDropPrice > snapPrice)
                                    {
                                        newDropPrice = snapPrice;
                                    }

                                    if (newDropPrice != 0 && (newDropPrice >= askPrice || newDropPrice >= lastPrice)) // || newDropPrice >= realAskPrice))
                                    {
                                        newDropPrice = 0;
                                    }

                                    if (newDropPrice != 0 && oldBuyDropPrice != newDropPrice)
                                    {
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Update DropAutoJumpToSnap buy price=" + newDropPrice.ToString() + " via " + signalName);
                                        UpdateLimitOrder(signalName, attachedInstrument, OrderAction.Buy, OrderEntry.Manual, newDropPrice);
                                    }
                                }
                                else if (sellOrderFound && !buyOrderFound)
                                {
                                    double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                                    double lastPrice = RealInstrumentService.GetLastPrice(attachedInstrument);
                                    double newDropPrice = GetDropPriceFromJumpTicks(MarketPosition.Short, oldSellDropPrice, this.DropJumpTicks);
                                    double snapPrice = CalculateTrailHighPrice(MarketPosition.Short, true);
                                    //double realBidPrice = GetCurrentBid();

                                    if (oldSellDropPrice <= snapPrice)
                                    {
                                        newDropPrice = 0;
                                    }
                                    else if (newDropPrice < snapPrice)
                                    {
                                        newDropPrice = snapPrice;
                                    }

                                    if (newDropPrice != 0 && (newDropPrice <= bidPrice || newDropPrice <= lastPrice)) // || newDropPrice <= realBidPrice))
                                    {
                                        newDropPrice = 0;
                                    }

                                    if (newDropPrice != 0 && oldSellDropPrice != newDropPrice)
                                    {
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Update DropAutoJumpToSnap sell price=" + newDropPrice.ToString() + " via " + signalName);
                                        UpdateLimitOrder(signalName, attachedInstrument, OrderAction.Sell, OrderEntry.Manual, newDropPrice);
                                    }
                                }

                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception calling HandleDropAutoJumptToSnap:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                    throw;
                }
                finally
                {
                    if (lockTaken)
                    {
                        Monitor.Exit(DropAutoJumpToSnapLock);
                    }
                }
            }
        }

        private int CalculateATRTicks(double atrValue, double atrMultiplier, int ticksPerPoint)
        {
            int atrTicks = 0;

            if (atrMultiplier > 0)
            {
                atrTicks = (int)((atrValue * ticksPerPoint) * atrMultiplier);
            }

            return atrTicks;
        }

        private double GetInitialPopPrice(MarketPosition marketPosition, double askPrice)
        {
            int popTicks = this.PopInitialTicks;
            bool allowATROverride = (this.PopInitialATRMultiplier > 0);

            if (allowATROverride)
            {
                int newATRPopTicks = CalculateATRTicks(atrValue, this.PopInitialATRMultiplier, attachedInstrumentTicksPerPoint);

                popTicks = Math.Max(newATRPopTicks, this.PopInitialTicks);
            }

            double newPopPrice = CalculatePopPrice(marketPosition, askPrice, popTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newPopPrice);

            return normalizedPrice;
        }

        private double GetPopPriceFromJumpTicks(MarketPosition marketPosition, double oldPopPrice, int jumpTicks)
        {
            double newPopPrice = 0;

            newPopPrice = CalculatePopPlusPrice(marketPosition, oldPopPrice, jumpTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newPopPrice);

            return normalizedPrice;
        }

        private double CalculatePopPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newPopPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newPopPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newPopPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newPopPrice);

            return normalizedPrice;
        }

        private double CalculatePopPlusPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newPopPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newPopPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newPopPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newPopPrice);

            return normalizedPrice;
        }

        private double GetInitialDropPrice(MarketPosition marketPosition, double askPrice)
        {
            int dropTicks = this.DropInitialTicks;
            bool allowATROverride = (this.DropInitialATRMultiplier > 0);

            if (allowATROverride)
            {
                int newATRDropTicks = CalculateATRTicks(atrValue, this.DropInitialATRMultiplier, attachedInstrumentTicksPerPoint);

                dropTicks = Math.Max(newATRDropTicks, this.DropInitialTicks);
            }

            double newDropPrice = CalculateDropPrice(marketPosition, askPrice, dropTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newDropPrice);

            return normalizedPrice;
        }

        private double GetDropPriceFromJumpTicks(MarketPosition marketPosition, double oldDropPrice, int jumpTicks)
        {
            double newDropPrice = 0;

            newDropPrice = CalculateDropPlusPrice(marketPosition, oldDropPrice, jumpTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newDropPrice);

            return normalizedPrice;
        }

        private double CalculateDropPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newDropPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newDropPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newDropPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newDropPrice);

            return normalizedPrice;
        }

        private double CalculateDropPlusPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newDropPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newDropPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newDropPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newDropPrice);

            return normalizedPrice;
        }

        private double GetInitialStopLossPrice(Instrument instrument, MarketPosition marketPosition, double averagePrice, int quantity, double currentStopLossPrice = 0)
        {
            double newStopLossPrice = currentStopLossPrice;
            bool useStopLossTicks = (this.StopLossInitialTicks > 0);
            bool useStopLossDollars = (this.StopLossInitialDollars > 0);

            int stopLossTicks = this.StopLossInitialTicks;
            bool allowATROverride = (this.StopLossInitialATRMultiplier > 0);


            if (useStopLossDollars)
            {
                double commissionPerSide = GetInstrumentCommissionPerSide(instrument);
                bool includeCommissions = (commissionPerSide > 0);
                double netStopLossDollars = this.StopLossInitialDollars;

                double tickValue = RealInstrumentService.GetTickValue(attachedInstrument);
                double tickSize = attachedInstrumentTickSize;
                int ticksPerPoint = attachedInstrumentTicksPerPoint;

                if (StopLossInitialDollarsCombined && currentStopLossPrice == 0)
                {
                    if (allowATROverride)
                    {
                        int newATRStopLossTicks = CalculateATRTicks(atrValue, this.StopLossInitialATRMultiplier, attachedInstrumentTicksPerPoint);

                        stopLossTicks = Math.Max(newATRStopLossTicks, this.StopLossInitialTicks);
                    }

                    newStopLossPrice = CalculateStopLossPrice(marketPosition, averagePrice, stopLossTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

                    if (currentStopLossInitialSnapStatus != TickHunterStopLossSnapTypes.Disabled)
                    {
                        if (marketPosition == MarketPosition.Long)
                        {
                            double newSnapStopLossPrice = CalculateSnapBarLowPrice(currentStopLossInitialSnapStatus); //CalculateTrailLowPrice(marketPosition, true);
                            if (newSnapStopLossPrice > attachedInstrumentTickSize)
                                newStopLossPrice = Math.Min(newStopLossPrice, newSnapStopLossPrice);
                        }
                        else if (marketPosition == MarketPosition.Short)
                        {
                            double newSnapStopLossPrice = CalculateSnapBarHighPrice(currentStopLossInitialSnapStatus); //CalculateTrailHighPrice(marketPosition, true);
                            if (newSnapStopLossPrice > attachedInstrumentTickSize)
                                newStopLossPrice = Math.Max(newStopLossPrice, newSnapStopLossPrice);


                        }
                    }
                }

                if (includeCommissions)
                {
                    netStopLossDollars = netStopLossDollars - (quantity * commissionPerSide * 2);
                }

                if (marketPosition == MarketPosition.Long)
                {
                    double newStopLossDollarPrice = (Math.Floor(averagePrice * ticksPerPoint) / ticksPerPoint) - (Math.Ceiling((netStopLossDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                    newStopLossPrice = (StopLossInitialDollarsCombined) ? Math.Max(newStopLossPrice, newStopLossDollarPrice) : newStopLossDollarPrice;
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    double newStopLossDollarPrice = (Math.Ceiling(averagePrice * ticksPerPoint) / ticksPerPoint) + (Math.Ceiling((netStopLossDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                    newStopLossPrice = (StopLossInitialDollarsCombined) ? Math.Min(newStopLossPrice, newStopLossDollarPrice) : newStopLossDollarPrice;
                }
            }
            else if (useStopLossTicks)
            {
                if (allowATROverride)
                {
                    int newATRStopLossTicks = CalculateATRTicks(atrValue, this.StopLossInitialATRMultiplier, attachedInstrumentTicksPerPoint);

                    stopLossTicks = Math.Max(newATRStopLossTicks, this.StopLossInitialTicks);
                }

                newStopLossPrice = CalculateStopLossPrice(marketPosition, averagePrice, stopLossTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

                if (currentStopLossInitialSnapStatus != TickHunterStopLossSnapTypes.Disabled)
                {
                    if (marketPosition == MarketPosition.Long)
                    {
                        double newSnapStopLossPrice = CalculateSnapBarLowPrice(currentStopLossInitialSnapStatus); //CalculateTrailLowPrice(marketPosition, true);
                        if (newSnapStopLossPrice > attachedInstrumentTickSize)
                            newStopLossPrice = Math.Min(newStopLossPrice, newSnapStopLossPrice);
                    }
                    else if (marketPosition == MarketPosition.Short)
                    {
                        double newSnapStopLossPrice = CalculateSnapBarHighPrice(currentStopLossInitialSnapStatus); //CalculateTrailHighPrice(marketPosition, true);
                        if (newSnapStopLossPrice > attachedInstrumentTickSize)
                            newStopLossPrice = Math.Max(newStopLossPrice, newSnapStopLossPrice);
                    }
                }

                if (StopLossInitialMaxTicks > 0)
                {
                    if (marketPosition == MarketPosition.Long)
                    {
                        double tempMaxStopLossPrice = CalculateStopLossPrice(marketPosition, averagePrice, StopLossInitialMaxTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);
                        newStopLossPrice = Math.Max(newStopLossPrice, tempMaxStopLossPrice);
                    }
                    else if (marketPosition == MarketPosition.Short)
                    {
                        double tempMaxStopLossPrice = CalculateStopLossPrice(marketPosition, averagePrice, StopLossInitialMaxTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);
                        newStopLossPrice = Math.Min(newStopLossPrice, tempMaxStopLossPrice);
                    }
                }
            }

            bool isStopLossPriceInvalid = newStopLossPrice <= 0;

            if (isStopLossPriceInvalid)
            {
                newStopLossPrice = 0 + attachedInstrumentTickSize;
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }

        private double GetBogeyTargetFromDollars(Instrument instrument, MarketPosition marketPosition, double averagePrice, int quantity, double bogeyTargetDollars)
        {
            double newBogeyTargetPrice = 0;

            double commissionPerSide = GetInstrumentCommissionPerSide(instrument);
            bool includeCommissions = (commissionPerSide > 0);
            double netBogeyTargetDollars = bogeyTargetDollars;

            double tickValue = RealInstrumentService.GetTickValue(attachedInstrument);
            double tickSize = attachedInstrumentTickSize;
            int ticksPerPoint = attachedInstrumentTicksPerPoint;

            if (includeCommissions)
            {
                netBogeyTargetDollars = netBogeyTargetDollars + (quantity * commissionPerSide);// * 2);
            }

            if (marketPosition == MarketPosition.Long)
            {
                double newBogeyTargetDollarPrice = (Math.Ceiling(averagePrice * ticksPerPoint) / ticksPerPoint) + (Math.Ceiling((netBogeyTargetDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                newBogeyTargetPrice = newBogeyTargetDollarPrice;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                double newBogeyTargetDollarPrice = (Math.Floor(averagePrice * ticksPerPoint) / ticksPerPoint) - (Math.Ceiling((netBogeyTargetDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                newBogeyTargetPrice = newBogeyTargetDollarPrice;
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newBogeyTargetPrice);

            return normalizedPrice;
        }

        private double GetDayOverMaxLossFromDollars(MarketPosition marketPosition, double averagePrice, int quantity, double dayOverDollars)
        {
            double newStopLossPrice = 0;

            double commissionPerSide = attachedInstrumentCommissionPerSide;
            bool includeCommissions = (commissionPerSide > 0);
            double netStopLossDollars = dayOverDollars;

            double tickValue = RealInstrumentService.GetTickValue(attachedInstrument);
            double tickSize = attachedInstrumentTickSize;
            int ticksPerPoint = attachedInstrumentTicksPerPoint;

            if (includeCommissions)
            {
                netStopLossDollars = netStopLossDollars - (quantity * commissionPerSide);// * 2);
            }

            if (marketPosition == MarketPosition.Long)
            {
                double newStopLossDollarPrice = (Math.Floor(averagePrice * ticksPerPoint) / ticksPerPoint) - (Math.Ceiling((netStopLossDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                newStopLossPrice = newStopLossDollarPrice;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                double newStopLossDollarPrice = (Math.Ceiling(averagePrice * ticksPerPoint) / ticksPerPoint) + (Math.Ceiling((netStopLossDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                newStopLossPrice = newStopLossDollarPrice;
            }

            bool isStopLossPriceInvalid = newStopLossPrice <= 0;

            if (isStopLossPriceInvalid)
            {
                newStopLossPrice = 0 + attachedInstrumentTickSize;
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }


        private double GetECATakeProfitDollars(int totalVolume, int totalOtherVolume,
            int totalMYMVolume, int totalMESVolume, int totalM2KVolume, int totalMNQVolume,
            int totalYMVolume, int totalESVolume, int totalRTYVolume, int totalNQVolume)
        {
            double newECATakeProfitDollars = 0;

            bool hasTakeProfitDollars = ECATargetDollars > 0;

            if (hasTakeProfitDollars)
            {
                newECATakeProfitDollars = ECATargetDollars;
            }
            else
            {
                bool hasProfitATRMultiplierPerVolume = ECATargetATRMultiplierPerVolume > 0;
                double perVolumeProfitDollars = 0;

                if (totalMYMVolume > 0)
                    perVolumeProfitDollars += (ECATargetDollarsPerMYMVolume * totalMYMVolume);

                if (totalMESVolume > 0)
                    perVolumeProfitDollars += (ECATargetDollarsPerMESVolume * totalMESVolume);

                if (totalM2KVolume > 0)
                    perVolumeProfitDollars += (ECATargetDollarsPerM2KVolume * totalM2KVolume);

                if (totalMNQVolume > 0)
                    perVolumeProfitDollars += (ECATargetDollarsPerMNQVolume * totalMNQVolume);

                if (totalYMVolume > 0)
                    perVolumeProfitDollars += (ECATargetDollarsPerYMVolume * totalYMVolume);

                if (totalESVolume > 0)
                    perVolumeProfitDollars += (ECATargetDollarsPerESVolume * totalESVolume);

                if (totalRTYVolume > 0)
                    perVolumeProfitDollars += (ECATargetDollarsPerRTYVolume * totalRTYVolume);

                if (totalNQVolume > 0)
                    perVolumeProfitDollars += (ECATargetDollarsPerNQVolume * totalNQVolume);

                if (totalOtherVolume > 0)
                    perVolumeProfitDollars += (ECATargetDollarsPerOtherVolume * totalOtherVolume);

                if (hasProfitATRMultiplierPerVolume)
                {
                    int atrTicks = CalculateATRTicks(atrValue, ECATargetATRMultiplierPerVolume, attachedInstrumentTicksPerPoint);
                    double atrExpectedProfit = 0;

                    atrExpectedProfit += RealInstrumentService.ConvertTicksToDollars(attachedInstrument, atrTicks, totalVolume);

                    if (atrExpectedProfit > perVolumeProfitDollars)
                    {
                        perVolumeProfitDollars = atrExpectedProfit;
                    }
                }

                newECATakeProfitDollars = perVolumeProfitDollars;
            }


            return newECATakeProfitDollars;
        }


        private double GetECATakeProfitPriceFromDollars(MarketPosition marketPosition, double averagePrice, int quantity, double takeProfitDollars)
        {
            double newECATakeProfitPrice = 0;

            double commissionPerSide = attachedInstrumentCommissionPerSide;
            bool includeCommissions = (commissionPerSide > 0);
            double netECATakeProfitDollars = takeProfitDollars;

            double tickValue = RealInstrumentService.GetTickValue(attachedInstrument);
            double tickSize = attachedInstrumentTickSize;
            int ticksPerPoint = attachedInstrumentTicksPerPoint;

            if (includeCommissions)
            {
                if (marketPosition == MarketPosition.Long)
                    netECATakeProfitDollars = netECATakeProfitDollars + (quantity * commissionPerSide * 2);
                else if (marketPosition == MarketPosition.Short)
                    netECATakeProfitDollars = netECATakeProfitDollars + (quantity * commissionPerSide * 2);
            }

            if (marketPosition == MarketPosition.Long)
            {
                double newECATakeProfitDollarPrice = (Math.Ceiling(averagePrice * ticksPerPoint) / ticksPerPoint) + (Math.Ceiling((netECATakeProfitDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                newECATakeProfitPrice = newECATakeProfitDollarPrice;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                double newECATakeProfitDollarPrice = (Math.Floor(averagePrice * ticksPerPoint) / ticksPerPoint) - (Math.Ceiling((netECATakeProfitDollars / ((tickValue * quantity) / tickSize)) * ticksPerPoint) / ticksPerPoint);
                newECATakeProfitPrice = newECATakeProfitDollarPrice;
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newECATakeProfitPrice);

            return normalizedPrice;
        }

        private double GetStopLossPriceFromJumpTicks(MarketPosition marketPosition, double oldStopLossPrice, int jumpTicks)
        {
            double newStopLossPrice = 0;

            newStopLossPrice = CalculateStopLossPlusPrice(marketPosition, oldStopLossPrice, jumpTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }

        private double CalculateStopLossPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newStopLossPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newStopLossPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newStopLossPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }

        private double CalculateStopLossPlusPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newStopLossPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newStopLossPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newStopLossPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }

        private double GetInitialBreakEvenStopLossPrice(MarketPosition marketPosition, double averagePrice)
        {
            double newStopLossPrice = 0;

            if (marketPosition == MarketPosition.Long)
            {
                newStopLossPrice = (Math.Ceiling(averagePrice * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + ((double)this.BreakEvenInitialTicks * attachedInstrumentTickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newStopLossPrice = (Math.Floor(averagePrice * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - ((double)this.BreakEvenInitialTicks * attachedInstrumentTickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }

        private double GetTriggerBreakEvenStopLossPrice(MarketPosition marketPosition, double averagePrice)
        {
            double newStopLossPrice = 0;
            int breakEventriggerTicks = this.BreakEvenAutoTriggerTicks;

            if (this.BreakEvenAutoTriggerATRMultiplier > 0)
            {
                int newATRTriggerTicks = CalculateATRTicks(atrValue, this.BreakEvenAutoTriggerATRMultiplier, attachedInstrumentTicksPerPoint);

                breakEventriggerTicks = Math.Max(newATRTriggerTicks, this.BreakEvenAutoTriggerTicks);
            }

            if (marketPosition == MarketPosition.Long)
            {
                newStopLossPrice = (Math.Ceiling(averagePrice * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) + ((double)breakEventriggerTicks * attachedInstrumentTickSize);
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newStopLossPrice = (Math.Floor(averagePrice * attachedInstrumentTicksPerPoint) / attachedInstrumentTicksPerPoint) - ((double)breakEventriggerTicks * attachedInstrumentTickSize);
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newStopLossPrice);

            return normalizedPrice;
        }

        private double GetInitialTakeProfitPrice(MarketPosition marketPosition, double averagePrice)
        {
            double newTakeProfitPrice = 0;
            int takeProfitTicks = this.TakeProfitInitialTicks;

            if (this.TakeProfitInitialATRMultiplier > 0)
            {
                int newATRTakeProfitTicks = CalculateATRTicks(atrValue, this.TakeProfitInitialATRMultiplier, attachedInstrumentTicksPerPoint);

                takeProfitTicks = Math.Max(newATRTakeProfitTicks, this.TakeProfitInitialTicks);
            }

            newTakeProfitPrice = CalculateTakeProfitPrice(marketPosition, averagePrice, takeProfitTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            bool isTakeProfitPriceInvalid = newTakeProfitPrice <= 0;

            if (isTakeProfitPriceInvalid)
            {
                newTakeProfitPrice = 0 + attachedInstrumentTickSize;
            }

            double normalizedPrice = RealInstrumentService.NormalizePrice(attachedInstrument, newTakeProfitPrice);

            return normalizedPrice;
        }

        private double GetTakeProfitPriceFromJumpTicks(MarketPosition marketPosition, double oldTakeProfitPrice, int jumpTicks)
        {
            double newTakeProfitPrice = 0;

            newTakeProfitPrice = CalculateTakeProfitPrice(marketPosition, oldTakeProfitPrice, jumpTicks, attachedInstrumentTickSize, attachedInstrumentTicksPerPoint);

            return newTakeProfitPrice;
        }

        double CalculateTakeProfitPrice(MarketPosition marketPosition, double price, int ticks, double tickSize, int ticksPerPoint)
        {
            double newTakeProfitPrice = 0;

            if (price > 0 && ticks > 0)
            {
                bool isBuyPosition = (marketPosition == MarketPosition.Long);

                if (marketPosition == MarketPosition.Long)
                {
                    newTakeProfitPrice = (Math.Ceiling(price * ticksPerPoint) / ticksPerPoint) + ((double)ticks * tickSize);
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    newTakeProfitPrice = (Math.Floor(price * ticksPerPoint) / ticksPerPoint) - ((double)ticks * tickSize);
                }
            }

            return newTakeProfitPrice;
        }


        private OrderAction ConvertMarketPositionToOrderAction(MarketPosition marketPosition)
        {
            OrderAction orderAction = OrderAction.BuyToCover;

            if (marketPosition == MarketPosition.Long)
            {
                orderAction = OrderAction.Buy;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                orderAction = OrderAction.Sell;
            }
            else
            {
                RealLogger.PrintOutput("Market position type  " + marketPosition.ToString() + " not supported.");
            }

            return orderAction;
        }

        private MarketPosition ConvertOrderActionToMarketPosition(OrderAction orderAction)
        {
            MarketPosition marketPosition = MarketPosition.Flat;

            if (orderAction == OrderAction.Buy || orderAction == OrderAction.BuyToCover)
            {
                marketPosition = MarketPosition.Long;
            }
            else if (orderAction == OrderAction.Sell || orderAction == OrderAction.SellShort)
            {
                marketPosition = MarketPosition.Short;
            }
            else
            {
                RealLogger.PrintOutput("Order action type  " + orderAction.ToString() + " not supported.");
            }

            return marketPosition;
        }

        private OrderAction ConvertMarketPositionToRevOrderAction(MarketPosition marketPosition)
        {
            OrderAction orderAction = OrderAction.BuyToCover;

            if (marketPosition == MarketPosition.Long)
            {
                orderAction = OrderAction.Sell;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                orderAction = OrderAction.BuyToCover;
            }
            else
            {
                RealLogger.PrintOutput("Market position type  " + marketPosition.ToString() + " not supported.");
            }

            return orderAction;
        }

        private OrderAction ConvertMarketPositionToSLOrderAction(MarketPosition marketPosition)
        {
            OrderAction orderAction = OrderAction.BuyToCover;

            if (marketPosition == MarketPosition.Long)
            {
                orderAction = OrderAction.Sell;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                orderAction = OrderAction.BuyToCover;
            }
            else
            {
                RealLogger.PrintOutput("Market position type  " + marketPosition.ToString() + " not supported.");
            }

            return orderAction;
        }

        private OrderAction ConvertMarketPositionToTPOrderAction(MarketPosition marketPosition)
        {
            OrderAction orderAction = OrderAction.BuyToCover;

            if (marketPosition == MarketPosition.Long)
            {
                orderAction = OrderAction.Sell;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                orderAction = OrderAction.BuyToCover;
            }
            else
            {
                RealLogger.PrintOutput("Market position type  " + marketPosition.ToString() + " not supported.");
            }

            return orderAction;
        }

        private void IncrementBuyPopDelayedTradeCount()
        {
            if (currentBuyPopDelayedStatus != TickHunterPopDelayedTypes.TradeCount5)
            {
                if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.Disabled)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount1;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount1)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount2;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount2)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount3;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount3)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount4;
                }
                else
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount5;
                }

                lastToggleBuyPopDelayedStatus = nextBuyPopDelayedStatus;
                currentBuyPopDelayedStatus = nextBuyPopDelayedStatus;
                lastBuyPopDelayedChangeTime = GetDateTimeNow(); // no delay
                PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();
            }
        }

        private void IncrementSellPopDelayedTradeCount()
        {
            if (currentSellPopDelayedStatus != TickHunterPopDelayedTypes.TradeCount5)
            {
                if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.Disabled)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount1;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount1)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount2;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount2)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount3;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount3)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount4;
                }
                else
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount5;
                }

                lastToggleSellPopDelayedStatus = nextSellPopDelayedStatus;
                currentSellPopDelayedStatus = nextSellPopDelayedStatus;
                lastSellPopDelayedChangeTime = GetDateTimeNow(); // no delay
                PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();
            }
        }

        private void DecrementBuyPopDelayedTradeCount(string signalName)
        {
            if (currentBuyPopDelayedStatus != TickHunterPopDelayedTypes.Disabled)
            {
                if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount5)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount4;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount4)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount3;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount3)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount2;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount2)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount1;
                }
                else if (currentBuyPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount1)
                {
                    nextBuyPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
                }

                lastToggleBuyPopDelayedStatus = nextBuyPopDelayedStatus;
                currentBuyPopDelayedStatus = nextBuyPopDelayedStatus;
                lastBuyPopDelayedChangeTime = GetDateTimeNow(); // no delay
                PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();

                if (lastToggleBuyPopDelayedStatus != TickHunterPopDelayedTypes.Disabled)
                {
                    string buttonText = "";
                    string buttonToolTip = "";

                    GetPopButtonText(TickHunterPopTypes.PopPlus, lastToggleBuyPopDelayedStatus, out buttonText, out buttonToolTip);

                    SetBuyPopButton(BuyPopButton, buttonText, buttonToolTip, lastToggleBuyPopDelayedStatus, PopActivateColorDelaySeconds, Brushes.HotPink);
                }
                else
                {
                    DeactivateBuyPopButton(signalName);
                }
            }
        }

        private void DecrementSellPopDelayedTradeCount(string signalName)
        {
            if (currentSellPopDelayedStatus != TickHunterPopDelayedTypes.Disabled)
            {
                if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount5)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount4;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount4)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount3;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount3)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount2;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount2)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.TradeCount1;
                }
                else if (currentSellPopDelayedStatus == TickHunterPopDelayedTypes.TradeCount1)
                {
                    nextSellPopDelayedStatus = TickHunterPopDelayedTypes.Disabled;
                }

                lastToggleSellPopDelayedStatus = nextSellPopDelayedStatus;
                currentSellPopDelayedStatus = nextSellPopDelayedStatus;
                lastSellPopDelayedChangeTime = GetDateTimeNow(); // no delay
                PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();

                if (lastToggleSellPopDelayedStatus != TickHunterPopDelayedTypes.Disabled)
                {
                    string buttonText = "";
                    string buttonToolTip = "";

                    GetPopButtonText(TickHunterPopTypes.PopMinus, lastToggleSellPopDelayedStatus, out buttonText, out buttonToolTip);

                    SetSellPopButton(SellPopButton, buttonText, buttonToolTip, lastToggleSellPopDelayedStatus, PopActivateColorDelaySeconds, Brushes.HotPink);
                }
                else
                {
                    DeactivateSellPopButton(signalName);
                }
            }
        }

        private void DecrementAutoPilotTradeCount()
        {
            if (currentAutoPilotStatus != TickHunterAutoPilotTypes.Disabled)
            {
                if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount10)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount9;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount9)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount8;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount8)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount7;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount7)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount6;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount6)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount5;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount5)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount4;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount4)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount3;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount3)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount2;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount2)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.TradeCount1;
                }
                else if (currentAutoPilotStatus == TickHunterAutoPilotTypes.TradeCount1)
                {
                    nextAutoPilotStatus = TickHunterAutoPilotTypes.Disabled;
                }

                lastToggleEntryAutoPilotStatus = nextAutoPilotStatus;
                currentAutoPilotStatus = nextAutoPilotStatus;
                lastAutoPilotChangeTime = GetDateTimeNow(); // no delay
            }
        }

        private bool AllowNewAutoPilotOrders(Instrument instrument)
        {
            bool allowNewAutoPilotEntries = false;

            //double netLiquidationBalance = GetNetLiquidationBalance();

            if (!activeDayOverMaxLossAutoClose) //!HasAccountHitEquityRemainingFloor(netLiquidationBalance))
            {
                allowNewAutoPilotEntries = true;
            }


            return allowNewAutoPilotEntries;
        }

        /*
        private int GetMaxPositionSize(Instrument instrument)
        {
            int maxPositionSize = 0;

            if (account != null && account.Risk != null && account.Risk.ByMasterInstrument.ContainsKey(instrument.MasterInstrument))
            {
                maxPositionSize = account.Risk.ByMasterInstrument[instrument.MasterInstrument].MaxPositionSize;
            }
            else
            {
                RealLogger.PrintOutput("ERROR: Missing max position size for instrument '" + instrument.FullName + "'");
            }

            return maxPositionSize;
        }
        */

        private double GetAccountIntradayExcessMargin()
        {
            double intradayExcessMargin = 0;

            if (account != null)
            {
                intradayExcessMargin = Math.Round(account.Get(AccountItem.ExcessIntradayMargin, Currency.UsDollar), 2);
            }

            return intradayExcessMargin;
        }

        private double GetInstrumentIntradayMarginDollars(Instrument instrument)
        {
            double intradayMarginDollars = OtherIntradayMarginDollars;

            if (instrument == mnqInstrument)
            {
                intradayMarginDollars = MNQIntradayMarginDollars;
            }
            else if (instrument == mesInstrument)
            {
                intradayMarginDollars = MESIntradayMarginDollars;
            }
            else if (instrument == mymInstrument)
            {
                intradayMarginDollars = MYMIntradayMarginDollars;
            }
            else if (instrument == m2kInstrument)
            {
                intradayMarginDollars = M2KIntradayMarginDollars;
            }
            else if (instrument == nqInstrument)
            {
                intradayMarginDollars = NQIntradayMarginDollars;
            }
            else if (instrument == esInstrument)
            {
                intradayMarginDollars = ESIntradayMarginDollars;
            }
            else if (instrument == ymInstrument)
            {
                intradayMarginDollars = YMIntradayMarginDollars;
            }
            else if (instrument == rtyInstrument)
            {
                intradayMarginDollars = RTYIntradayMarginDollars;
            }


            /*
			if (account != null && account.Risk != null && account.Risk.ByMasterInstrument.ContainsKey(instrument.MasterInstrument))
            {
                if (orderAction == OrderAction.Buy)
                {
                    intradayMargin = account.Risk.ByMasterInstrument[instrument.MasterInstrument].BuyIntradayMargin;
                }
                else if (orderAction == OrderAction.Sell)
                {
                    intradayMargin = account.Risk.ByMasterInstrument[instrument.MasterInstrument].SellIntradayMargin;
                }
                else
                {
                    RealLogger.PrintOutput("GetInstrumentIntradayMargin: Order action type  " + orderAction.ToString() + " not supported.");
                }
            }
            else
            {
                RealLogger.PrintOutput("ERROR: Missing intraday margin for instrument '" + instrument.FullName + "'");
            }
			*/

            return intradayMarginDollars;
        }

        private int GetInstrumentPositionMaxVolume(Instrument instrument)
        {
            int positionMaxVolume = OtherPositionMaxVolume;

            if (instrument == mnqInstrument)
            {
                positionMaxVolume = MNQPositionMaxVolume;
            }
            else if (instrument == mesInstrument)
            {
                positionMaxVolume = MESPositionMaxVolume;
            }
            else if (instrument == mymInstrument)
            {
                positionMaxVolume = MYMPositionMaxVolume;
            }
            else if (instrument == m2kInstrument)
            {
                positionMaxVolume = M2KPositionMaxVolume;
            }
            else if (instrument == nqInstrument)
            {
                positionMaxVolume = NQPositionMaxVolume;
            }
            else if (instrument == esInstrument)
            {
                positionMaxVolume = ESPositionMaxVolume;
            }
            else if (instrument == ymInstrument)
            {
                positionMaxVolume = YMPositionMaxVolume;
            }
            else if (instrument == rtyInstrument)
            {
                positionMaxVolume = RTYPositionMaxVolume;
            }

            return positionMaxVolume;
        }

        private bool OrderMarginCheck(Instrument instrument, bool requireMarginCheck, OrderAction orderAction, int volume, int buyPositionVolume, int sellPositionVolume)
        {
            bool marginCheckSucceeded = false;

            if (HasRanOnceFirstCycle())
            {
                if (!requireMarginCheck)
                {
                    marginCheckSucceeded = true;
                    return marginCheckSucceeded;
                }

                double intradayMargin = GetInstrumentIntradayMarginDollars(instrument);

                bool hasValidRiskTemplate = intradayMargin > 0;

                if (hasValidRiskTemplate)
                {
                    double excessInitialMargin = account.Get(AccountItem.ExcessIntradayMargin, Currency.UsDollar);
                    double totalRequiredIntradayMargin = volume * intradayMargin;
                    double remainingExcessIntradayMargin = 0;

                    bool addingToExistingPosition = (orderAction == OrderAction.Buy && buyPositionVolume > 0)
                        || (orderAction == OrderAction.Sell && sellPositionVolume > 0);

                    bool adddingToNoPosition = (buyPositionVolume == 0 && sellPositionVolume == 0);

                    bool reducingAnExistingPosition = (orderAction == OrderAction.Buy && sellPositionVolume > 0) ||
                        (orderAction == OrderAction.Sell && buyPositionVolume > 0);

                    if (addingToExistingPosition || adddingToNoPosition)
                    {
                        remainingExcessIntradayMargin = excessInitialMargin - totalRequiredIntradayMargin;
                    }
                    else if (reducingAnExistingPosition)
                    {
                        remainingExcessIntradayMargin = excessInitialMargin + totalRequiredIntradayMargin;
                    }

                    marginCheckSucceeded = remainingExcessIntradayMargin > (ExcessIntradayMarginMinDollars + MIN_EXCESS_MARGIN);
                }
                else
                {
                    RealLogger.PrintOutput("Missing valid risk template attached to account with IntradayMargin and IntradayMarginDollars equals zero.");

                    marginCheckSucceeded = true;
                }
            }

            return marginCheckSucceeded;
        }

        private bool GetPositionVolume(Instrument instrument, out int buyVolume, out int sellVolume)
        {
            bool positionFound = false;
            buyVolume = 0;
            sellVolume = 0;

            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;

                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    if (position.Instrument == instrument)
                    {
                        positionFound = true;

                        if (position.MarketPosition == MarketPosition.Long)
                        {
                            buyVolume += position.Quantity;
                        }
                        else if (position.MarketPosition == MarketPosition.Short)
                        {
                            sellVolume += position.Quantity;
                        }
                    }
                }
            }

            return positionFound;
        }

        private bool GetPositionVolume(Instrument instrument, out int buyVolume, out double buyPositionPrice, out int sellVolume, out double sellPositionPrice, out DateTime positionModifyDate)
        {
            bool positionFound = false;
            buyVolume = 0;
            sellVolume = 0;
            buyPositionPrice = 0;
            sellPositionPrice = 0;
            positionModifyDate = DateTime.MinValue;

            int positionCount = RealPositionService.PositionCount;

            for (int index = 0; index < positionCount; index++)
            {
                RealPosition position = null;

                if (RealPositionService.TryGetByIndex(index, out position))
                {
                    if (position.Instrument == instrument)
                    {
                        positionFound = true;
                        positionModifyDate = position.ModifyDate;

                        if (position.MarketPosition == MarketPosition.Long)
                        {
                            buyPositionPrice = position.AveragePrice;
                            buyVolume += position.Quantity;
                        }
                        else if (position.MarketPosition == MarketPosition.Short)
                        {
                            sellPositionPrice = position.AveragePrice;
                            sellVolume += position.Quantity;
                        }
                    }
                }
            }

            return positionFound;
        }



        private void AttemptToEngageAutoAddOn()
        {
            string signalName = "EngageAutoAddOn";
            if (currentAutoAddOnStatus == TickHunterAutoAddOnTypes.Enabled
                && RealOrderService.AreAllOrderUpdateCyclesComplete())
            {
                if (!IsAccountFlat(attachedInstrument)
                    && autoAddOnMaxDollars > 0
                    && attachedInstrumentPositionMaxVolume > 0)
                {
                    bool fullyEnabled = lastAddOnMaxCycleChangeTime <= GetDateTimeNow();

                    if (fullyEnabled)
                    {
                        lastAddOnMaxCycleChangeTime = (GetDateTimeNow()).AddSeconds(AutoAddOnMaxCycleDelaySeconds);

                        int positionCount = RealPositionService.PositionCount;

                        int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                        int newAddOnVolume = autoEntryVolume;

                        double unrealizedProfitLoss = 0;
                        int buyPositionVolumeSize = 0;
                        int sellPositionVolumeSize = 0;
                        bool passedInProfitCheck = false;
                        bool passedPositionMaxVolumeCheck = false;
                        bool passedIntradayMarginCheck = false;
                        OrderAction addOnOrderAction = OrderAction.Buy;
                        DateTime addOnReadyTime = DateTime.MinValue;

                        double autoAddOnMaxDollarsFlipped = autoAddOnMaxDollars * -1;

                        for (int index = 0; index < positionCount; index++)
                        {
                            RealPosition position = null;

                            if (RealPositionService.TryGetByIndex(index, out position))
                            {
                                if (RealPositionService.IsValidPosition(position, attachedInstrument) && position.IsValid)
                                {
                                    position.StoreState();

                                    bool addOnPastDelay = position.CreateDate.AddSeconds(AutoAddOnInnerWindowDelaySeconds) <= GetDateTimeNow();

                                    if (addOnPastDelay)
                                    {
                                        if (position.MarketPosition == MarketPosition.Long)
                                        {
                                            addOnOrderAction = OrderAction.Buy;
                                        }
                                        else if (position.MarketPosition == MarketPosition.Short)
                                        {
                                            addOnOrderAction = OrderAction.Sell;
                                        }

                                        buyPositionVolumeSize = (addOnOrderAction == OrderAction.Buy) ? (position.Quantity) : 0;
                                        sellPositionVolumeSize = (addOnOrderAction == OrderAction.Sell) ? (position.Quantity) : 0;

                                        bool passedNextAddOnCheck = false;
                                        bool passedNextAddOn1Check = false;

                                        double riskInfoTotalDollars = 0;
                                        double riskInfoBlendedDollars = 0;


                                        if (IsBlendedInstrumentEnabled() && blendedInstrumentHasPosition)
                                        {
                                            riskInfoBlendedDollars = Math.Round(GetPositionProfitWithStoLoss(blendedInstrument, blendedInstrumentMarketPosition, blendedInstrumentPositionQuantity, blendedInstrumentPositionPrice, blendedInstrumentPositionStopLossPrice), 2);
                                            riskInfoTotalDollars += riskInfoBlendedDollars;
                                        }

                                        bool stillPassedPositionMaxVolumeCheck = false;
                                        bool stillPassedIntradayMarginCheck = false;

                                        bool hasAttachedStopLoss = attachedInstrumentPositionStopLossPrice > 0;
                                        bool hasBlendedStopLoss = blendedInstrumentPositionStopLossPrice > 0;

                                        if (hasAttachedStopLoss && (!blendedInstrumentHasPosition
                                            || (blendedInstrumentHasPosition && hasBlendedStopLoss)))
                                        {
                                            int nextAddOnCount = 1;

                                            double nextPositionPrice = attachedInstrumentPositionPrice;

                                            if (attachedInstrumentMarketPosition == MarketPosition.Long)
                                            {
                                                double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                                                nextPositionPrice = Math.Max(attachedInstrumentPositionPrice, askPrice);
                                            }
                                            else if (attachedInstrumentMarketPosition == MarketPosition.Short)
                                            {
                                                double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                                                nextPositionPrice = Math.Min(attachedInstrumentPositionPrice, bidPrice);
                                            }


                                            double nextAddOnDollars = Math.Round(GetPositionProfitWithStoLoss(attachedInstrument, attachedInstrumentMarketPosition, attachedInstrumentPositionQuantity + nextAddOnCount, nextPositionPrice, attachedInstrumentPositionStopLossPrice), 2);
                                            double nextAddOnTotalDollars = (nextAddOnDollars + riskInfoBlendedDollars);

                                            //RealLogger.PrintOutput("*** DEBUG nextAddOnDollars=" + nextAddOnDollars + " buyPositionVolumeSize=" + buyPositionVolumeSize + " sellPositionVolumeSize=" + sellPositionVolumeSize + " attachedInstrumentPositionStopLossPrice=" + attachedInstrumentPositionStopLossPrice);

                                            //RealLogger.PrintOutput("*** DEBUG autoAddOnMaxDollarsFlipped=" + autoAddOnMaxDollarsFlipped + " nextAddOn1TotalDollars=" + nextAddOn1TotalDollars);

                                            bool riskDollarsInverted = nextAddOnTotalDollars > 0;


                                            if (nextAddOnTotalDollars < 0 || riskDollarsInverted)
                                            {
                                                if (autoAddOnMaxDollarsFlipped <= nextAddOnTotalDollars || riskDollarsInverted)
                                                {
                                                    passedNextAddOnCheck = true;
                                                    passedNextAddOn1Check = true;
                                                    newAddOnVolume = 1;

                                                    passedPositionMaxVolumeCheck = attachedInstrumentPositionMaxVolume > 0 && (position.Quantity + newAddOnVolume) <= attachedInstrumentPositionMaxVolume;
                                                    passedIntradayMarginCheck = OrderMarginCheck(attachedInstrument, true, addOnOrderAction, newAddOnVolume, buyPositionVolumeSize, sellPositionVolumeSize);

                                                    for (var i = 2; i <= attachedInstrumentPositionMaxVolume; i++)
                                                    {
                                                        nextAddOnCount = i;
                                                        nextAddOnDollars = Math.Round(GetPositionProfitWithStoLoss(attachedInstrument, attachedInstrumentMarketPosition, attachedInstrumentPositionQuantity + nextAddOnCount, nextPositionPrice, attachedInstrumentPositionStopLossPrice), 2);
                                                        nextAddOnTotalDollars = (nextAddOnDollars + riskInfoBlendedDollars);
                                                        stillPassedPositionMaxVolumeCheck = attachedInstrumentPositionMaxVolume > 0 && (position.Quantity + nextAddOnCount) <= attachedInstrumentPositionMaxVolume;
                                                        stillPassedIntradayMarginCheck = OrderMarginCheck(attachedInstrument, true, addOnOrderAction, nextAddOnCount, buyPositionVolumeSize, sellPositionVolumeSize);

                                                        /*
                                                        Print(" i=" + i + " stillPassedPositionMaxVolumeCheck=" + stillPassedPositionMaxVolumeCheck
                                                            + " stillPassedIntradayMarginCheck=" + stillPassedIntradayMarginCheck
                                                            + " stillPassedIntradayMarginCheck=" + stillPassedIntradayMarginCheck
                                                            + " read=" + (autoAddOnMaxDollarsFlipped <= nextAddOnTotalDollars)
                                                            + " nextAddOnTotalDollars=" + nextAddOnTotalDollars
                                                            + " newAddOnVolume=" + newAddOnVolume);
                                                        */

                                                        if (stillPassedPositionMaxVolumeCheck
                                                            && stillPassedIntradayMarginCheck
                                                            && autoAddOnMaxDollarsFlipped <= nextAddOnTotalDollars)
                                                        {
                                                            newAddOnVolume = i;
                                                        }
                                                        else
                                                        {
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }

                                        /*
                                        RealLogger.PrintOutput(" passedPositionMaxVolumeCheck=" + passedPositionMaxVolumeCheck
                                            + " passedIntradayMarginCheck=" + passedIntradayMarginCheck
                                            + " passedNextAddOnCheck =" + passedNextAddOnCheck
                                            + " newAddOnVolume =" + newAddOnVolume
                                            );
                                        */


                                        if (!passedNextAddOnCheck)
                                        {
                                            RealLogger.PrintOutput("Auto AddOn detected current stop-loss risk dollars too high to add more volume" + " via " + signalName);
                                        }
                                        else if (!passedIntradayMarginCheck)
                                        {
                                            RealLogger.PrintOutput("Auto AddOn detected excess intraday margin too low to add more volume" + " via " + signalName);
                                        }

                                        DisableAutoAddOnButton(0);

                                        if (passedPositionMaxVolumeCheck
                                            && passedIntradayMarginCheck
                                            && passedNextAddOnCheck)
                                        {
                                            if (!position.HasStateChanged()
                                            && !position.IsFlat()
                                            && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                            {
                                                RealLogger.PrintOutput("AutoAddOn event triggered and now opening market " + addOnOrderAction.ToString().ToLower() + " order with volume " + newAddOnVolume + " via " + signalName);

                                                SubmitMarketOrder(signalName, attachedInstrument, addOnOrderAction, OrderEntry.Automated, newAddOnVolume);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    bool fullyEnabled = lastAddOnMaxCycleChangeTime <= GetDateTimeNow();

                    if (fullyEnabled)
                    {
                        lastAddOnMaxCycleChangeTime = (GetDateTimeNow()).AddSeconds(AutoAddOnMaxCycleDelaySeconds);

                        if (IsAccountFlat(attachedInstrument))
                            RealLogger.PrintOutput("ERROR: Auto AddOn requires a position.  No position found for instrument '" + attachedInstrument.FullName + "'" + " via " + signalName);

                        DisableAutoAddOnButton(0);
                    }
                }
            }
        }

        private void AttemptToEngagePopDelayedEntry()
        {
            string signalName = "PopDelayedEntry";

            if ((useBuyPopActivateFlag || useSellPopActivateFlag)
                && RealOrderService.AreAllOrderUpdateCyclesComplete()
                && PopDelayedEntryRunOncePerBar.IsFirstRunThisBar)
            {
                PopDelayedEntryRunOncePerBar.SetRunCompletedThisBar();

                bool allowNewAutoPilotEntries = AllowNewAutoPilotOrders(attachedInstrument);

                if (!allowNewAutoPilotEntries)
                {
                    RealLogger.PrintOutput("ERROR: Blocking new Pop Delayed Entry orders as stop-loss equity remaining floor hit." + " via " + signalName);
                }
                else
                {
                    if (useBuyPopActivateFlag)
                    {
                        bool isAutoPilotProfilePeppy = currentAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Peppy;
                        bool isAutoPilotProfileSleepy = currentAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Sleepy;
                        bool isAboveRushLine = previous1ClosePrice >= autoCloseAndTrailRLValue;
                        bool isBelowRushLine = previous1ClosePrice <= autoCloseAndTrailRLValue;
                        bool buyCreeperContinuation = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2;
                        bool sellCreeperContinuation = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2;

                        bool passedLimitToPullbackCheck = (!popLimitToPullbackFlag) || (popLimitToPullbackFlag && IsInValidBuyPopPullBack());

                        bool passedLimitPopAlignedCreeper = (!isAutoPilotProfilePeppy || !UsePeppyLimitPopAlignedCreeper)
                            || (isAutoPilotProfilePeppy && UsePeppyLimitPopAlignedCreeper && buyCreeperContinuation);
                        bool passedLimitPopCounterCreeper = (!isAutoPilotProfileSleepy || !UseSleepyLimitPopCounterCreeper)
                            || (isAutoPilotProfileSleepy && UseSleepyLimitPopCounterCreeper && sellCreeperContinuation);

                        bool passedLimitPopAlignedRushLine = (!isAutoPilotProfilePeppy || !UsePeppyLimitPopAlignedRushLine)
                            || (isAutoPilotProfilePeppy && UsePeppyLimitPopAlignedRushLine && isAboveRushLine);
                        bool passedLimitPopCounterRushLine = (!isAutoPilotProfileSleepy || !UseSleepyLimitPopCounterRushLine)
                            || (isAutoPilotProfileSleepy && UseSleepyLimitPopCounterRushLine && isBelowRushLine);

                        int popDropBuyCount = 0;
                        int popDropSellCount = 0;

                        bool passedNoExistingPopOrderCheck = !GetPopDropOrderCount(out popDropBuyCount, out popDropSellCount);

                        /*
                        Print("*** DEBUG passedLimitToPullbackCheck=" + passedLimitToPullbackCheck
                            + " passedLimitPopAlignedCreeper=" + passedLimitPopAlignedCreeper
                            + " passedLimitPopCounterCreeper=" + passedLimitPopCounterCreeper
                            + " passedLimitPopAlignedRushLine=" + passedLimitPopAlignedRushLine
                            + " passedLimitPopCounterRushLine=" + passedLimitPopCounterRushLine);
                        */

                        if (passedNoExistingPopOrderCheck
                            && passedLimitToPullbackCheck
                            && (passedLimitPopAlignedCreeper || passedLimitPopAlignedRushLine)
                            && (passedLimitPopCounterCreeper || passedLimitPopCounterRushLine))
                        {
                            DecrementBuyPopDelayedTradeCount(signalName);

                            //RealLogger.PrintOutput("Attempting to open a buy stop order (" + attachedInstrument.FullName + ") via " + signalName);
                            HandleBuyPop(signalName);
                        }
                        else
                        {
                            return;
                        }
                    }
                    else if (useSellPopActivateFlag)
                    {
                        bool isAutoPilotProfilePeppy = currentAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Peppy;
                        bool isAutoPilotProfileSleepy = currentAutoPilotProfileStatus == TickHunterAutoPilotProfileTypes.Sleepy;
                        bool isAboveRushLine = previous1ClosePrice >= autoCloseAndTrailRLValue;
                        bool isBelowRushLine = previous1ClosePrice <= autoCloseAndTrailRLValue;
                        bool buyCreeperContinuation = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2;
                        bool sellCreeperContinuation = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2;

                        bool passedLimitToPullbackCheck = (!popLimitToPullbackFlag) || (popLimitToPullbackFlag && IsInValidSellPopPullBack());

                        bool passedLimitPopAlignedCreeper = (!isAutoPilotProfilePeppy || !UsePeppyLimitPopAlignedCreeper)
                            || (isAutoPilotProfilePeppy && UsePeppyLimitPopAlignedCreeper && sellCreeperContinuation);
                        bool passedLimitPopCounterCreeper = (!isAutoPilotProfileSleepy || !UseSleepyLimitPopCounterCreeper)
                            || (isAutoPilotProfileSleepy && UseSleepyLimitPopCounterCreeper && buyCreeperContinuation);

                        bool passedLimitPopAlignedRushLine = (!isAutoPilotProfilePeppy || !UsePeppyLimitPopAlignedRushLine)
                            || (isAutoPilotProfilePeppy && UsePeppyLimitPopAlignedRushLine && isBelowRushLine);
                        bool passedLimitPopCounterRushLine = (!isAutoPilotProfileSleepy || !UseSleepyLimitPopCounterRushLine)
                            || (isAutoPilotProfileSleepy && UseSleepyLimitPopCounterRushLine && isAboveRushLine);

                        int popDropBuyCount = 0;
                        int popDropSellCount = 0;

                        bool passedNoExistingPopOrderCheck = !GetPopDropOrderCount(out popDropBuyCount, out popDropSellCount);
                        /*
                        Print("*** DEBUG passedLimitToPullbackCheck=" + passedLimitToPullbackCheck
                            + " passedLimitPopAlignedCreeper=" + passedLimitPopAlignedCreeper
                            + " passedLimitPopCounterCreeper=" + passedLimitPopCounterCreeper
                            + " passedLimitPopAlignedRushLine=" + passedLimitPopAlignedRushLine
                            + " passedLimitPopCounterRushLine=" + passedLimitPopCounterRushLine);
                        */

                        if (passedNoExistingPopOrderCheck
                            && passedLimitToPullbackCheck
                            && (passedLimitPopAlignedCreeper || passedLimitPopAlignedRushLine)
                            && (passedLimitPopCounterCreeper || passedLimitPopCounterRushLine))
                        {
                            DecrementSellPopDelayedTradeCount(signalName);

                            //RealLogger.PrintOutput("Attempting to open a buy stop order (" + attachedInstrument.FullName + ") via " + signalName);
                            HandleSellPop(signalName);
                        }
                        else
                        {
                            return;
                        }
                    }
                }

                //DeactivatePopDelayedEntryFeatures(signalName);
            }
        }

        private void AttemptToEngageAutoPilot()
        {
            string signalName = "AttemptToEngageAutoPilot";

            bool autoPilotIsInAlertMode = (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup);

            if ((IsAccountFlat(attachedInstrument) || useAutoPilotAddOnFlag || autoPilotIsInAlertMode)
                && RealOrderService.AreAllOrderUpdateCyclesComplete()
                && AutoPilotRunOncePerBar.IsFirstRunThisBar)
            {
                AutoPilotRunOncePerBar.SetRunCompletedThisBar();

                if ((currentTradeSignalStatus != TickHunterTradeSignalTypes.Disabled && currentAutoPilotStatus != TickHunterAutoPilotTypes.Disabled)
                    || currentAutoPilotLiteStatus != TickHunterAutoPilotLiteTypes.Disabled)
                {
                    bool allowNewAutoPilotEntries = AllowNewAutoPilotOrders(attachedInstrument);

                    if (!allowNewAutoPilotEntries)
                    {
                        RealLogger.PrintOutput("ERROR: Blocking new AutoPilot orders as stop-loss equity remaining floor hit." + " via " + signalName);
                        DeactivateAutoEntryFeatures(signalName);
                    }
                    else
                    {
                        signalName = "AutoPilot";
                        string algoSetupName = "AutoPilot";
                        MarketPosition openMarketPosition = MarketPosition.Flat;
                        //RealLogger.PrintOutput("Trade signal autoPilotBullishTrend=" + autoPilotBullishTrend + " currentTradeSignalStatus= " + currentTradeSignalStatus);// + " autoPilotBullishTrend= " + autoPilotBullishTrend + " tradeSignalBullishMicroTrend=" + tradeSignalBullishMicroTrend + " tradeSignalBullishMicroTrendPrevious=" + tradeSignalBullishMicroTrendPrevious);

                        bool requireSpeedLineCheck = UseAutoPilotSpeedLineFilter;
                        bool passedBuySpeedLineFilterCheck = false;
                        bool passedSellSpeedLineFilterCheck = false;
                        bool isCloseAboveSpeedLine = (autoPilotSpeedLineFilterValue <= previous1ClosePrice);
                        bool isCloseAboveSpeedLine2 = (autoPilotSpeedLineFilterValue2 <= previous2ClosePrice);
                        bool isCloseAboveSpeedLine3 = (autoPilotSpeedLineFilterValue3 <= previous3ClosePrice);
                        bool isCloseAboveSpeedLine4 = (autoPilotSpeedLineFilterValue4 <= previous4ClosePrice);
                        bool isCloseAboveSpeedLine5 = (autoPilotSpeedLineFilterValue5 <= previous5ClosePrice);
                        bool isCloseAboveSpeedLine6 = (autoPilotSpeedLineFilterValue6 <= previous6ClosePrice);
                        bool isCloseAboveSpeedLine7 = (autoPilotSpeedLineFilterValue7 <= previous7ClosePrice);
                        bool isCloseAboveSpeedLine8 = (autoPilotSpeedLineFilterValue8 <= previous8ClosePrice);
                        bool isCloseAboveSpeedLine9 = (autoPilotSpeedLineFilterValue9 <= previous9ClosePrice);

                        bool buyZombieBoostedSetup = (autoPilotSetupZombieBuySetup2 && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup3 && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup4 && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup5 && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup6 && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup7 && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup8 && autoPilotSetupZombieBuyContinuation7 && !previous7CandleBullish && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                            || (autoPilotSetupZombieBuySetup9 && autoPilotSetupZombieBuyContinuation8 && !previous8CandleBullish && autoPilotSetupZombieBuyContinuation7 && !previous7CandleBullish && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish);


                        bool sellZombieBoostedSetup = (autoPilotSetupZombieSellSetup2 && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup3 && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup4 && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup5 && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup6 && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup7 && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup8 && autoPilotSetupZombieSellContinuation7 && previous7CandleBullish && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                            || (autoPilotSetupZombieSellSetup9 && autoPilotSetupZombieSellContinuation8 && previous8CandleBullish && autoPilotSetupZombieSellContinuation7 && previous7CandleBullish && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish);

                        //bool buyZombieSetup = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                        //bool sellZombieSetup = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;

                        bool buyZombieSetup = (autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode)
                            || (requireSpeedLineCheck &&
                                (
                                    (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && autoPilotSetupZombieValue3 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && autoPilotSetupZombieValue4 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && !isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupBuyCode && autoPilotSetupZombieValue5 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && !isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupBuyCode && !isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupBuyCode && autoPilotSetupZombieValue6 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && !isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupBuyCode && !isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupBuyCode && !isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupBuyCode && autoPilotSetupZombieValue7 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && !isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupBuyCode && !isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupBuyCode && !isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupBuyCode && !isCloseAboveSpeedLine7 && autoPilotSetupZombieValue7 == ZombieSetupBuyCode && autoPilotSetupZombieValue8 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && !isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupBuyCode && !isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupBuyCode && !isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupBuyCode && !isCloseAboveSpeedLine7 && autoPilotSetupZombieValue7 == ZombieSetupBuyCode && !isCloseAboveSpeedLine8 && autoPilotSetupZombieValue8 == ZombieSetupBuyCode && autoPilotSetupZombieValue9 == ZombieSetupSellCode)
                                    || (isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupBuyCode && !isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupBuyCode && !isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupBuyCode && !isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupBuyCode && !isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupBuyCode && !isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupBuyCode && !isCloseAboveSpeedLine7 && autoPilotSetupZombieValue7 == ZombieSetupBuyCode && !isCloseAboveSpeedLine8 && autoPilotSetupZombieValue8 == ZombieSetupBuyCode && !isCloseAboveSpeedLine9 && autoPilotSetupZombieValue9 == ZombieSetupBuyCode && autoPilotSetupZombieValue10 == ZombieSetupSellCode)
                                )
                            );

                        bool sellZombieSetup = (autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode)
                            || (requireSpeedLineCheck &&
                                (
                                    (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && autoPilotSetupZombieValue3 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && autoPilotSetupZombieValue4 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupSellCode && autoPilotSetupZombieValue5 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupSellCode && isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupSellCode && autoPilotSetupZombieValue6 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupSellCode && isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupSellCode && isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupSellCode && autoPilotSetupZombieValue7 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupSellCode && isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupSellCode && isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupSellCode && isCloseAboveSpeedLine7 && autoPilotSetupZombieValue7 == ZombieSetupSellCode && autoPilotSetupZombieValue8 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupSellCode && isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupSellCode && isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupSellCode && isCloseAboveSpeedLine7 && autoPilotSetupZombieValue7 == ZombieSetupSellCode && isCloseAboveSpeedLine8 && autoPilotSetupZombieValue8 == ZombieSetupSellCode && autoPilotSetupZombieValue9 == ZombieSetupBuyCode)
                                    || (!isCloseAboveSpeedLine && autoPilotSetupZombieValue == ZombieSetupSellCode && isCloseAboveSpeedLine2 && autoPilotSetupZombieValue2 == ZombieSetupSellCode && isCloseAboveSpeedLine3 && autoPilotSetupZombieValue3 == ZombieSetupSellCode && isCloseAboveSpeedLine4 && autoPilotSetupZombieValue4 == ZombieSetupSellCode && isCloseAboveSpeedLine5 && autoPilotSetupZombieValue5 == ZombieSetupSellCode && isCloseAboveSpeedLine6 && autoPilotSetupZombieValue6 == ZombieSetupSellCode && isCloseAboveSpeedLine7 && autoPilotSetupZombieValue7 == ZombieSetupSellCode && isCloseAboveSpeedLine8 && autoPilotSetupZombieValue8 == ZombieSetupSellCode && isCloseAboveSpeedLine9 && autoPilotSetupZombieValue9 == ZombieSetupSellCode && autoPilotSetupZombieValue10 == ZombieSetupBuyCode)
                                )
                            );

                        bool buyCreeperZombieSetup = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode
                            && (autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2);
                        bool sellCreeperZombieSetup = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode
                            && (autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2);

                        bool buyRiverFilter = (previous1ClosePrice >= autoCloseAndTrailMA4Value);
                        bool sellRiverFilter = (previous1ClosePrice < autoCloseAndTrailMA4Value);

                        bool buyDriftFilter = (previous1ClosePrice >= autoCloseAndTrailDL4Value);
                        bool sellDriftFilter = (previous1ClosePrice < autoCloseAndTrailDL4Value);

                        bool buyZombieRiverBreak = autoPilotSetupZombieBuyContinuation1
                            && (
                                (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8 && previous9ClosePrice < autoCloseAndTrailMA4Value9)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8 && previous9ClosePrice >= autoCloseAndTrailMA4Value9 && previous10ClosePrice < autoCloseAndTrailMA4Value10)
                            );

                        bool sellZombieRiverBreak = autoPilotSetupZombieSellContinuation1
                            && (
                                (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8 && previous9ClosePrice >= autoCloseAndTrailMA4Value9)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8 && previous9ClosePrice < autoCloseAndTrailMA4Value9 && previous10ClosePrice >= autoCloseAndTrailMA4Value10)
                            );

                        bool buyZombieDriftBreak = autoPilotSetupZombieBuyContinuation1
                            && (
                                (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9 && previous10ClosePrice < autoCloseAndTrailDL4Value10)
                            );

                        bool sellZombieDriftBreak = autoPilotSetupZombieSellContinuation1
                            && (
                                (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9 && previous10ClosePrice >= autoCloseAndTrailDL4Value10)
                            );


                        bool buyWalkerSetup = (!AutoPilotSetupWalkerFreshCrossOnly && autoPilotSetupWalkerValue <= previous1ClosePrice) ||
                            (AutoPilotSetupWalkerFreshCrossOnly && autoPilotSetupWalkerValue <= previous1ClosePrice && autoPilotSetupWalkerValue2 > previous2ClosePrice);
                        bool sellWalkerSetup = (!AutoPilotSetupWalkerFreshCrossOnly && autoPilotSetupWalkerValue > previous1ClosePrice) ||
                            (AutoPilotSetupWalkerFreshCrossOnly && autoPilotSetupWalkerValue > previous1ClosePrice && autoPilotSetupWalkerValue2 <= previous2ClosePrice);
                        /*
                        bool buyCreeperSetup = (previous1CandleBullish && autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3)
                            || (previous1CandleBullish && !previous2CandleBullish && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3 && autoPilotSetupCreeperValue3 < autoPilotSetupCreeperValue4)
                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && autoPilotSetupCreeperValue3 >= autoPilotSetupCreeperValue4 && autoPilotSetupCreeperValue4 < autoPilotSetupCreeperValue5)
                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && autoPilotSetupCreeperValue4 >= autoPilotSetupCreeperValue5 && autoPilotSetupCreeperValue5 < autoPilotSetupCreeperValue6)
                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && autoPilotSetupCreeperValue5 >= autoPilotSetupCreeperValue6 && autoPilotSetupCreeperValue6 < autoPilotSetupCreeperValue7)
                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && !previous6CandleBullish && autoPilotSetupCreeperValue6 >= autoPilotSetupCreeperValue7 && autoPilotSetupCreeperValue7 < autoPilotSetupCreeperValue8)
                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && !previous6CandleBullish && !previous7CandleBullish && autoPilotSetupCreeperValue7 >= autoPilotSetupCreeperValue8 && autoPilotSetupCreeperValue8 < autoPilotSetupCreeperValue9)
                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && !previous6CandleBullish && !previous7CandleBullish && !previous8CandleBullish && autoPilotSetupCreeperValue8 >= autoPilotSetupCreeperValue9 && autoPilotSetupCreeperValue9 < autoPilotSetupCreeperValue10);

                        bool sellCreeperSetup = (!previous1CandleBullish && autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3)
                            || (!previous1CandleBullish && previous2CandleBullish && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3 && autoPilotSetupCreeperValue3 >= autoPilotSetupCreeperValue4)
                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && autoPilotSetupCreeperValue3 < autoPilotSetupCreeperValue4 && autoPilotSetupCreeperValue4 >= autoPilotSetupCreeperValue5)
                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && autoPilotSetupCreeperValue4 < autoPilotSetupCreeperValue5 && autoPilotSetupCreeperValue5 >= autoPilotSetupCreeperValue6)
                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && autoPilotSetupCreeperValue5 < autoPilotSetupCreeperValue6 && autoPilotSetupCreeperValue6 >= autoPilotSetupCreeperValue7)
                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && previous6CandleBullish && autoPilotSetupCreeperValue6 < autoPilotSetupCreeperValue7 && autoPilotSetupCreeperValue7 >= autoPilotSetupCreeperValue8)
                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && previous6CandleBullish && previous7CandleBullish && autoPilotSetupCreeperValue7 < autoPilotSetupCreeperValue8 && autoPilotSetupCreeperValue8 >= autoPilotSetupCreeperValue9)
                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && previous6CandleBullish && previous7CandleBullish && previous8CandleBullish && autoPilotSetupCreeperValue8 < autoPilotSetupCreeperValue9 && autoPilotSetupCreeperValue9 >= autoPilotSetupCreeperValue10);
                        */

                        bool altBuyCreeperSetup1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;
                        bool altSellCreeperSetup1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;
                        bool altBuyCreeperSetup2 = autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3 && autoPilotSetupCreeperValue3 < autoPilotSetupCreeperValue4;
                        bool altSellCreeperSetup2 = autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3 && autoPilotSetupCreeperValue3 >= autoPilotSetupCreeperValue4;

                        bool altBuyZombieSetup1 = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                        bool altSellZombieSetup1 = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
                        bool altBuyZombieSetup2 = autoPilotSetupZombieValue2 == ZombieSetupBuyCode && autoPilotSetupZombieValue3 == ZombieSetupSellCode;
                        bool altSellZombieSetup2 = autoPilotSetupZombieValue2 == ZombieSetupSellCode && autoPilotSetupZombieValue3 == ZombieSetupBuyCode;

                        bool buyCreeperSetup = altBuyCreeperSetup1;
                        bool sellCreeperSetup = altSellCreeperSetup1;

                        bool buyCreeperDriftSetup = (previous1ClosePrice >= autoCloseAndTrailDL4Value
                            && autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2
                            && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3);

                        bool sellCreeperDriftSetup = (previous1ClosePrice < autoCloseAndTrailDL4Value
                            && autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2
                            && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3);

                        bool buyCreeperDriftBreak = autoPilotSetupCreeperBuyContinuation1
                            && (
                                (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9 && previous10ClosePrice < autoCloseAndTrailDL4Value10)
                            );

                        bool sellCreeperDriftBreak = autoPilotSetupCreeperSellContinuation1
                            && (
                                (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9 && previous10ClosePrice >= autoCloseAndTrailDL4Value10)
                            );

                        int maAboveDL4Count = 0;
                        if (autoCloseAndTrailDL1Value >= autoCloseAndTrailDL4Value) maAboveDL4Count++;
                        if (autoCloseAndTrailDL2Value >= autoCloseAndTrailDL4Value) maAboveDL4Count++;
                        if (autoCloseAndTrailDL3Value >= autoCloseAndTrailDL4Value) maAboveDL4Count++;
                        if (autoCloseAndTrailRLValue >= autoCloseAndTrailDL4Value) maAboveDL4Count++;


                        int maBelowDL4Count = 0;
                        if (autoCloseAndTrailDL1Value <= autoCloseAndTrailDL4Value) maBelowDL4Count++;
                        if (autoCloseAndTrailDL2Value <= autoCloseAndTrailDL4Value) maBelowDL4Count++;
                        if (autoCloseAndTrailDL3Value <= autoCloseAndTrailDL4Value) maBelowDL4Count++;
                        if (autoCloseAndTrailRLValue <= autoCloseAndTrailDL4Value) maBelowDL4Count++;

                        bool buyXCreeperDriftSetup = (previous1ClosePrice >= autoCloseAndTrailDL4Value
                            && autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2
                            && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3)
                            && maAboveDL4Count >= 2;

                        bool sellXCreeperDriftSetup = (previous1ClosePrice < autoCloseAndTrailDL4Value
                            && autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2
                            && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3)
                            && maBelowDL4Count >= 2;

                        bool buyXCreeperDriftBreak = autoPilotSetupCreeperBuyContinuation1
                            && maAboveDL4Count >= 2
                            && (
                                (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9 && previous10ClosePrice < autoCloseAndTrailDL4Value10)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9 && previous10ClosePrice >= autoCloseAndTrailDL4Value10 && previous11ClosePrice < autoCloseAndTrailDL4Value11)
                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9 && previous10ClosePrice >= autoCloseAndTrailDL4Value10 && previous11ClosePrice >= autoCloseAndTrailDL4Value11 && previous12ClosePrice < autoCloseAndTrailDL4Value12)
                            );

                        bool sellXCreeperDriftBreak = autoPilotSetupCreeperSellContinuation1
                            && maBelowDL4Count >= 2
                            && (
                                (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9 && previous10ClosePrice >= autoCloseAndTrailDL4Value10)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9 && previous10ClosePrice < autoCloseAndTrailDL4Value10 && previous11ClosePrice >= autoCloseAndTrailDL4Value11)
                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9 && previous10ClosePrice < autoCloseAndTrailDL4Value10 && previous11ClosePrice < autoCloseAndTrailDL4Value11 && previous12ClosePrice >= autoCloseAndTrailDL4Value12)
                            );

                        bool buyCreeperRiverSetup = (previous1ClosePrice >= autoCloseAndTrailMA4Value
                            && autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2
                            && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3);

                        bool sellCreeperRiverSetup = (previous1ClosePrice < autoCloseAndTrailMA4Value
                            && autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2
                            && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3);

                        bool buyCreeperRiverBreak = autoPilotSetupCreeperBuyContinuation1
                            && (
                                (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8 && previous9ClosePrice < autoCloseAndTrailMA4Value9)
                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8 && previous9ClosePrice >= autoCloseAndTrailMA4Value9 && previous10ClosePrice < autoCloseAndTrailMA4Value10)
                            );

                        bool sellCreeperRiverBreak = autoPilotSetupCreeperSellContinuation1
                            && (
                                (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8 && previous9ClosePrice >= autoCloseAndTrailMA4Value9)
                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8 && previous9ClosePrice < autoCloseAndTrailMA4Value9 && previous10ClosePrice >= autoCloseAndTrailMA4Value10)
                            );

                        bool recentNewHigh = stingRayRecentHigherHighValue == StingRayHigherHighCode;
                        bool buyCreeperContinuation = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2;
                        bool recentNewLow = stingRayRecentLowerLowValue == StingRayLowerLowCode;
                        bool sellCreeperContinuation = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2;

                        bool buyStingRayBreakSetup = (recentNewHigh && buyCreeperContinuation);
                        bool sellStingRayBreakSetup = (recentNewLow && sellCreeperContinuation);

                        /*
                        bool buyZombieStackedSetup = (altBuyZombieSetup1 && altBuyCreeperSetup1)
                            || (altBuyZombieSetup1 && altBuyCreeperSetup2)
                            || (altBuyZombieSetup2 && altBuyCreeperSetup1)
                            || (altBuyZombieSetup1 && autoPilotSetupCreeperBuyContinuation1);

                        bool sellZombieStackedSetup = (altSellZombieSetup1 && altSellCreeperSetup1)
                            || (altSellZombieSetup1 && altSellCreeperSetup2)
                            || (altSellZombieSetup2 && altSellCreeperSetup1)
                            || (altSellZombieSetup1 && autoPilotSetupCreeperSellContinuation1);
                        */

                        bool buyZombieStackedSetup = (altBuyZombieSetup1 && autoPilotSetupCreeperBuyContinuation1)
                            || (altBuyCreeperSetup1 && autoPilotSetupZombieBuyContinuation1);

                        bool sellZombieStackedSetup = (altSellZombieSetup1 && autoPilotSetupCreeperSellContinuation1)
                            || (altSellCreeperSetup1 && autoPilotSetupZombieSellContinuation1);

                        if (requireSpeedLineCheck)
                        {
                            passedBuySpeedLineFilterCheck = isCloseAboveSpeedLine;
                            passedSellSpeedLineFilterCheck = !isCloseAboveSpeedLine;
                        }
                        else
                        {
                            passedBuySpeedLineFilterCheck = true;
                            passedSellSpeedLineFilterCheck = true;
                        }

                        bool isPriceAboveDL3 = previous1ClosePrice >= autoCloseAndTrailDL3Value;
                        bool isPriceBelowDL3 = previous1ClosePrice <= autoCloseAndTrailDL3Value;
                        bool isPriceAboveDL4 = previous1ClosePrice >= autoCloseAndTrailDL4Value;
                        bool isPriceBelowDL4 = previous1ClosePrice <= autoCloseAndTrailDL4Value;

                        bool isPriceAbovePBMiddle = previous1ClosePrice >= snapPowerBoxMiddleValue;
                        bool isPriceBelowPBMiddle = previous1ClosePrice <= snapPowerBoxMiddleValue;

                        bool isPriceAboveCreek1Edge = previous1ClosePrice >= autoCloseAndTrailDL3LValue;
                        bool isPriceBelowCreek1Edge = previous1ClosePrice <= autoCloseAndTrailDL3HValue;

                        bool isPriceAboveCreek5Edge = previous1ClosePrice >= autoCloseAndTrailDL4LValue;
                        bool isPriceBelowCreek5Edge = previous1ClosePrice <= autoCloseAndTrailDL4HValue;

                        bool usingAutoPilotLiteAlerts = (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup);

                        bool usingAutoPilotPopOrders = (currentAutoPilotOrderStatus == TickHunterAutoPilotOrderTypes.MarketPop);

                        bool twoOrMoreBullish = (previous1CandleBullish && previous2CandleBullish)
                            || (previous1CandleBullish && previous3CandleBullish)
                            || (previous2CandleBullish && previous3CandleBullish);

                        bool twoOrMoreBearish = (!previous1CandleBullish && !previous2CandleBullish)
                            || (!previous1CandleBullish && !previous3CandleBullish)
                            || (!previous2CandleBullish && !previous3CandleBullish);

                        bool buySlider = usingAutoPilotPopOrders
                            && twoOrMoreBearish
                            && previous1HighPrice <= previous2HighPrice && previous2HighPrice <= previous3HighPrice
                            && previous1HighPrice <= autoCloseAndTrailRLValue
                            && previous2HighPrice <= autoCloseAndTrailRLValue2
                            && previous3HighPrice <= autoCloseAndTrailRLValue3;

                        bool sellSlider = usingAutoPilotPopOrders
                            && twoOrMoreBullish
                            && previous1LowPrice >= previous2LowPrice && previous2LowPrice >= previous3LowPrice
                            && previous1LowPrice >= autoCloseAndTrailRLValue
                            && previous2LowPrice >= autoCloseAndTrailRLValue2
                            && previous3LowPrice >= autoCloseAndTrailRLValue3;


                        bool isAltSetupFlag = false;

                        /*
                        bool buyPeppySetupCombo = isPriceBelowDL4 && altBuyCreeperSetup1;
                        bool sellPeppySetupCombo = isPriceAboveDL4 && altSellCreeperSetup1;

                        bool buyPeppySetupAltCombo = usingAutoPilotLiteAlerts && ((isPriceAboveDL4 && altBuyCreeperSetup1) || buyZombieSetup);
                        bool sellPeppySetupAltCombo = usingAutoPilotLiteAlerts && ((isPriceBelowDL4 && altSellCreeperSetup1) || sellZombieSetup);
                        */


                        bool buyPeppySetupCombo = false;
                        bool sellPeppySetupCombo = false;

                        bool buyPeppySetupAltCombo = false;
                        bool sellPeppySetupAltCombo = false;

                        bool buySleepySetupCombo = false;
                        bool sellSleepySetupCombo = false;

                        bool buySleepySetupAltCombo = false;
                        bool sellSleepySetupAltCombo = false;


                        bool profileSetupZombieOnly = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOnly);
                        bool profileSetupCreeperOnly = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOnly);
                        bool profileSetupSliderOnly = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.SliderOnly);
                        bool profileSetupZombieOrSliderCombo = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOrSliderCombo);
                        bool profileSetupCreeperOrSliderCombo = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOrSliderCombo);
                        bool profileSetupZombieOrCreeperCombo = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOrCreeperCombo);
                        bool profileSetupZombieOrCreeperOrSliderCombo = (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOrCreeperOrSliderCombo);


                        if (currentAutoPilotProfileStatus != TickHunterAutoPilotProfileTypes.Disabled)
                        {
                            if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOnly)
                            {
                                buyPeppySetupCombo = buyZombieSetup;
                                sellPeppySetupCombo = sellZombieSetup;

                                buySleepySetupCombo = ((isPriceBelowDL3 || isPriceBelowDL4 || isPriceBelowPBMiddle) && buyZombieSetup);
                                sellSleepySetupCombo = ((isPriceAboveDL3 || isPriceAboveDL4 || isPriceAbovePBMiddle) && sellZombieSetup);
                            }
                            else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOnly)
                            {
                                buyPeppySetupCombo = altBuyCreeperSetup1;
                                sellPeppySetupCombo = altSellCreeperSetup1;

                                buySleepySetupCombo = ((isPriceBelowDL3 || isPriceBelowDL4 || isPriceBelowPBMiddle) && altBuyCreeperSetup1);
                                sellSleepySetupCombo = ((isPriceAboveDL3 || isPriceAboveDL4 || isPriceAbovePBMiddle) && altSellCreeperSetup1);
                            }
                            else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.SliderOnly)
                            {
                                buyPeppySetupCombo = buySlider;
                                sellPeppySetupCombo = sellSlider;

                                buySleepySetupCombo = (buySlider);
                                sellSleepySetupCombo = (sellSlider);
                            }
                            else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOrSliderCombo)
                            {
                                buyPeppySetupCombo = buyZombieSetup;
                                sellPeppySetupCombo = sellZombieSetup;

                                buySleepySetupCombo = ((isPriceBelowDL3 || isPriceBelowDL4 || isPriceBelowPBMiddle) && buyZombieSetup) || (buySlider);
                                sellSleepySetupCombo = ((isPriceAboveDL3 || isPriceAboveDL4 || isPriceAbovePBMiddle) && sellZombieSetup) || (sellSlider);
                            }
                            else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOrSliderCombo)
                            {
                                buyPeppySetupCombo = altBuyCreeperSetup1;
                                sellPeppySetupCombo = altSellCreeperSetup1;

                                buySleepySetupCombo = ((isPriceBelowDL3 || isPriceBelowDL4 || isPriceBelowPBMiddle) && altBuyCreeperSetup1) || (buySlider);
                                sellSleepySetupCombo = ((isPriceAboveDL3 || isPriceAboveDL4 || isPriceAbovePBMiddle) && altSellCreeperSetup1) || (sellSlider);
                            }
                            else
                            {
                                buyPeppySetupCombo = altBuyCreeperSetup1;
                                sellPeppySetupCombo = altSellCreeperSetup1;

                                buyPeppySetupAltCombo = usingAutoPilotLiteAlerts && (buyZombieSetup || buySlider);
                                sellPeppySetupAltCombo = usingAutoPilotLiteAlerts && (sellZombieSetup || sellSlider);

                                buySleepySetupCombo = ((isPriceBelowDL3 || isPriceBelowDL4 || isPriceBelowPBMiddle) && altBuyCreeperSetup1);
                                sellSleepySetupCombo = ((isPriceAboveDL3 || isPriceAboveDL4 || isPriceAbovePBMiddle) && altSellCreeperSetup1);

                                buySleepySetupAltCombo = usingAutoPilotLiteAlerts && (((isPriceBelowDL3 || isPriceBelowDL4 || isPriceBelowPBMiddle) && buyZombieSetup) || buySlider);
                                sellSleepySetupAltCombo = usingAutoPilotLiteAlerts && (((isPriceAboveDL3 || isPriceAboveDL4 || isPriceAbovePBMiddle) && sellZombieSetup) || sellSlider);

                                /*
                                buySlowRollSetupCombo = ((isPriceAboveCreek1Edge || isPriceAboveCreek5Edge) && (altBuyCreeperSetup1 || buyCreeperDriftBreak)) || (isPriceAbovePBMiddle && buySlider);
                                sellSlowRollSetupCombo = ((isPriceBelowCreek1Edge || isPriceBelowCreek5Edge) && (altSellCreeperSetup1 || sellCreeperDriftBreak)) || (isPriceBelowPBMiddle && sellSlider);

                                buySlowRollSetupAltCombo = usingAutoPilotLiteAlerts && ((isPriceAboveCreek1Edge || isPriceAboveCreek5Edge) && (buyZombieSetup));
                                sellSlowRollSetupAltCombo = usingAutoPilotLiteAlerts && ((isPriceBelowCreek1Edge || isPriceBelowCreek5Edge) && (sellZombieSetup));

                                buyEonRollSetupCombo = ((isPriceAboveCreek1Edge || isPriceAboveCreek5Edge) && (altBuyCreeperSetup1 || buyCreeperDriftBreak)) || (isPriceAbovePBMiddle && buySlider);
                                sellEonRollSetupCombo = ((isPriceBelowCreek1Edge || isPriceBelowCreek5Edge) && (altSellCreeperSetup1 || sellCreeperDriftBreak)) || (isPriceBelowPBMiddle && sellSlider);

                                buyEonRollSetupAltCombo = usingAutoPilotLiteAlerts && ((isPriceAboveCreek1Edge || isPriceAboveCreek5Edge) && buyZombieSetup);
                                sellEonRollSetupAltCombo = usingAutoPilotLiteAlerts && ((isPriceBelowCreek1Edge || isPriceBelowCreek5Edge) && sellZombieSetup);
                                */
                            }
                        }


                        bool isZombieSetupFlavor = false;
                        bool isCreeperSetupFlavor = false;
                        bool isSliderSetupFlavor = false;

                        if (buyZombieSetup && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyZombie";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (sellZombieSetup && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellZombie";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if (buyZombieBoostedSetup && passedBuySpeedLineFilterCheck && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieBoostedOnly
                            || currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieBoostedOrStackedCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyZombieBoosted";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (sellZombieBoostedSetup && passedSellSpeedLineFilterCheck && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieBoostedOnly
                            || currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieBoostedOrStackedCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellZombieBoosted";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if (buyZombieStackedSetup && passedBuySpeedLineFilterCheck && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieStackedOnly
                            || currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieBoostedOrStackedCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyZombieStacked";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (sellZombieStackedSetup && passedSellSpeedLineFilterCheck && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieStackedOnly
                            || currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieBoostedOrStackedCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellZombieStacked";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if (((buyZombieSetup && buyRiverFilter) || buyZombieRiverBreak) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOrRiverBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyZombieOrRiverBreakCombo";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (((sellZombieSetup && sellRiverFilter) || sellZombieRiverBreak) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOrRiverBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellZombieOrRiverBreakCombo";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if (((buyZombieSetup && buyDriftFilter) || buyZombieDriftBreak) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOrDriftBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyZombieOrDriftBreakCombo";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (((sellZombieSetup && sellDriftFilter) || sellZombieDriftBreak) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOrDriftBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellZombieOrDriftBreakCombo";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if (buyWalkerSetup && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.WalkerOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyWalker";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (sellWalkerSetup && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.WalkerOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellWalker";
                            isZombieSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if (buyCreeperSetup && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyCreeper";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if (sellCreeperSetup && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellCreeper";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buyCreeperDriftSetup || buyCreeperDriftBreak) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOrDriftBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishDriftTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishDriftTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyCreeperOrDriftBreakCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellCreeperDriftSetup || sellCreeperDriftBreak) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOrDriftBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishDriftTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishDriftTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellCreeperOrDriftBreakCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buyCreeperRiverSetup || buyCreeperRiverBreak) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOrRiverBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishRiverTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishRiverTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyCreeperOrRiverBreakCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellCreeperRiverSetup || sellCreeperRiverBreak) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOrRiverBreakCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishRiverTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishRiverTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellCreeperOrRiverBreakCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buyStingRayBreakSetup && buyDriftFilter) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.StingRayBreakOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishRiverTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishRiverTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyStingRayBreakOnly";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellStingRayBreakSetup && sellDriftFilter) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.StingRayBreakOnly
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishRiverTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishRiverTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellStingRayBreakOnly";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buyCreeperSetup || buyCreeperZombieSetup) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOrCZCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyCreeperOrCZCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellCreeperSetup || sellCreeperZombieSetup) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.CreeperOrCZCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellCreeperOrCZCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buyCreeperSetup || buyZombieSetup) && passedBuySpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOrCreeperCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuyZombieOrCreeperCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellCreeperSetup || sellZombieSetup) && passedSellSpeedLineFilterCheck && currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.ZombieOrCreeperCombo
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && !autoPilotBullishTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && !autoPilotBullishTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellZombieOrCreeperCombo";
                            isCreeperSetupFlavor = true;

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buyPeppySetupCombo || buyPeppySetupAltCombo) && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.PeppySetupCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered && autoPilotBullishDriftTrend)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup && autoPilotBullishDriftTrend)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuySetupCombo-Peppy";

                            if (buySlider && (profileSetupSliderOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrSliderCombo))
                            {
                                algoSetupName = "BuySlider-Peppy";
                                isSliderSetupFlavor = true;
                            }
                            else if (altBuyCreeperSetup1 && (profileSetupCreeperOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrCreeperCombo))
                            {
                                algoSetupName = "BuyCreeper-Peppy";
                                isCreeperSetupFlavor = true;
                            }
                            else if (buyZombieSetup && (profileSetupZombieOnly || profileSetupZombieOrSliderCombo || profileSetupZombieOrCreeperOrSliderCombo))
                            {
                                algoSetupName = "BuyZombie-Peppy";
                                isZombieSetupFlavor = true;
                            }

                            isAltSetupFlag = buyPeppySetupAltCombo;

                            if (isAltSetupFlag) algoSetupName += " (Alt)";

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellPeppySetupCombo || sellPeppySetupAltCombo) && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.PeppySetupCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellSetupCombo-Peppy";

                            if (sellSlider && (profileSetupSliderOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrSliderCombo))
                            {
                                algoSetupName = "SellSlider-Peppy";
                                isSliderSetupFlavor = true;
                            }
                            else if (altSellCreeperSetup1 && (profileSetupCreeperOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrCreeperCombo))
                            {
                                algoSetupName = "SellCreeper-Peppy";
                                isCreeperSetupFlavor = true;
                            }
                            else if (sellZombieSetup && (profileSetupZombieOnly || profileSetupZombieOrSliderCombo || profileSetupZombieOrCreeperOrSliderCombo))
                            {
                                algoSetupName = "SellZombie-Peppy";
                                isZombieSetupFlavor = true;
                            }

                            isAltSetupFlag = sellPeppySetupAltCombo;

                            if (isAltSetupFlag) algoSetupName += " (Alt)";

                            openMarketPosition = MarketPosition.Short;
                        }
                        else if ((buySleepySetupCombo || buySleepySetupAltCombo) && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.SleepySetupCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.BuySetup))
                                )
                            )
                        {
                            algoSetupName = "BuySetupCombo-Sleepy";

                            if (buySlider && (profileSetupSliderOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrSliderCombo))
                            {
                                algoSetupName = "BuySlider-Sleepy";
                                isSliderSetupFlavor = true;
                            }
                            else if (altBuyCreeperSetup1 && (profileSetupCreeperOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrCreeperCombo))
                            {
                                algoSetupName = "BuyCreeper-Sleepy";
                                isCreeperSetupFlavor = true;
                            }
                            else if (buyZombieSetup && (profileSetupZombieOnly || profileSetupZombieOrSliderCombo || profileSetupZombieOrCreeperOrSliderCombo))
                            {
                                algoSetupName = "BuyZombie-Sleepy";
                                isZombieSetupFlavor = true;
                            }


                            isAltSetupFlag = sellSleepySetupAltCombo;

                            if (isAltSetupFlag) algoSetupName += " (Alt)";

                            openMarketPosition = MarketPosition.Long;
                        }
                        else if ((sellSleepySetupCombo || sellSleepySetupAltCombo) && (currentAutoPilotSetupStatus == TickHunterAutoPilotSetupTypes.SleepySetupCombo)
                            && (
                                (!UseAutoPilotLite
                                    && (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll
                                    || currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly
                                    || (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered)))
                                || (UseAutoPilotLite
                                    && (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextSetup
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup
                                    || (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.NextFilteredSetup)
                                    || currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.SellSetup))
                                )
                            )
                        {
                            algoSetupName = "SellSetupCombo-Sleepy";

                            if (sellSlider && (profileSetupSliderOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrSliderCombo))
                            {
                                algoSetupName = "SellSlider-Sleepy";
                                isSliderSetupFlavor = true;
                            }
                            if (altSellCreeperSetup1 && (profileSetupCreeperOnly || profileSetupCreeperOrSliderCombo || profileSetupZombieOrCreeperCombo))
                            {
                                algoSetupName = "SellCreeper-Sleepy";
                                isCreeperSetupFlavor = true;
                            }
                            else if (sellZombieSetup && (profileSetupZombieOnly || profileSetupZombieOrSliderCombo || profileSetupZombieOrCreeperOrSliderCombo))
                            {
                                algoSetupName = "SellZombie-Sleepy";
                                isZombieSetupFlavor = true;
                            }


                            isAltSetupFlag = sellSleepySetupAltCombo;

                            if (isAltSetupFlag) algoSetupName += " (Alt)";

                            openMarketPosition = MarketPosition.Short;
                        }


                        bool openNewPosition = (openMarketPosition == MarketPosition.Long || openMarketPosition == MarketPosition.Short);

                        if (openNewPosition)
                        {
                            int buyCount = 0;
                            int sellCount = 0;
                            bool hasPosition = GetPositionVolume(attachedInstrument, out buyCount, out sellCount);
                            bool isBuyAddOn = (useAutoPilotAddOnFlag && buyCount > 0 && openMarketPosition == MarketPosition.Long);
                            bool isSellAddOn = (useAutoPilotAddOnFlag && sellCount > 0 && openMarketPosition == MarketPosition.Short);
                            bool isReversalSetup = (autoPilotIsInAlertMode && hasPosition
                                && (buyCount > 0 && openMarketPosition == MarketPosition.Short
                                || sellCount > 0 && openMarketPosition == MarketPosition.Long));

                            if (!hasPosition || isBuyAddOn || isSellAddOn || isReversalSetup)
                            {

                                int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);
                                bool autoPilotMaxVolumeCheckRequired = AutoPilotMaxVolume > 0;
                                bool passedAutoPilotMaxVolumeCheck = false;

                                if (autoPilotMaxVolumeCheckRequired)
                                {
                                    int totalCombinedNewVolume = 0;
                                    int positionVolume = 0;

                                    if (openMarketPosition == MarketPosition.Long)
                                    {
                                        positionVolume = buyCount;

                                    }
                                    else if (openMarketPosition == MarketPosition.Short)
                                    {
                                        positionVolume = sellCount;
                                    }

                                    totalCombinedNewVolume = positionVolume + autoEntryVolume;

                                    if (totalCombinedNewVolume <= AutoPilotMaxVolume)
                                    {
                                        passedAutoPilotMaxVolumeCheck = true;
                                    }
                                    else
                                    {
                                        RealLogger.PrintOutput("BLOCKED: AutoPilot reached max volume of " + AutoPilotMaxVolume + " (AutoPilotMaxVolume) with an exiting position volume of " + positionVolume + " for a total combined new volume of " + totalCombinedNewVolume);
                                    }
                                }
                                else
                                {
                                    passedAutoPilotMaxVolumeCheck = true;
                                }


                                if (passedAutoPilotMaxVolumeCheck)
                                {
                                    if (isSliderSetupFlavor)
                                    {
                                        if (openMarketPosition == MarketPosition.Short)
                                        {
                                            if (usedSellSliderSetupCycle)
                                                return;
                                            else
                                                usedSellSliderSetupCycle = true;
                                        }
                                        else
                                        {
                                            if (usedBuySliderSetupCycle)
                                                return;
                                            else
                                                usedBuySliderSetupCycle = true;
                                        }
                                    }

                                    if (currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup)
                                    {
                                        RealLogger.PrintOutput("AutoPilot detected " + algoSetupName + " setup and now opening trade alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);


                                        string orderTypeText = "BUY";

                                        if (openMarketPosition == MarketPosition.Short)
                                            orderTypeText = "SELL";

                                        string orderEntryTypeText = "market";

                                        if (currentAutoPilotOrderStatus == TickHunterAutoPilotOrderTypes.MarketPop)
                                            orderEntryTypeText = "Pop";


                                        string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                        string messageTitle = "";

                                        if (isCreeperSetupFlavor)
                                        {
                                            if (openMarketPosition == MarketPosition.Short)
                                            {
                                                messageTitle = isAltSetupFlag ? SellCreeperAlertAltMessageTitle : SellCreeperAlertMessageTitle;
                                            }
                                            else
                                            {
                                                messageTitle = isAltSetupFlag ? BuyCreeperAlertAltMessageTitle : BuyCreeperAlertMessageTitle;

                                            }
                                        }
                                        else if (isSliderSetupFlavor)
                                        {
                                            if (openMarketPosition == MarketPosition.Short)
                                            {
                                                messageTitle = isAltSetupFlag ? SellZombieAlertAltMessageTitle : SellSliderAlertMessageTitle;
                                            }
                                            else
                                            {
                                                messageTitle = isAltSetupFlag ? BuyZombieAlertAltMessageTitle : BuySliderAlertMessageTitle;
                                            }
                                        }
                                        else
                                        {
                                            if (openMarketPosition == MarketPosition.Short)
                                            {
                                                messageTitle = isAltSetupFlag ? SellZombieAlertAltMessageTitle : SellZombieAlertMessageTitle;
                                            }
                                            else
                                            {
                                                messageTitle = isAltSetupFlag ? BuyZombieAlertAltMessageTitle : BuyZombieAlertMessageTitle;
                                            }
                                        }

                                        string reverseMessageText = "";
                                        if (isReversalSetup) reverseMessageText = "close your existing position and ";

                                        string message = "AutoPilot detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to " + reverseMessageText + "open a " + orderEntryTypeText + " '" + orderTypeText + "' order with " + autoEntryVolume + " contract(s)?";

                                        ExitCloseAlertWindows();
                                        ExitTradeAlertWindows();

                                        if (PlaySoundOnSetupAlert)
                                        {
                                            PlaySound(fullSoundFilename);
                                        }

                                        ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                        {
                                            MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, !isAltSetupFlag);
                                            isTradeAlertMessageBoxOpen = true;
                                            //MessageBoxResult result = NinjaTrader.Gui.Tools.NTMessageBoxSimple.Show(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question);
                                            //MessageBoxResult result = MessageBox.Show((Window.GetWindow(ChartControl.OwnerChart as DependencyObject)), message, FullSystemName + " Trade Alert", MessageBoxButton.YesNoCancel, MessageBoxImage.Question, MessageBoxResult.No);

                                            if (result == MessageBoxResult.Yes)
                                            {
                                                if (currentAutoPilotOrderStatus == TickHunterAutoPilotOrderTypes.MarketPop)
                                                {
                                                    RealLogger.PrintOutput("AutoPilot trade alert prompt accepted " + algoSetupName + " setup and now opening Pop order for " + GetInstrumentPeriodText() + " (altsetup=" + isAltSetupFlag.ToString().ToLower() + ")" + " via " + signalName);

                                                    if (openMarketPosition == MarketPosition.Long)
                                                    {
                                                        double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                                                        double highPrice = CalculateTrailHighPrice(MarketPosition.Long, true);
                                                        double highestPrice = Math.Max(askPrice, highPrice);
                                                        double newPopPrice = GetInitialPopPrice(MarketPosition.Long, highestPrice);

                                                        DeactivatePopDelayedEntryFeatures(signalName);
                                                        CancelPopDropOrders(signalName);

                                                        if (isReversalSetup) FlattenEverything(signalName, true, attachedInstrument);
                                                        CreateBuyStop(signalName, attachedInstrument, OrderAction.BuyToCover, OrderEntry.Manual, autoEntryVolume, newPopPrice);
                                                    }
                                                    else
                                                    {
                                                        double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                                                        double lowPrice = CalculateTrailLowPrice(MarketPosition.Short, true);
                                                        double lowestPrice = Math.Min(bidPrice, lowPrice);
                                                        double newPopPrice = GetInitialPopPrice(MarketPosition.Short, lowestPrice);

                                                        DeactivatePopDelayedEntryFeatures(signalName);
                                                        CancelPopDropOrders(signalName);

                                                        if (isReversalSetup) FlattenEverything(signalName, true, attachedInstrument);
                                                        CreateSellStop(signalName, attachedInstrument, OrderAction.SellShort, OrderEntry.Manual, autoEntryVolume, newPopPrice);
                                                    }
                                                }
                                                else
                                                {
                                                    RealLogger.PrintOutput("AutoPilot trade alert prompt accepted " + algoSetupName + " setup and now opening market order for " + GetInstrumentPeriodText() + " (altsetup=" + isAltSetupFlag.ToString().ToLower() + ")" + " via " + signalName);

                                                    if (openMarketPosition == MarketPosition.Long)
                                                    {
                                                        DeactivatePopDelayedEntryFeatures(signalName);
                                                        CancelPopDropOrders(signalName);

                                                        if (isReversalSetup) FlattenEverything(signalName, true, attachedInstrument);
                                                        SubmitMarketOrder(signalName, attachedInstrument, OrderAction.Buy, OrderEntry.Manual, autoEntryVolume);
                                                    }
                                                    else
                                                    {
                                                        DeactivatePopDelayedEntryFeatures(signalName);
                                                        CancelPopDropOrders(signalName);

                                                        if (isReversalSetup) FlattenEverything(signalName, true, attachedInstrument);
                                                        SubmitMarketOrder(signalName, attachedInstrument, OrderAction.Sell, OrderEntry.Manual, autoEntryVolume);
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                RealLogger.PrintOutput("AutoPilot trade alert prompt declined for " + GetInstrumentPeriodText() + " (altsetup=" + isAltSetupFlag.ToString().ToLower() + ")" + " via " + signalName);
                                            }
                                        }));
                                    }
                                    else
                                    {
                                        if (UseAutoPilotLite) DisableAutoPilotLiteButton(0); else DecrementAutoPilotTradeCount();

                                        DeactivatePopDelayedEntryFeatures(signalName);
                                        CancelPopDropOrders(signalName);

                                        //RealLogger.PrintOutput("got here AutoPilot hasPosition=" + hasPosition + " buyCount=" + buyCount + " sellCount=" + sellCount + " isCloseAutoSlopeMinProfit=" + isCloseAutoSlopeMinProfit + " openMarketPosition=" + openMarketPosition);

                                        if (currentAutoPilotOrderStatus == TickHunterAutoPilotOrderTypes.MarketPop)
                                        {
                                            RealLogger.PrintOutput("AutoPilot detected " + algoSetupName + " setup and now opening Pop order" + " via " + signalName);

                                            if (openMarketPosition == MarketPosition.Long)
                                            {
                                                double askPrice = RealInstrumentService.GetAskPrice(attachedInstrument);
                                                double highPrice = CalculateTrailHighPrice(MarketPosition.Long, true);
                                                double highestPrice = Math.Max(askPrice, highPrice);
                                                double newPopPrice = GetInitialPopPrice(MarketPosition.Long, highestPrice);

                                                CreateBuyStop(signalName, attachedInstrument, OrderAction.BuyToCover, OrderEntry.Manual, autoEntryVolume, newPopPrice);
                                            }
                                            else
                                            {
                                                double bidPrice = RealInstrumentService.GetBidPrice(attachedInstrument);
                                                double lowPrice = CalculateTrailLowPrice(MarketPosition.Short, true);
                                                double lowestPrice = Math.Min(bidPrice, lowPrice);
                                                double newPopPrice = GetInitialPopPrice(MarketPosition.Short, lowestPrice);

                                                CreateSellStop(signalName, attachedInstrument, OrderAction.SellShort, OrderEntry.Manual, autoEntryVolume, newPopPrice);
                                            }
                                        }
                                        else
                                        {
                                            RealLogger.PrintOutput("AutoPilot detected " + algoSetupName + " setup and now opening market order" + " via " + signalName);

                                            if (openMarketPosition == MarketPosition.Long)
                                            {
                                                SubmitMarketOrder(signalName, attachedInstrument, OrderAction.Buy, OrderEntry.Manual, autoEntryVolume);
                                            }
                                            else
                                            {
                                                SubmitMarketOrder(signalName, attachedInstrument, OrderAction.Sell, OrderEntry.Manual, autoEntryVolume);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    }
                }
            }
        }



        private void DeactivateAutoEntryFeatures(string signalName)
        {
            if (UseAutoPilotLite)
            {
                if (currentAutoPilotLiteStatus != TickHunterAutoPilotLiteTypes.AlertSetup)
                {
                    DisableAutoPilotLiteButton(0);
                }
            }
            else
            {
                DecrementAutoPilotTradeCount();
            }

            DeactivatePopDelayedEntryFeatures(signalName);
        }

        private void DeactivatePopDelayedEntryFeatures(string signalName)
        {
            if (useBuyPopActivateFlag)
            {
                DeactivateBuyPopButton(signalName);
            }

            if (useSellPopActivateFlag)
            {
                DeactivateSellPopButton(signalName);
            }
        }

        public class MessageBoxMoreSimple : NinjaTrader.Gui.Tools.NTMessageBoxSimple
        {
            public static MessageBoxMoreSimple BuildMessageBox(Window parent, string message, string messageTitle, MessageBoxButton buttonType, MessageBoxImage imageType, Brush backgroundColor)
            {
                MessageBoxMoreSimple moreSimple = new MessageBoxMoreSimple();
                moreSimple.Title = messageTitle;
                moreSimple.Caption = message;
                moreSimple.ButtonSet = buttonType;
                moreSimple.MsgBoxImage = imageType;
                //moreSimple.Owner = parent;

                //backgroundColor.Freeze();
                //moreSimple.Background = backgroundColor;

                return moreSimple;
            }
            public static MessageBoxResult Show(NTMessageBoxSimple moreSimple)
            {
                return NinjaTrader.Gui.Tools.NTMessageBoxSimple.ShowInternal(moreSimple);
            }

            public MessageBoxMoreSimple()
            {


            }

        }

        private MessageBoxResult ShowMessageBox(Window parent, string message, string messageTitle, MessageBoxButton buttonType, MessageBoxImage imageType, bool useNativeColors = true)
        {
            MessageBoxResult result = MessageBoxResult.None;

            if (useNativeColors)
            {
                result = NinjaTrader.Gui.Tools.NTMessageBoxSimple.Show(parent, message, messageTitle, buttonType, imageType);
            }
            else
            {
                result = MessageBox.Show(parent, message, messageTitle, buttonType, imageType, MessageBoxResult.None);
            }

            return result;
        }

        [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        [System.Runtime.InteropServices.DllImport("user32.dll", CharSet = System.Runtime.InteropServices.CharSet.Auto)]
        static extern IntPtr SendMessage(IntPtr hWnd, UInt32 Msg, IntPtr wParam, IntPtr lParam);

        //[return: MarshalAs(UnmanagedType.Bool)]
        [System.Runtime.InteropServices.DllImport("user32.dll", SetLastError = true)]
        static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

        [System.Runtime.InteropServices.DllImport("user32")]
        private static extern bool SetForegroundWindow(IntPtr hwnd);

        [System.Runtime.InteropServices.DllImport("kernel32", SetLastError = true)]
        public static extern bool CloseHandle(IntPtr handle);

        [System.Runtime.InteropServices.DllImport("user32.dll")]
        static extern bool EndDialog(IntPtr hDlg, IntPtr nResult);

        //private const int WM_CLOSE = 0x0010;
        private const int WM_CLOSE = 0x10;
        private const int WM_COMMAND = 0x0011;
        private const int IDCANCEL = 2;
        private const int IDNO = 7;
        private const int WM_IME_NOTIFY = 0x0282;

        private const int WM_DESTROY = 0x0002;

        private const int WM_NCDESTROY = 0x0082;

        private const int IMN_CLOSESTATUSWINDOW = 0x0001;

        private const int WM_KILLFOCUS = 0x0008;


        private IntPtr GetHandleWindow(string title)
        {
            return FindWindow(null, title);
        }

        private void CloseAltMessageBox(string title)
        {
            IntPtr hwnd = GetHandleWindow(title);

            if (hwnd != IntPtr.Zero)
            {
                //Print("*** DEBUG found title=" + title);

                EndDialog(hwnd, (IntPtr)IDCANCEL);

                //CloseHandle(hwnd);

                //SetForegroundWindow(hwnd);

                //System.Windows.Forms.SendKeys.Send(System.Windows.Forms.Keys.Escape);

                //SendMessage(hwnd, WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
                //SendMessage(hwnd, WM_COMMAND, idPointer, IntPtr.Zero);

            }
            else
            {
                //Print("*** DEBUG NOT found title=" + title);
            }
        }

        private void CloseMessageBox(string title)
        {
            IntPtr hwnd = GetHandleWindow(title);

            if (hwnd != IntPtr.Zero)
            {
                //Print("*** DEBUG found title=" + title);

                //EndDialog(hwnd, (IntPtr)IDCANCEL);

                SendMessage(hwnd, WM_CLOSE, IntPtr.Zero, IntPtr.Zero);

                //CloseHandle(hwnd);

                //SetForegroundWindow(hwnd);

                //System.Windows.Forms.SendKeys.Send("{ESC}");

                //PostMessage(hwnd, WM_COMMAND, (IntPtr)IDCANCEL, IntPtr.Zero);

                //SendMessage(hwnd, WM_COMMAND, idPointer, IntPtr.Zero);

            }
            else
            {
                //Print("*** DEBUG NOT found title=" + title);
            }
        }

        private void CloseWindow(IntPtr hwnd)
        {
            if (hwnd != IntPtr.Zero)
            {
                SendMessage(hwnd, WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
            }
        }

        /*
        private void AttemptToEngageAutobot()
        {
            if (1 == 2)
            {
                if (UseHedgehogEntry)
                {
                    lock (NewPositionLock)
                    {
                        int positionCount = RealPositionService.PositionCount;
                        int autoEntryVolume = CalculateAutoEntryVolume(currentEntryVolumeAutoStatus);

                        for (int index = 0; index < positionCount; index++)
                        {
                            RealPosition position = null;
                            if (RealPositionService.TryGetByIndex(index, out position))
                            {
                                if (IsAccountFlat()
                                    && RealOrderService.AreAllOrderUpdateCyclesComplete())
                                {
                                    if (HedgehogEntryBuySymbol1SellSymbol2)
                                    {
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Hedgehog Entry buy (" + HedgehogEntrySymbol1FullName + ") sell (" + HedgehogEntrySymbol2FullName + ")", PrintTo.OutputTab1);

                                        //Interlocked.Exchange(ref activeCloseOrderCount, Account.Orders.Count());
                                        Instrument buyInstrument = Instrument.GetInstrument(HedgehogEntrySymbol1FullName);

                                        SubmitMarketOrder(signalName, buyInstrument, OrderAction.Buy, OrderEntry.Automated, autoEntryVolume);


                                        //Order buyMarketorder = Account.CreateOrder(buyInstrument, OrderAction.Buy, OrderType.Market, OrderEntry.Automated, TimeInForce.Day, AutobotEntryQuantity, 0, 0, "", uniqueSignalKey, Core.Globals.MaxDate, null);
                                        //Account.Submit(new[] { buyMarketorder });

                                        //uniqueSignalKey = Guid.NewGuid().ToString();
                                        //inFlighOrderCache.Add(uniqueSignalKey, AutobotEntryQuantity);

                                        Instrument sellInstrument = Instrument.GetInstrument(HedgehogEntrySymbol2FullName);

                                        SubmitMarketOrder(signalName, sellInstrument, OrderAction.Sell, OrderEntry.Automated, autoEntryVolume);

                                        //Order sellMarketorder = Account.CreateOrder(sellInstrument, OrderAction.SellShort, OrderType.Market, OrderEntry.Automated, TimeInForce.Day, AutobotEntryQuantity, 0, 0, "", uniqueSignalKey, Core.Globals.MaxDate, null);
                                        //Account.Submit(new[] { sellMarketorder });
                                    }
                                    else
                                    {
                                        if (DebugLogLevel > 2) RealLogger.PrintOutput("Hedgehog Entry buy (" + HedgehogEntrySymbol2FullName + ") sell (" + HedgehogEntrySymbol1FullName + ")", PrintTo.OutputTab1);

                                        //uniqueSignalKey = Guid.NewGuid().ToString();
                                        //inFlighOrderCache.Add(uniqueSignalKey, AutobotEntryQuantity);

                                        //Interlocked.Exchange(ref lastOrderCount, Account.Orders.Count());

                                        Instrument buyInstrument = Instrument.GetInstrument(HedgehogEntrySymbol2FullName);

                                        SubmitMarketOrder(signalName, buyInstrument, OrderAction.Buy, OrderEntry.Automated, autoEntryVolume);

                                        //Order buyMarketorder = Account.CreateOrder(buyInstrument, OrderAction.Buy, OrderType.Market, OrderEntry.Automated, TimeInForce.Day, AutobotEntryQuantity, 0, 0, "", uniqueSignalKey, Core.Globals.MaxDate, null);
                                        //Account.Submit(new[] { buyMarketorder });

                                        //uniqueSignalKey = Guid.NewGuid().ToString();
                                        //inFlighOrderCache.Add(uniqueSignalKey, AutobotEntryQuantity);

                                        Instrument sellInstrument = Instrument.GetInstrument(HedgehogEntrySymbol1FullName);

                                        SubmitMarketOrder(signalName, sellInstrument, OrderAction.Sell, OrderEntry.Automated, autoEntryVolume);

                                        //Order sellMarketorder = Account.CreateOrder(sellInstrument, OrderAction.SellShort, OrderType.Market, OrderEntry.Automated, TimeInForce.Day, AutobotEntryQuantity, 0, 0, "", uniqueSignalKey, Core.Globals.MaxDate, null);
                                        //Account.Submit(new[] { sellMarketorder });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        */

        private bool IsLiveAccount(Account account)
        {
            bool isLiveAccount = false;

            if (account != null)
            {
                const string SimAccountPrefix = "Sim";
                const string DemoAccountPrefix = "DEMO";

                bool isSimAccount = account.Name.StartsWith(SimAccountPrefix, StringComparison.OrdinalIgnoreCase);
                bool isDemoAccount = account.Name.StartsWith(DemoAccountPrefix, StringComparison.OrdinalIgnoreCase);

                if (!isSimAccount && !isDemoAccount)
                {
                    isLiveAccount = true;
                }
            }

            return isLiveAccount;
        }

        DateTime lastWindowHiddenDetectionTime = DateTime.MinValue;
        const int WindowHiddenDetectionThrottleSeconds = 3;

        private void DetermineIfWindowHidden()
        {
            bool isNextCycleReady = lastWindowHiddenDetectionTime <= GetDateTimeNow();

            if (isNextCycleReady)
            {
                lastWindowHiddenDetectionTime = (GetDateTimeNow()).AddSeconds(WindowHiddenDetectionThrottleSeconds);

                if (ChartControl != null)
                {
                    if (ChartControl.Dispatcher.CheckAccess())
                    {
                        Window chartWindow = ChartControl.OwnerChart as Window;

                        if (chartWindow != null)
                        {
                            bool isWindowHidden = (chartWindow.Visibility == Visibility.Hidden);

                            if (isWindowHidden)
                            {
                                if (!isIndicatorSuspended)
                                {
                                    RealLogger.PrintOutput("Detecting chart window has been set to hidden...suspending " + FullSystemName + " (Workspace Switch)");
                                }

                                isIndicatorSuspended = true;
                            }
                            else
                            {
                                if (isIndicatorSuspended)
                                {
                                    RealLogger.PrintOutput("Detecting chart window has been reactivated...awakening " + FullSystemName + " (Workspace Switch)");
                                }

                                isIndicatorSuspended = false;
                            }
                        }
                    }
                    else
                    {
                        ChartControl.Dispatcher.InvokeAsync(() =>
                        {
                            Window chartWindow = ChartControl.OwnerChart as Window;

                            if (chartWindow != null)
                            {
                                bool isWindowHidden = (chartWindow.Visibility == Visibility.Hidden);

                                if (isWindowHidden)
                                {
                                    if (!isIndicatorSuspended)
                                    {
                                        RealLogger.PrintOutput("Detecting chart window has been set to hidden...suspending " + FullSystemName + " (Workspace Switch)");
                                    }

                                    isIndicatorSuspended = true;
                                }
                                else
                                {
                                    if (isIndicatorSuspended)
                                    {
                                        RealLogger.PrintOutput("Detecting chart window has been reactivated...awakening " + FullSystemName + " (Workspace Switch)");
                                    }

                                    isIndicatorSuspended = false;
                                }
                            }
                        });
                    }

                    //Print("*** DEBUG isIndicatorSuspended=" + isIndicatorSuspended + " slt=" + StopLossInitialTicks);
                }
            }
        }

        DateTime lastAccountInfoLogOutputTime = DateTime.MinValue;
        const int AccountInfoLoggingOutputThrottleSeconds = 60;
        private void AttemptAccountInfoLogging()
        {
            if (UseAccountInfoLogging)
            {
                bool isNextCycleReady = lastAccountInfoLogOutputTime <= GetDateTimeNow();

                if (isNextCycleReady)
                {
                    lastAccountInfoLogOutputTime = (GetDateTimeNow()).AddSeconds(AccountInfoLoggingOutputThrottleSeconds);

                    if (account != null && IsLiveAccount(account))
                    {
                        double accountBalance = Math.Round(account.Get(AccountItem.CashValue, Currency.UsDollar), 2);
                        double grossRealizedPnL = Math.Round(account.Get(AccountItem.GrossRealizedProfitLoss, Currency.UsDollar), 2);
                        double realizedPnL = Math.Round(account.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar), 2);

                        double accountBalanceWithNewPnL = accountBalance;
                        //if (grossRealizedPnL != 0) accountBalanceWithNewPnL = accountBalance - grossRealizedPnL + realizedPnL;

                        if (accountBalanceWithNewPnL != lastAccountBalance)
                        {
                            RealLogger.PrintOutput("Logging account information...", PrintTo.OutputTab2);
                            string content = "ACCOUNT_BALANCE,ACCOUNT_EQUITY\r\n" + Convert.ToString(accountBalanceWithNewPnL) + "," + Convert.ToString(accountBalanceWithNewPnL);
                            File.WriteAllText(AccountInfoLoggingPath, content);
                            lastAccountBalance = accountBalanceWithNewPnL;
                        }
                    }
                }
            }
        }

        /*
        private void LoadDayOverMaxLossHighestPnLInSessionData()
        {
            return;
            string fileNameAndPath = System.IO.Path.GetTempPath() + TickHunterSessionStateFileName;

            string formattedDateTime = GetDateTimeNow().ToString("d");
            DateTime currentDate = Convert.ToDateTime(formattedDateTime);

            if (File.Exists(fileNameAndPath))
            {
                using (StreamReader reader = new StreamReader(fileNameAndPath))
                {
                    string currentLine;
                    // currentLine will be null when the StreamReader reaches the end of file
                    while ((currentLine = reader.ReadLine()) != null)
                    {
                        // Search, case insensitive, if the currentLine contains the searched keyword
                        if (!(currentLine.IndexOf("DATE,ACCOUNT_ID,ACCOUNT_PNL", StringComparison.CurrentCultureIgnoreCase) >= 0))
                        {
                            RealLogger.PrintOutput("currentLine=" + currentLine);
                            string[] fields = currentLine.Split(',');
                            int fieldAccountId = Convert.ToInt32(fields[1]);
                            if (account.Id == fieldAccountId)
                            {
                                DateTime fieldDate = Convert.ToDateTime(fields[0]);
                                double fieldPnL = Convert.ToDouble(fields[2]);

                                RealLogger.PrintOutput("fieldAccountId=" + fieldAccountId + " date=" + fieldDate + " fieldPnL=" + fieldPnL);
                                bool needsToBeReset = fieldDate < currentDate;

                                if (needsToBeReset)
                                {
                                    lastDayOverMaxLossHighestPnLInSessionChangeDate = currentDate;
                                    lastDayOverMaxLossHighestPnLInSessionPnL = 0;
                                }
                                else
                                {
                                    lastDayOverMaxLossHighestPnLInSessionChangeDate = fieldDate;
                                    lastDayOverMaxLossHighestPnLInSessionPnL = fieldPnL;
                                }

                                RealLogger.PrintOutput("lastDayOverMaxLossHighestPnLInSessionChangeDate=" + lastDayOverMaxLossHighestPnLInSessionChangeDate + " lastDayOverMaxLossHighestPnLInSessionPnL=" + lastDayOverMaxLossHighestPnLInSessionPnL);
                            }
                        }
                    }
                }
            }
            else
            {
                lastDayOverMaxLossHighestPnLInSessionChangeDate = currentDate;
                lastDayOverMaxLossHighestPnLInSessionPnL = 0;
            }
        }
        */

        /*
         * private void StoreStateDayOverMaxLossHighestPnLInSession()
        {
            return; // debug
            try
            {
                string fileNameAndPath = System.IO.Path.GetTempPath() + TickHunterSessionStateFileName;
                string formattedDateTime = GetDateTimeNow().ToString("d");
                double realizedPnL;

                if (DebugLogLevel > 15) RealLogger.PrintOutput("Storing State in (" + fileNameAndPath + ")");

                StringBuilder content = new StringBuilder();

                content.Append("DATE,ACCOUNT_ID,ACCOUNT_PNL\r\n");

                foreach (Account accountItem in Account.All)
                {
                    realizedPnL = Math.Round(accountItem.Get(AccountItem.RealizedProfitLoss, Currency.UsDollar), 2);
                    content.AppendFormat("{0},{1},{2}\r\n", formattedDateTime, accountItem.Id, realizedPnL);
                }

                File.WriteAllText(fileNameAndPath, content.ToString());
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception calling StoreStateDayOverMaxLossHighestPnLInSession:" + ex.Message + " " + ex.StackTrace);
            }
        }
        */
        private double GetPositionProfitWithStoLoss(Instrument instrument, MarketPosition marketPosition, int quantity, double averagePrice, double stopLossPrice)
        {
            double positionProfit = double.MinValue;

            if (stopLossPrice > 0)
            {
                double tickValue = RealInstrumentService.GetTickValue(instrument);
                double tickSize = instrument.MasterInstrument.TickSize;

                if (marketPosition == MarketPosition.Long)
                {
                    positionProfit = (stopLossPrice - averagePrice) * ((tickValue * quantity) / tickSize);
                }
                else if (marketPosition == MarketPosition.Short)
                {
                    positionProfit = (averagePrice - stopLossPrice) * ((tickValue * quantity) / tickSize);
                }

                double commissionPerSide = GetInstrumentCommissionPerSide(instrument);
                bool includeCommissions = (commissionPerSide > 0);

                if (includeCommissions)
                {
                    positionProfit = positionProfit - (quantity * commissionPerSide * 2);
                }
            }

            return (Math.Round(positionProfit, 2, MidpointRounding.ToEven));
        }

        private double GetPositionProfit(RealPosition position)
        {
            double positionProfit = 0;
            double totalVolume = position.Quantity;
            double averagePrice = position.AveragePrice;
            double tickValue = RealInstrumentService.GetTickValue(position.Instrument);
            double tickSize = position.Instrument.MasterInstrument.TickSize;

            if (position.MarketPosition == MarketPosition.Long)
            {
                double bid = RealInstrumentService.GetBidPrice(position.Instrument);

                positionProfit = (bid - averagePrice) * ((tickValue * totalVolume) / tickSize);
            }
            else if (position.MarketPosition == MarketPosition.Short)
            {
                double ask = RealInstrumentService.GetAskPrice(position.Instrument);

                positionProfit = (averagePrice - ask) * ((tickValue * totalVolume) / tickSize);
            }

            double commissionPerSide = GetInstrumentCommissionPerSide(position.Instrument);
            bool includeCommissions = (commissionPerSide > 0);

            if (includeCommissions)
            {
                positionProfit = positionProfit - (totalVolume * commissionPerSide * 2);
            }

            return (Math.Round(positionProfit, 2, MidpointRounding.ToEven));
        }


        private bool IsMicroInstrument(Instrument instrument)
        {
            bool returnFlag = false;

            if (instrument.FullName.StartsWith(MYMPrefix) || instrument.FullName.StartsWith(MESPrefix) || instrument.FullName.StartsWith(M2KPrefix) || instrument.FullName.StartsWith(MNQPrefix))
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool IsEminiInstrument(Instrument instrument)
        {
            bool returnFlag = false;

            if (instrument.FullName.StartsWith(YMPrefix) || instrument.FullName.StartsWith(ESPrefix) || instrument.FullName.StartsWith(RTYPrefix) || instrument.FullName.StartsWith(NQPrefix))
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        private double GetInstrumentCommissionPerSide(Instrument instrument)
        {
            double commissionPerSide = OtherCommissionPerSide;

            if (instrument == mnqInstrument)
            {
                commissionPerSide = MNQCommissionPerSide;
            }
            else if (instrument == mesInstrument)
            {
                commissionPerSide = MESCommissionPerSide;
            }
            else if (instrument == mymInstrument)
            {
                commissionPerSide = MYMCommissionPerSide;
            }
            else if (instrument == m2kInstrument)
            {
                commissionPerSide = M2KCommissionPerSide;
            }
            else if (instrument == nqInstrument)
            {
                commissionPerSide = NQCommissionPerSide;
            }
            else if (instrument == esInstrument)
            {
                commissionPerSide = ESCommissionPerSide;
            }
            else if (instrument == ymInstrument)
            {
                commissionPerSide = YMCommissionPerSide;
            }
            else if (instrument == rtyInstrument)
            {
                commissionPerSide = RTYCommissionPerSide;
            }

            /*
            if (CommissionPerSide <= 0 && account != null && account.Commission != null && account.Commission.ByMasterInstrument.ContainsKey(instrument.MasterInstrument))
            {
                commissionPerSide = account.Commission.ByMasterInstrument[instrument.MasterInstrument].PerUnit;
            }
            else
            {
                //RealLogger.PrintOutput("ERROR: Missing commission per side for instrument '" + instrument.FullName + "'");
            }
            */


            return commissionPerSide;
        }

        private void ChartControl_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (e.ClickCount == 2)
            {
                if (IsCtrlKeyDown())
                {
                    DumpDebugInternalsToOutput();
                }
                //e.Handled = true; // if you want to prevent the chart double click action use true
            }
        }

        private void DumpDebugInternalsToOutput()
        {
            string signalName = "DumpDebugInternalsToOutput";
            try
            {
                if (hasRanOnceFirstCycle)
                {
                    RealLogger.PrintOutput("***Activated DumpDebugInternalsToOutput...");

                    int positionCount = RealPositionService.PositionCount;

                    RealLogger.PrintOutput("Dump Positions: positionCount=" + positionCount);

                    for (int index = 0; index < positionCount; index++)
                    {
                        RealPosition position = null;
                        if (RealPositionService.TryGetByIndex(index, out position))
                        {
                            RealLogger.PrintOutput("- Instrument=" + position.Instrument.FullName + " Type=" + position.MarketPosition.ToString() + " Quan=" + position.Quantity);
                        }
                    }

                    int orderCount = RealOrderService.OrderCount;

                    RealLogger.PrintOutput("Dump Orders: orderCount=" + orderCount);

                    for (int index = 0; index < orderCount; index++)
                    {
                        RealOrder order = null;

                        if (RealOrderService.TryGetByIndex(index, out order))
                        {
                            RealLogger.PrintOutput("- Instrument=" + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " Quan=" + order.Quantity + " State=" + order.OrderState.ToString() + " OrderId=" + order.OrderId);
                        }
                    }

                    int orderUpdateMultiCycleCacheCount = RealOrderService.OrderUpdateMultiCycleCache.Count;

                    RealLogger.PrintOutput("Dump Order Update Multi-Cycle Orders: orderUpdateMultiCycleCacheCount=" + orderUpdateMultiCycleCacheCount);


                    int orderPartialFillCacheCount = RealOrderService.OrderPartialFillCache.Count;

                    RealLogger.PrintOutput("Dump OrderPartialFillCache: orderPartialFillCacheCount=" + orderPartialFillCacheCount);

                    Dictionary<string, int> keyValues = RealOrderService.OrderPartialFillCache;

                    foreach (KeyValuePair<string, int> entry in keyValues)
                    {
                        RealLogger.PrintOutput("- Key=" + entry.Key + " Value=" + entry.Value);
                    }
                }
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception calling DumpInternalsToOutput:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                throw;
            }
        }

        private void AttemptToClosePositionsInProfit()
        {
            string signalName = "AttemptToClosePositionsInProfit";

            if (currentCloseAutoStatus != TickHunterCloseAutoTypes.Disabled || UsePositionProfitLogging || IsBogeyTargetEnabled() || IsECATPEnabled())
            {
                var lockTimeout = TimeSpan.FromMilliseconds(250);
                bool lockTaken = false;

                try
                {
                    Monitor.TryEnter(ClosePositionsInProfitLock, lockTimeout, ref lockTaken);

                    if (lockTaken)
                    {
                        if (RealOrderService.AreAllOrderUpdateCyclesComplete())
                        {
                            bool isCloseAutoSlopeAll = (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage1Slope
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage2Slope
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage3Slope
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage4Break
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.DriftLine4Break
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieBoostedFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieStackedFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.CreeperFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.KLineDualFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.ZLineDualFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.KZFlip
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.ProfilePeppy
                                || currentCloseAutoStatus == TickHunterCloseAutoTypes.ProfileSleepy
                                );

                            if ((!IsAccountFlat(attachedInstrument) || (IsBlendedInstrumentEnabled() && !IsAccountFlat(blendedInstrument))) && !IsHODLEnabled())
                            {
                                int totalVolume = 0;
                                //int totalMicroVolume = 0;
                                //int totalEminiVolume = 0;
                                int totalOtherVolume = 0;
                                int totalMNQVolume = 0;
                                int totalNQVolume = 0;
                                int totalM2KVolume = 0;
                                int totalRTYVolume = 0;
                                int totalMESVolume = 0;
                                int totalESVolume = 0;
                                int totalMYMVolume = 0;
                                int totalYMVolume = 0;
                                double totalUnrealizedProfitLoss = 0;
                                double unrealizedProfitLoss = 0;
                                bool hasPosition = false;
                                bool hasAttachedPosition = false;
                                bool hasBlendedPosition = false;
                                double attachedPositionAveragePrice = 0;
                                double totalUnrealizedProfitLossAttached = 0;
                                int totalQuantityAttached = 0;

                                MarketPosition positionMarketPosition = MarketPosition.Flat;
                                int positionQuantity = 0;

                                int positionCount = RealPositionService.PositionCount;

                                for (int index = 0; index < positionCount; index++)
                                {
                                    RealPosition position = null;
                                    if (RealPositionService.TryGetByIndex(index, out position))
                                    {
                                        hasPosition = true;

                                        positionQuantity = position.Quantity;
                                        totalVolume += positionQuantity;
                                        //if (IsMicroInstrument(position.Instrument)) totalMicroVolume += positionQuantity;
                                        //else if (IsEminiInstrument(position.Instrument)) totalEminiVolume += positionQuantity;

                                        if (position.Instrument == mymInstrument)
                                            totalMYMVolume += position.Quantity;
                                        else if (position.Instrument == mesInstrument)
                                            totalMESVolume += position.Quantity;
                                        else if (position.Instrument == m2kInstrument)
                                            totalM2KVolume += position.Quantity;
                                        else if (position.Instrument == mnqInstrument)
                                            totalMNQVolume += position.Quantity;
                                        else if (position.Instrument == ymInstrument)
                                            totalYMVolume += position.Quantity;
                                        else if (position.Instrument == esInstrument)
                                            totalESVolume += position.Quantity;
                                        else if (position.Instrument == rtyInstrument)
                                            totalRTYVolume += position.Quantity;
                                        else if (position.Instrument == nqInstrument)
                                            totalNQVolume += position.Quantity;
                                        else
                                            totalOtherVolume += position.Quantity;

                                        unrealizedProfitLoss = GetPositionProfit(position);
                                        totalUnrealizedProfitLoss += Math.Round(unrealizedProfitLoss, 2);

                                        if (position.Instrument == attachedInstrument)
                                        {
                                            hasAttachedPosition = true;
                                            positionMarketPosition = position.MarketPosition;
                                            totalUnrealizedProfitLossAttached += Math.Round(unrealizedProfitLoss, 2);
                                            totalQuantityAttached += positionQuantity;
                                            attachedPositionAveragePrice = position.AveragePrice;
                                        }
                                        else if (position.Instrument == blendedInstrument)
                                        {
                                            hasBlendedPosition = true;
                                        }
                                    }
                                }

                                if (hasPosition)
                                {
                                    double minAutoCloseProfit = (AutoCloseMinProfitDollarsPerVolume * totalQuantityAttached);

                                    double expectedECAProfitDollars = GetECATakeProfitDollars(totalVolume, totalOtherVolume,
                                        totalMYMVolume, totalMESVolume, totalM2KVolume, totalMNQVolume,
                                        totalYMVolume, totalESVolume, totalRTYVolume, totalNQVolume);

                                    cacheECATakeProfitDollars = expectedECAProfitDollars;

                                    if (UsePositionProfitLogging && hasAttachedPosition)
                                    {
                                        if (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget)
                                        {
                                            RealLogger.PrintOutput("Total vs Target PnL: $" + totalUnrealizedProfitLoss.ToString("N2") + " vs $" + expectedECAProfitDollars.ToString("N2") + " with " + Convert.ToString(totalVolume) + " volume / avg price " + attachedPositionAveragePrice.ToString("N2") + " via " + signalName, PrintTo.OutputTab1, true, true);
                                        }
                                        else
                                        {
                                            RealLogger.PrintOutput("Total PnL: $" + totalUnrealizedProfitLoss.ToString("N2") + " with " + Convert.ToString(totalVolume) + " volume / avg price " + attachedPositionAveragePrice.ToString("N2") + " via " + signalName, PrintTo.OutputTab1, true, true);
                                        }
                                    }

                                    if (hasAttachedPosition || hasBlendedPosition)
                                    {
                                        if (IsECATPEnabled()
                                            && !IsHODLEnabled()
                                            && totalUnrealizedProfitLoss > 0
                                            && expectedECAProfitDollars > 0
                                            && totalUnrealizedProfitLoss >= expectedECAProfitDollars)
                                        {
                                            bool hasSyncedECATakeProfit = (IsAutoPositionTakeProfitEnabled() && IsECATPEnabled()
                                                && this.TakeProfitSyncECATargetPrice && lastECATakeProfitLinePrice > 0
                                                && this.TakeProfitRefreshManagementEnabled);
                                            //&& (attachedInstrumentPositionTakeProfitPrice > 0 || blendedInstrumentPositionTakeProfitPrice > 0));

                                            if (!hasSyncedECATakeProfit)
                                            {
                                                DeactivateAutoEntryFeatures(signalName);

                                                RealLogger.PrintOutput("ECA target reached: Total vs Target PnL: $" + totalUnrealizedProfitLoss.ToString("N2") + " vs $" + expectedECAProfitDollars.ToString("N2") + " with " + Convert.ToString(totalVolume) + " volume" + " via " + signalName, PrintTo.OutputTab1, true, false);
                                                FlattenEverything("EquityCloseAllTakeProfit", true, null);
                                            }
                                        }
                                        else if (IsBogeyTargetEnabled()
                                            && !IsHODLEnabled()
                                            && lastBogeyTargetBaseDollars > 0
                                            && totalUnrealizedProfitLoss > 0
                                            && totalUnrealizedProfitLoss >= lastBogeyTargetBaseDollars
                                            && lastBogeyTargetLinePrice > 0)
                                        {
                                            bool hasSyncedECATakeProfit = (IsAutoPositionTakeProfitEnabled() && IsECATPEnabled()
                                                && this.TakeProfitSyncECATargetPrice && lastECATakeProfitLinePrice > 0
                                                && this.TakeProfitRefreshManagementEnabled);
                                            //&& (attachedInstrumentPositionTakeProfitPrice > 0 || blendedInstrumentPositionTakeProfitPrice > 0));

                                            bool hasSyncedBogeyTakeProfit = (IsAutoPositionTakeProfitEnabled() && IsBogeyTargetEnabled()
                                                && this.TakeProfitSyncBogeyTargetPrice && lastBogeyTargetLinePrice > 0
                                                && this.TakeProfitRefreshManagementEnabled);
                                            //&& (attachedInstrumentPositionTakeProfitPrice > 0 || blendedInstrumentPositionTakeProfitPrice > 0));

                                            if (!hasSyncedBogeyTakeProfit && !hasSyncedECATakeProfit)
                                            {
                                                string formattedDailyMaxProfitDollars = "";
                                                if (lastBogeyTargetBaseDollars > 0)
                                                {
                                                    formattedDailyMaxProfitDollars = "$" + lastBogeyTargetBaseDollars.ToString("N0");
                                                }
                                                else
                                                {
                                                    formattedDailyMaxProfitDollars = "($" + lastBogeyTargetBaseDollars.ToString("N0") + ")";
                                                }

                                                DeactivateAutoEntryFeatures(signalName);

                                                RealLogger.PrintOutput("Bogey target reached: $" + BogeyTargetBaseDollars.ToString("N0") + " / " + formattedDailyMaxProfitDollars, PrintTo.OutputTab1, false);

                                                FlattenEverything("BogeyTarget", true, null);
                                            }
                                        }
                                        else if (isCloseAutoSlopeAll)
                                        {

                                            if (AutoCloseRunOncePerBar.IsFirstRunThisBar)
                                            {
                                                AutoCloseRunOncePerBar.SetRunCompletedThisBar();

                                                bool closePositionFlag = false;

                                                bool hasMinAutoCloseProfit = totalUnrealizedProfitLossAttached >= minAutoCloseProfit;

                                                if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage1Slope
                                                    && ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit)))
                                                {

                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        if (autoCloseAndTrailMA1Value < autoCloseAndTrailMA1Value2 && autoCloseAndTrailMA1Value2 >= autoCloseAndTrailMA1Value3)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        if (autoCloseAndTrailMA1Value >= autoCloseAndTrailMA1Value2 && autoCloseAndTrailMA1Value2 < autoCloseAndTrailMA1Value3)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }

                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage2Slope
                                                    && ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit)))
                                                {

                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        if (autoCloseAndTrailMA2Value < autoCloseAndTrailMA2Value2 && autoCloseAndTrailMA2Value2 >= autoCloseAndTrailMA2Value3)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        if (autoCloseAndTrailMA2Value >= autoCloseAndTrailMA2Value2 && autoCloseAndTrailMA2Value2 < autoCloseAndTrailMA2Value3)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }

                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage3Slope
                                                    && ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit)))
                                                {

                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        if (autoCloseAndTrailMA3Value < autoCloseAndTrailMA3Value2 && autoCloseAndTrailMA3Value2 >= autoCloseAndTrailMA3Value3)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        if (autoCloseAndTrailMA3Value >= autoCloseAndTrailMA3Value2 && autoCloseAndTrailMA3Value2 < autoCloseAndTrailMA3Value3)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage4Break
                                                    && ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit)))
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        bool sellCreeperRiverBreak = autoPilotSetupCreeperSellContinuation1
                                                            && (
                                                                (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8 && previous9ClosePrice >= autoCloseAndTrailMA4Value9)
                                                            || (previous1ClosePrice < autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8 && previous9ClosePrice < autoCloseAndTrailMA4Value9 && previous10ClosePrice >= autoCloseAndTrailMA4Value10)
                                                            );

                                                        if (sellCreeperRiverBreak)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        bool buyCreeperRiverBreak = autoPilotSetupCreeperBuyContinuation1
                                                            && (
                                                                (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice < autoCloseAndTrailMA4Value2)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice < autoCloseAndTrailMA4Value3)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice < autoCloseAndTrailMA4Value4)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice < autoCloseAndTrailMA4Value5)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice < autoCloseAndTrailMA4Value6)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice < autoCloseAndTrailMA4Value7)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice < autoCloseAndTrailMA4Value8)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8 && previous9ClosePrice < autoCloseAndTrailMA4Value9)
                                                            || (previous1ClosePrice >= autoCloseAndTrailMA4Value && previous2ClosePrice >= autoCloseAndTrailMA4Value2 && previous3ClosePrice >= autoCloseAndTrailMA4Value3 && previous4ClosePrice >= autoCloseAndTrailMA4Value4 && previous5ClosePrice >= autoCloseAndTrailMA4Value5 && previous6ClosePrice >= autoCloseAndTrailMA4Value6 && previous7ClosePrice >= autoCloseAndTrailMA4Value7 && previous8ClosePrice >= autoCloseAndTrailMA4Value8 && previous9ClosePrice >= autoCloseAndTrailMA4Value9 && previous10ClosePrice < autoCloseAndTrailMA4Value10)
                                                            );

                                                        if (buyCreeperRiverBreak)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.DriftLine4Break
                                                    && ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit)))
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        bool sellCreeperDriftBreak = autoPilotSetupCreeperSellContinuation1
                                                            && (
                                                                (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9)
                                                            || (previous1ClosePrice < autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9 && previous10ClosePrice >= autoCloseAndTrailDL4Value10)
                                                            );

                                                        if (sellCreeperDriftBreak)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        bool buyCreeperDriftBreak = autoPilotSetupCreeperBuyContinuation1
                                                            && (
                                                                (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice < autoCloseAndTrailDL4Value2)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice < autoCloseAndTrailDL4Value3)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice < autoCloseAndTrailDL4Value4)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice < autoCloseAndTrailDL4Value5)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice < autoCloseAndTrailDL4Value6)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice < autoCloseAndTrailDL4Value7)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice < autoCloseAndTrailDL4Value8)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice < autoCloseAndTrailDL4Value9)
                                                            || (previous1ClosePrice >= autoCloseAndTrailDL4Value && previous2ClosePrice >= autoCloseAndTrailDL4Value2 && previous3ClosePrice >= autoCloseAndTrailDL4Value3 && previous4ClosePrice >= autoCloseAndTrailDL4Value4 && previous5ClosePrice >= autoCloseAndTrailDL4Value5 && previous6ClosePrice >= autoCloseAndTrailDL4Value6 && previous7ClosePrice >= autoCloseAndTrailDL4Value7 && previous8ClosePrice >= autoCloseAndTrailDL4Value8 && previous9ClosePrice >= autoCloseAndTrailDL4Value9 && previous10ClosePrice < autoCloseAndTrailDL4Value10)
                                                            );

                                                        if (buyCreeperDriftBreak)
                                                        {
                                                            closePositionFlag = true;
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieFlip)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        bool sellZombieSetup = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;

                                                        if (sellZombieSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "BUY";
                                                                string algoSetupName = "ZombieFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                if (PlaySoundOnSetupAlert)
                                                                {
                                                                    PlaySound(fullSoundFilename);
                                                                }

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        bool buyZombieSetup = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;

                                                        if (buyZombieSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "SELL";
                                                                string algoSetupName = "ZombieFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieStackedFlip)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        bool altSellZombieSetup1 = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;
                                                        bool altSellCreeperSetup1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;

                                                        bool sellZombieStackedSetup = (altSellZombieSetup1 && autoPilotSetupCreeperSellContinuation1)
                                                            || (altSellCreeperSetup1 && autoPilotSetupZombieSellContinuation1);

                                                        if (sellZombieStackedSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "BUY";
                                                                string algoSetupName = "ZombieStackedFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        bool altBuyZombieSetup1 = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;
                                                        bool altBuyCreeperSetup1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;

                                                        bool buyZombieStackedSetup = (altBuyZombieSetup1 && autoPilotSetupCreeperBuyContinuation1)
                                                            || (altBuyCreeperSetup1 && autoPilotSetupZombieBuyContinuation1);

                                                        if (buyZombieStackedSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "SELL";
                                                                string algoSetupName = "ZombieStackedFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieBoostedFlip)
                                                {
                                                    if (hasAttachedPosition)
                                                    {

                                                        bool buyZombieBoostedSetup = (autoPilotSetupZombieBuySetup2 && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup3 && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup4 && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup5 && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup6 && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup7 && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup8 && autoPilotSetupZombieBuyContinuation7 && !previous7CandleBullish && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                            || (autoPilotSetupZombieBuySetup9 && autoPilotSetupZombieBuyContinuation8 && !previous8CandleBullish && autoPilotSetupZombieBuyContinuation7 && !previous7CandleBullish && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish);


                                                        bool sellZombieBoostedSetup = (autoPilotSetupZombieSellSetup2 && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup3 && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup4 && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup5 && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup6 && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup7 && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup8 && autoPilotSetupZombieSellContinuation7 && previous7CandleBullish && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                            || (autoPilotSetupZombieSellSetup9 && autoPilotSetupZombieSellContinuation8 && previous8CandleBullish && autoPilotSetupZombieSellContinuation7 && previous7CandleBullish && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish);

                                                        if (positionMarketPosition == MarketPosition.Long)
                                                        {

                                                            if (sellZombieBoostedSetup)
                                                            {
                                                                bool isInAlertMode = closeAutoAlertFlag;

                                                                if (isInAlertMode)
                                                                {
                                                                    string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                    string orderTypeText = "BUY";
                                                                    string algoSetupName = "ZombieBoostedFlip";

                                                                    string messageTitle = CloseAlertMessageTitle;
                                                                    string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                    ExitCloseAlertWindows();
                                                                    ExitTradeAlertWindows();

                                                                    RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                    {
                                                                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                        if (result == MessageBoxResult.Yes)
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                            FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                        }
                                                                        else
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                        }

                                                                    }));
                                                                }
                                                                else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                                {
                                                                    closePositionFlag = true;
                                                                }
                                                            }
                                                        }
                                                        else if (positionMarketPosition == MarketPosition.Short)
                                                        {
                                                            if (buyZombieBoostedSetup)
                                                            {
                                                                bool isInAlertMode = closeAutoAlertFlag;

                                                                if (isInAlertMode)
                                                                {
                                                                    string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                    string orderTypeText = "SELL";
                                                                    string algoSetupName = "ZombieBoostedFlip";

                                                                    string messageTitle = CloseAlertMessageTitle;
                                                                    string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                    ExitCloseAlertWindows();
                                                                    ExitTradeAlertWindows();

                                                                    RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                    {
                                                                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                        if (result == MessageBoxResult.Yes)
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                            FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                        }
                                                                        else
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                        }

                                                                    }));
                                                                }
                                                                else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                                {
                                                                    closePositionFlag = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.KLineDualFlip)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        double lowestKLinePrice = Math.Min(GetKineticLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool sellKLineDualSetup = lowestKLinePrice > previous1ClosePrice;

                                                        if (sellKLineDualSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "BUY";
                                                                string algoSetupName = "KLineDualFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                if (PlaySoundOnSetupAlert)
                                                                {
                                                                    PlaySound(fullSoundFilename);
                                                                }

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        double highestKLinePrice = Math.Max(GetKineticLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool buyKLineDualSetup = highestKLinePrice < previous1ClosePrice;

                                                        if (buyKLineDualSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "SELL";
                                                                string algoSetupName = "KLineDualFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.CreeperFlip)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        /*
                                                        bool sellCreeperSetup = (!previous1CandleBullish && autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3)
                                                            || (!previous1CandleBullish && previous2CandleBullish && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3 && autoPilotSetupCreeperValue3 >= autoPilotSetupCreeperValue4)
                                                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && autoPilotSetupCreeperValue3 < autoPilotSetupCreeperValue4 && autoPilotSetupCreeperValue4 >= autoPilotSetupCreeperValue5)
                                                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && autoPilotSetupCreeperValue4 < autoPilotSetupCreeperValue5 && autoPilotSetupCreeperValue5 >= autoPilotSetupCreeperValue6)
                                                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && autoPilotSetupCreeperValue5 < autoPilotSetupCreeperValue6 && autoPilotSetupCreeperValue6 >= autoPilotSetupCreeperValue7)
                                                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && previous6CandleBullish && autoPilotSetupCreeperValue6 < autoPilotSetupCreeperValue7 && autoPilotSetupCreeperValue7 >= autoPilotSetupCreeperValue8)
                                                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && previous6CandleBullish && previous7CandleBullish && autoPilotSetupCreeperValue7 < autoPilotSetupCreeperValue8 && autoPilotSetupCreeperValue8 >= autoPilotSetupCreeperValue9)
                                                            || (!previous1CandleBullish && previous2CandleBullish && previous3CandleBullish && previous4CandleBullish && previous5CandleBullish && previous6CandleBullish && previous7CandleBullish && previous8CandleBullish && autoPilotSetupCreeperValue8 < autoPilotSetupCreeperValue9 && autoPilotSetupCreeperValue9 >= autoPilotSetupCreeperValue10);
                                                        */

                                                        bool sellCreeperSetup = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;

                                                        if (sellCreeperSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "BUY";
                                                                string algoSetupName = "CreeperFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        /*
                                                        bool buyCreeperSetup = (previous1CandleBullish && autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3)
                                                            || (previous1CandleBullish && !previous2CandleBullish && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3 && autoPilotSetupCreeperValue3 < autoPilotSetupCreeperValue4)
                                                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && autoPilotSetupCreeperValue3 >= autoPilotSetupCreeperValue4 && autoPilotSetupCreeperValue4 < autoPilotSetupCreeperValue5)
                                                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && autoPilotSetupCreeperValue4 >= autoPilotSetupCreeperValue5 && autoPilotSetupCreeperValue5 < autoPilotSetupCreeperValue6)
                                                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && autoPilotSetupCreeperValue5 >= autoPilotSetupCreeperValue6 && autoPilotSetupCreeperValue6 < autoPilotSetupCreeperValue7)
                                                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && !previous6CandleBullish && autoPilotSetupCreeperValue6 >= autoPilotSetupCreeperValue7 && autoPilotSetupCreeperValue7 < autoPilotSetupCreeperValue8)
                                                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && !previous6CandleBullish && !previous7CandleBullish && autoPilotSetupCreeperValue7 >= autoPilotSetupCreeperValue8 && autoPilotSetupCreeperValue8 < autoPilotSetupCreeperValue9)
                                                            || (previous1CandleBullish && !previous2CandleBullish && !previous3CandleBullish && !previous4CandleBullish && !previous5CandleBullish && !previous6CandleBullish && !previous7CandleBullish && !previous8CandleBullish && autoPilotSetupCreeperValue8 >= autoPilotSetupCreeperValue9 && autoPilotSetupCreeperValue9 < autoPilotSetupCreeperValue10);
                                                        */

                                                        bool buyCreeperSetup = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;

                                                        if (buyCreeperSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "SELL";
                                                                string algoSetupName = "CreeperFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }

                                                    //RealLogger.PrintOutput("positionMarketPosition=" + positionMarketPosition.ToString() + " autoPilotSetupCreeperValue=" + autoPilotSetupCreeperValue + " autoPilotSetupCreeperValue2=" + autoPilotSetupCreeperValue2 + " autoPilotSetupCreeperValue3=" + autoPilotSetupCreeperValue3 + " closePositionFlag=" + closePositionFlag);
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZLineDualFlip)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        double lowestZipLinePrice = Math.Min(GetZipLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool sellZipLineDualSetup = lowestZipLinePrice > previous1ClosePrice;

                                                        if (sellZipLineDualSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "BUY";
                                                                string algoSetupName = "ZLineDualFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        double highestZipLinePrice = Math.Max(GetZipLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool buyZipLineDualSetup = highestZipLinePrice < previous1ClosePrice;

                                                        if (buyZipLineDualSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "SELL";
                                                                string algoSetupName = "ZLineDualFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }

                                                    //RealLogger.PrintOutput("positionMarketPosition=" + positionMarketPosition.ToString() + " autoPilotSetupCreeperValue=" + autoPilotSetupCreeperValue + " autoPilotSetupCreeperValue2=" + autoPilotSetupCreeperValue2 + " autoPilotSetupCreeperValue3=" + autoPilotSetupCreeperValue3 + " closePositionFlag=" + closePositionFlag);
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.KZFlip)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        double lowestZipLinePrice = Math.Min(GetZipLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool sellZipLineDualSetup = lowestZipLinePrice > previous1ClosePrice;

                                                        double lowestKLinePrice = Math.Min(GetKineticLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool sellKLineDualSetup = lowestKLinePrice > previous1ClosePrice;

                                                        if (sellZipLineDualSetup && sellKLineDualSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "BUY";
                                                                string algoSetupName = "KZFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        double highestZipLinePrice = Math.Max(GetZipLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool buyZipLineDualSetup = highestZipLinePrice < previous1ClosePrice;

                                                        double highestKLinePrice = Math.Max(GetKineticLine1Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(positionMarketPosition, AutoCloseAndTrailOffsetTicks));
                                                        bool buyKLineDualSetup = highestKLinePrice < previous1ClosePrice;

                                                        if (buyZipLineDualSetup && buyKLineDualSetup)
                                                        {
                                                            bool isInAlertMode = closeAutoAlertFlag;

                                                            if (isInAlertMode)
                                                            {
                                                                string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                string orderTypeText = "SELL";
                                                                string algoSetupName = "KZFlip";

                                                                string messageTitle = CloseAlertMessageTitle;
                                                                string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                ExitCloseAlertWindows();
                                                                ExitTradeAlertWindows();

                                                                RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                {
                                                                    MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                    if (result == MessageBoxResult.Yes)
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                        FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                    }
                                                                    else
                                                                    {
                                                                        RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                    }

                                                                }));
                                                            }
                                                            else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                            {
                                                                closePositionFlag = true;
                                                            }
                                                        }
                                                    }

                                                    //RealLogger.PrintOutput("positionMarketPosition=" + positionMarketPosition.ToString() + " autoPilotSetupCreeperValue=" + autoPilotSetupCreeperValue + " autoPilotSetupCreeperValue2=" + autoPilotSetupCreeperValue2 + " autoPilotSetupCreeperValue3=" + autoPilotSetupCreeperValue3 + " closePositionFlag=" + closePositionFlag);
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ProfilePeppy)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        bool altSellCreeperSetup1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;
                                                        bool sellZombieSetup = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;

                                                        if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOnly)
                                                        {
                                                            sellZombieSetup = false;
                                                        }
                                                        else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOnly)
                                                        {
                                                            altSellCreeperSetup1 = false;
                                                        }

                                                        if ((altSellCreeperSetup1 || sellZombieSetup)
                                                            && !attachedInstrumentPositionCreeperSurging
                                                            && !attachedInstrumentPositionCreeperGushing1)
                                                        {
                                                            double newProfileStopLossPrice = 0;
                                                            newProfileStopLossPrice = FilterFlow1PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1)
                                                                newProfileStopLossPrice = FilterFlow2PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2)
                                                                newProfileStopLossPrice = FilterFlow3PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2 && !attachedInstrumentPositionFlowing3)
                                                                newProfileStopLossPrice = FilterFlow4PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1
                                                                || !attachedInstrumentPositionFlowing2
                                                                || !attachedInstrumentPositionFlowing3
                                                                || !attachedInstrumentPositionFlowing4)
                                                            {
                                                                bool isInAlertMode = closeAutoAlertFlag;

                                                                if (isInAlertMode && closeAutoMinProfitFlag && !hasMinAutoCloseProfit)
                                                                {
                                                                    string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                    string orderTypeText = "BUY";
                                                                    string algoSetupName = "CreeperFlip";
                                                                    if (altSellCreeperSetup1 && sellZombieSetup)
                                                                        algoSetupName = "StackedFlip";
                                                                    else if (sellZombieSetup)
                                                                        algoSetupName = "ZombieFlip";


                                                                    string messageTitle = CloseAlertMessageTitle;
                                                                    string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                    ExitCloseAlertWindows();
                                                                    ExitTradeAlertWindows();

                                                                    RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                    {
                                                                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                        if (result == MessageBoxResult.Yes)
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                            FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                        }
                                                                        else
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                        }

                                                                    }));
                                                                }
                                                                else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                                {
                                                                    closePositionFlag = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        bool altBuyCreeperSetup1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;
                                                        bool buyZombieSetup = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;

                                                        if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOnly)
                                                        {
                                                            buyZombieSetup = false;
                                                        }
                                                        else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOnly)
                                                        {
                                                            altBuyCreeperSetup1 = false;
                                                        }

                                                        if ((altBuyCreeperSetup1 || buyZombieSetup)
                                                            && !attachedInstrumentPositionCreeperSurging
                                                            && !attachedInstrumentPositionCreeperGushing1)
                                                        {
                                                            double newProfileStopLossPrice = 0;
                                                            newProfileStopLossPrice = FilterFlow1PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1)
                                                                newProfileStopLossPrice = FilterFlow2PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2)
                                                                newProfileStopLossPrice = FilterFlow3PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2 && !attachedInstrumentPositionFlowing3)
                                                                newProfileStopLossPrice = FilterFlow4PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1
                                                                || !attachedInstrumentPositionFlowing2
                                                                || !attachedInstrumentPositionFlowing3
                                                                || !attachedInstrumentPositionFlowing4)
                                                            {
                                                                bool isInAlertMode = closeAutoAlertFlag;

                                                                if (isInAlertMode && closeAutoMinProfitFlag && !hasMinAutoCloseProfit)
                                                                {
                                                                    string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                    string orderTypeText = "SELL";
                                                                    string algoSetupName = "CreeperFlip";
                                                                    if (altBuyCreeperSetup1 && buyZombieSetup)
                                                                        algoSetupName = "StackedFlip";
                                                                    else if (buyZombieSetup)
                                                                        algoSetupName = "ZombieFlip";

                                                                    string messageTitle = CloseAlertMessageTitle;
                                                                    string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                    ExitCloseAlertWindows();
                                                                    ExitTradeAlertWindows();

                                                                    RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                    {
                                                                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                        if (result == MessageBoxResult.Yes)
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                            FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                        }
                                                                        else
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                        }

                                                                    }));
                                                                }
                                                                else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                                {
                                                                    closePositionFlag = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ProfileSleepy)
                                                {
                                                    if (hasAttachedPosition && positionMarketPosition == MarketPosition.Long)
                                                    {
                                                        bool altSellCreeperSetup1 = autoPilotSetupCreeperValue < autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 >= autoPilotSetupCreeperValue3;
                                                        bool sellZombieSetup = autoPilotSetupZombieValue == ZombieSetupSellCode && autoPilotSetupZombieValue2 == ZombieSetupBuyCode;

                                                        if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOnly)
                                                        {
                                                            sellZombieSetup = false;
                                                        }
                                                        else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOnly)
                                                        {
                                                            altSellCreeperSetup1 = false;
                                                        }

                                                        if ((altSellCreeperSetup1 || sellZombieSetup)
                                                            && !attachedInstrumentPositionCreeperSurging
                                                            && !attachedInstrumentPositionCreeperGushing1)
                                                        {
                                                            double newProfileStopLossPrice = 0;
                                                            newProfileStopLossPrice = FilterFlow1PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1)
                                                                newProfileStopLossPrice = FilterFlow2PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2)
                                                                newProfileStopLossPrice = FilterFlow3PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2 && !attachedInstrumentPositionFlowing3)
                                                                newProfileStopLossPrice = FilterFlow4PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1
                                                                || !attachedInstrumentPositionFlowing2
                                                                || !attachedInstrumentPositionFlowing3
                                                                || !attachedInstrumentPositionFlowing4)
                                                            {
                                                                bool isInAlertMode = closeAutoAlertFlag;

                                                                if (isInAlertMode && closeAutoMinProfitFlag && !hasMinAutoCloseProfit)
                                                                {
                                                                    string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                    string orderTypeText = "BUY";
                                                                    string algoSetupName = "CreeperFlip";
                                                                    if (altSellCreeperSetup1 && sellZombieSetup)
                                                                        algoSetupName = "StackedFlip";
                                                                    else if (sellZombieSetup)
                                                                        algoSetupName = "ZombieFlip";

                                                                    string messageTitle = CloseAlertMessageTitle;
                                                                    string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                    ExitCloseAlertWindows();
                                                                    ExitTradeAlertWindows();

                                                                    RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                    {
                                                                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                        if (result == MessageBoxResult.Yes)
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                            FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                        }
                                                                        else
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                        }

                                                                    }));
                                                                }
                                                                else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                                {
                                                                    //closePositionFlag = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else if (hasAttachedPosition && positionMarketPosition == MarketPosition.Short)
                                                    {
                                                        bool altBuyCreeperSetup1 = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2 && autoPilotSetupCreeperValue2 < autoPilotSetupCreeperValue3;
                                                        bool buyZombieSetup = autoPilotSetupZombieValue == ZombieSetupBuyCode && autoPilotSetupZombieValue2 == ZombieSetupSellCode;

                                                        if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.CreeperOnly)
                                                        {
                                                            buyZombieSetup = false;
                                                        }
                                                        else if (currentAutoPilotProfileSetupStatus == TickHunterAutoPilotProfileSetupTypes.ZombieOnly)
                                                        {
                                                            altBuyCreeperSetup1 = false;
                                                        }

                                                        if ((altBuyCreeperSetup1 || buyZombieSetup)
                                                            && !attachedInstrumentPositionCreeperSurging
                                                            && !attachedInstrumentPositionCreeperGushing1)
                                                        {
                                                            double newProfileStopLossPrice = 0;
                                                            newProfileStopLossPrice = FilterFlow1PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1)
                                                                newProfileStopLossPrice = FilterFlow2PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2)
                                                                newProfileStopLossPrice = FilterFlow3PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1 && !attachedInstrumentPositionFlowing2 && !attachedInstrumentPositionFlowing3)
                                                                newProfileStopLossPrice = FilterFlow4PriceMovement(signalName, attachedInstrument, positionMarketPosition, attachedInstrumentPositionPrice, attachedInstrumentPositionStopLossPrice, newProfileStopLossPrice);

                                                            if (!attachedInstrumentPositionFlowing1
                                                                || !attachedInstrumentPositionFlowing2
                                                                || !attachedInstrumentPositionFlowing3
                                                                || !attachedInstrumentPositionFlowing4)
                                                            {
                                                                bool isInAlertMode = closeAutoAlertFlag;

                                                                if (isInAlertMode && closeAutoMinProfitFlag && !hasMinAutoCloseProfit)
                                                                {
                                                                    string formattedDateTime = GetDateTimeNow().ToString("d") + " " + GetDateTimeNow().ToString("T");

                                                                    string orderTypeText = "SELL";
                                                                    string algoSetupName = "CreeperFlip";
                                                                    if (altBuyCreeperSetup1 && buyZombieSetup)
                                                                        algoSetupName = "StackedFlip";
                                                                    else if (buyZombieSetup)
                                                                        algoSetupName = "ZombieFlip";

                                                                    string messageTitle = CloseAlertMessageTitle;
                                                                    string message = "AutoClose detected " + algoSetupName + " setup at '" + formattedDateTime + "' for " + GetInstrumentPeriodText() + ".  Would you like to close the " + orderTypeText + " position?";

                                                                    ExitCloseAlertWindows();
                                                                    ExitTradeAlertWindows();

                                                                    RealLogger.PrintOutput("AutoClose detected " + algoSetupName + " setup and now opening close alert prompt for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                    ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                                                                    {
                                                                        MessageBoxResult result = ShowMessageBox(Window.GetWindow(ChartControl.OwnerChart as DependencyObject), message, messageTitle, MessageBoxButton.YesNoCancel, MessageBoxImage.Question, hasMinAutoCloseProfit);

                                                                        if (result == MessageBoxResult.Yes)
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt accepted " + algoSetupName + " setup and now opening closing the " + orderTypeText + " position for " + GetInstrumentPeriodText() + " via " + signalName);

                                                                            FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);
                                                                        }
                                                                        else
                                                                        {
                                                                            RealLogger.PrintOutput("AutoClose close alert prompt declined " + algoSetupName + "setup  for " + GetInstrumentPeriodText() + " via " + signalName);
                                                                        }

                                                                    }));
                                                                }
                                                                else if ((!closeAutoMinProfitFlag) || (closeAutoMinProfitFlag && hasMinAutoCloseProfit))
                                                                {
                                                                    //closePositionFlag = true;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }

                                                if (closePositionFlag)
                                                {
                                                    FlattenEverything(currentCloseAutoStatus.ToString(), true, attachedInstrument);

                                                }

                                            }
                                        }
                                    }
                                }
                            }
                            else if (currentTradeSignalStatus != TickHunterTradeSignalTypes.Disabled
                                && (currentAutoPilotLiteStatus != TickHunterAutoPilotLiteTypes.AlertSetup))
                            {
                                if (isCloseAutoSlopeAll)
                                {
                                    if (AutoCloseRunOncePerBar.IsFirstRunThisBar)
                                    {
                                        AutoCloseRunOncePerBar.SetRunCompletedThisBar();

                                        int buyPendingOrderCount = 0;
                                        int sellPendingOrderCount = 0;

                                        bool hasPendingOrder = GetPopDropOrderCount(out buyPendingOrderCount, out sellPendingOrderCount);
                                        bool hasBuyPendingOrder = (buyPendingOrderCount > 0);

                                        bool closePendingOrderFlag = false;

                                        if (hasPendingOrder)
                                        {
                                            if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage1Slope)
                                            {
                                                if (hasBuyPendingOrder)
                                                {
                                                    if (autoCloseAndTrailMA1Value < autoCloseAndTrailMA1Value2 && autoCloseAndTrailMA1Value2 >= autoCloseAndTrailMA1Value3)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                                else
                                                {
                                                    if (autoCloseAndTrailMA1Value >= autoCloseAndTrailMA1Value2 && autoCloseAndTrailMA1Value2 < autoCloseAndTrailMA1Value3)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                            }
                                            else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage2Slope)
                                            {

                                                if (hasBuyPendingOrder)
                                                {
                                                    if (autoCloseAndTrailMA2Value < autoCloseAndTrailMA2Value2 && autoCloseAndTrailMA2Value2 >= autoCloseAndTrailMA2Value3)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                                else
                                                {
                                                    if (autoCloseAndTrailMA2Value >= autoCloseAndTrailMA2Value2 && autoCloseAndTrailMA2Value2 < autoCloseAndTrailMA2Value3)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                            }
                                            else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage3Slope)
                                            {

                                                if (hasBuyPendingOrder)
                                                {
                                                    if (autoCloseAndTrailMA3Value < autoCloseAndTrailMA3Value2 && autoCloseAndTrailMA3Value2 >= autoCloseAndTrailMA3Value3)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                                else
                                                {
                                                    if (autoCloseAndTrailMA3Value >= autoCloseAndTrailMA3Value2 && autoCloseAndTrailMA3Value2 < autoCloseAndTrailMA3Value3)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                            }
                                            else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieFlip)
                                            {

                                                if (hasBuyPendingOrder)
                                                {
                                                    if (autoPilotSetupZombieValue == ZombieSetupSellCode)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                                else
                                                {
                                                    if (autoPilotSetupZombieValue == ZombieSetupBuyCode)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                            }
                                            else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieBoostedFlip)
                                            {
                                                bool buyZombieBoostedSetup = (autoPilotSetupZombieBuySetup2 && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                    || (autoPilotSetupZombieBuySetup3 && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                    || (autoPilotSetupZombieBuySetup4 && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                    || (autoPilotSetupZombieBuySetup5 && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                    || (autoPilotSetupZombieBuySetup6 && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                    || (autoPilotSetupZombieBuySetup7 && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                    || (autoPilotSetupZombieBuySetup8 && autoPilotSetupZombieBuyContinuation7 && !previous7CandleBullish && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish)
                                                    || (autoPilotSetupZombieBuySetup9 && autoPilotSetupZombieBuyContinuation8 && !previous8CandleBullish && autoPilotSetupZombieBuyContinuation7 && !previous7CandleBullish && autoPilotSetupZombieBuyContinuation6 && !previous6CandleBullish && autoPilotSetupZombieBuyContinuation5 && !previous5CandleBullish && autoPilotSetupZombieBuyContinuation4 && !previous4CandleBullish && autoPilotSetupZombieBuyContinuation3 && !previous3CandleBullish && autoPilotSetupZombieBuyContinuation2 && !previous2CandleBullish && autoPilotSetupZombieBuyContinuation1 && previous1CandleBullish);


                                                bool sellZombieBoostedSetup = (autoPilotSetupZombieSellSetup2 && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                    || (autoPilotSetupZombieSellSetup3 && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                    || (autoPilotSetupZombieSellSetup4 && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                    || (autoPilotSetupZombieSellSetup5 && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                    || (autoPilotSetupZombieSellSetup6 && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                    || (autoPilotSetupZombieSellSetup7 && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                    || (autoPilotSetupZombieSellSetup8 && autoPilotSetupZombieSellContinuation7 && previous7CandleBullish && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish)
                                                    || (autoPilotSetupZombieSellSetup9 && autoPilotSetupZombieSellContinuation8 && previous8CandleBullish && autoPilotSetupZombieSellContinuation7 && previous7CandleBullish && autoPilotSetupZombieSellContinuation6 && previous6CandleBullish && autoPilotSetupZombieSellContinuation5 && previous5CandleBullish && autoPilotSetupZombieSellContinuation4 && previous4CandleBullish && autoPilotSetupZombieSellContinuation3 && previous3CandleBullish && autoPilotSetupZombieSellContinuation2 && previous2CandleBullish && autoPilotSetupZombieSellContinuation1 && !previous1CandleBullish);

                                                if (hasBuyPendingOrder)
                                                {
                                                    if (sellZombieBoostedSetup)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                                else
                                                {
                                                    if (buyZombieBoostedSetup)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                            }
                                            else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.KLineDualFlip)
                                            {
                                                if (hasBuyPendingOrder)
                                                {
                                                    double lowestKLinePrice = Math.Min(GetKineticLine1Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks));
                                                    bool sellKLineDualSetup = lowestKLinePrice > previous1ClosePrice;

                                                    if (sellKLineDualSetup)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                                else
                                                {
                                                    double highestKLinePrice = Math.Max(GetKineticLine1Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks));
                                                    bool buyKLineDualSetup = highestKLinePrice < previous1ClosePrice;

                                                    if (buyKLineDualSetup)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                            }
                                            else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.CreeperFlip)
                                            {
                                                bool risingAvgLine = autoPilotSetupCreeperValue >= autoPilotSetupCreeperValue2;

                                                if (hasBuyPendingOrder)
                                                {
                                                    if (!risingAvgLine)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                                else
                                                {
                                                    if (risingAvgLine)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                            }
                                            else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZLineDualFlip)
                                            {
                                                if (hasBuyPendingOrder)
                                                {
                                                    double lowestZipLinePrice = Math.Min(GetZipLine1Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks));
                                                    bool sellZipLineDualSetup = lowestZipLinePrice > previous1ClosePrice;

                                                    if (sellZipLineDualSetup)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                                else
                                                {
                                                    double highestZipLinePrice = Math.Max(GetZipLine1Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks));
                                                    bool buyZipLineDualSetup = highestZipLinePrice < previous1ClosePrice;

                                                    if (buyZipLineDualSetup)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                            }
                                            else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.KZFlip)
                                            {
                                                if (hasBuyPendingOrder)
                                                {
                                                    double lowestZipLinePrice = Math.Min(GetZipLine1Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks));
                                                    bool sellZipLineDualSetup = lowestZipLinePrice > previous1ClosePrice;

                                                    double lowestKLinePrice = Math.Min(GetKineticLine1Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(MarketPosition.Long, AutoCloseAndTrailOffsetTicks));
                                                    bool sellKLineDualSetup = lowestKLinePrice > previous1ClosePrice;

                                                    if (sellZipLineDualSetup && sellKLineDualSetup)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                                else
                                                {
                                                    double highestZipLinePrice = Math.Max(GetZipLine1Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks), GetZipLine2Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks));
                                                    bool buyZipLineDualSetup = highestZipLinePrice < previous1ClosePrice;

                                                    double highestKLinePrice = Math.Max(GetKineticLine1Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks), GetKineticLine2Price(MarketPosition.Short, AutoCloseAndTrailOffsetTicks));
                                                    bool buyKLineDualSetup = highestKLinePrice < previous1ClosePrice;

                                                    if (buyZipLineDualSetup && buyKLineDualSetup)
                                                    {
                                                        closePendingOrderFlag = true;
                                                    }
                                                }
                                            }

                                            if (closePendingOrderFlag)
                                            {
                                                CancelPopDropOrders(currentCloseAutoStatus.ToString());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception calling AttemptToClosePositionsInProfit:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                    throw;
                }
                finally
                {
                    if (lockTaken)
                    {
                        Monitor.Exit(ClosePositionsInProfitLock);
                    }
                }
            }

        }

        private void ExitCloseAlertWindows()
        {
            if (ChartControl != null && closeAutoAlertFlag)
            {
                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                {
                    CloseMessageBox(CloseAlertMessageTitle);
                    CloseAltMessageBox(CloseAlertAltMessageTitle);
                }));
            }
        }

        private void ExitTradeAlertWindows()
        {
            if (ChartControl != null && currentAutoPilotLiteStatus == TickHunterAutoPilotLiteTypes.AlertSetup)
            {
                ChartControl.Dispatcher.InvokeAsync(new Action(() =>
                {
                    CloseMessageBox(BuyZombieAlertMessageTitle);
                    CloseAltMessageBox(BuyZombieAlertAltMessageTitle);
                    CloseMessageBox(SellZombieAlertMessageTitle);
                    CloseAltMessageBox(SellZombieAlertAltMessageTitle);
                    CloseMessageBox(BuyCreeperAlertMessageTitle);
                    CloseAltMessageBox(BuyCreeperAlertAltMessageTitle);
                    CloseMessageBox(SellCreeperAlertMessageTitle);
                    CloseAltMessageBox(SellCreeperAlertAltMessageTitle);
                    CloseMessageBox(BuySliderAlertMessageTitle);
                    CloseMessageBox(SellSliderAlertMessageTitle);
                }));
            }
        }

        private void AttemptToClosePositionsInLoss()
        {
            string signalName = "AttemptToClosePositionsInLoss";

            if (IsMaxDDStopLossEnabled() || IsDayOverAccountBalanceFloorEnabled() || IsDayOverMaxLossEnabled())
            {
                var lockTimeout = TimeSpan.FromMilliseconds(250);
                bool lockTaken = false;

                try
                {
                    Monitor.TryEnter(ClosePositionsInLossLock, lockTimeout, ref lockTaken);

                    if (lockTaken)
                    {
                        if (!IsAccountFlat(attachedInstrument)
                            && RealOrderService.AreAllOrderUpdateCyclesComplete())
                        {
                            int totalVolume = 0;
                            int totalMicroVolume = 0;
                            int totalEminiVolume = 0;
                            double totalUnrealizedProfitLoss = 0;
                            double unrealizedProfitLoss = 0;
                            int positionQuantity = 0;
                            double oldStopLossPrice = 0;
                            OrderType stopLossOrderType = OrderType.Unknown;
                            int oldStopLossOrderQuantity = 0;
                            int stopLossOrderCount = 0;
                            bool hasStopLoss = false;

                            int positionCount = RealPositionService.PositionCount;

                            for (int index = 0; index < positionCount; index++)
                            {
                                RealPosition position = null;
                                if (RealPositionService.TryGetByIndex(index, out position))
                                {
                                    oldStopLossPrice = 0;
                                    stopLossOrderType = OrderType.Unknown;
                                    oldStopLossOrderQuantity = 0;
                                    stopLossOrderCount = 0;
                                    hasStopLoss = false;

                                    positionQuantity = position.Quantity;
                                    totalVolume += positionQuantity;
                                    if (IsMicroInstrument(position.Instrument)) totalMicroVolume += positionQuantity;
                                    else if (IsEminiInstrument(position.Instrument)) totalEminiVolume += positionQuantity;
                                    unrealizedProfitLoss = GetPositionProfit(position);
                                    totalUnrealizedProfitLoss += Math.Round(unrealizedProfitLoss, 2);

                                    oldStopLossPrice = RealOrderService.GetStopLossInfo(position.Account, position.Instrument, ConvertMarketPositionToSLOrderAction(position.MarketPosition), out stopLossOrderType, out oldStopLossOrderQuantity, out stopLossOrderCount);
                                    hasStopLoss = (oldStopLossPrice > 0);
                                }
                            }

                            if (totalVolume > 0 && totalUnrealizedProfitLoss < 0)
                            {
                                //if (UseDebugLogging) RealLogger.PrintOutput("Max DD: $" + totalUnrealizedProfitLoss.ToString("N2") + " vs DD $" + maxDDInDollars.ToString("N2") + " with " + Convert.ToString(totalVolume) + " volume", PrintTo.OutputTab1, true);
                                double netLiquidationBalance = Math.Round(account.Get(AccountItem.NetLiquidation, Currency.UsDollar), 2);

                                if (IsMaxDDStopLossEnabled() && totalUnrealizedProfitLoss <= maxDDInDollars)
                                {
                                    DeactivateAutoEntryFeatures(signalName);

                                    RealLogger.PrintOutput("Max DD reached: $" + totalUnrealizedProfitLoss.ToString("N2") + " ($" + maxDDInDollars.ToString("N2") + ") with " + Convert.ToString(totalVolume) + " volume", PrintTo.OutputTab1, false);

                                    FlattenEverything("MaxDDStopLoss", true, null);
                                }
                                else if (IsDayOverAccountBalanceFloorEnabled() && netLiquidationBalance <= DayOverAccountBalanceFloorDollars)
                                {
                                    DeactivateAutoEntryFeatures(signalName);

                                    RealLogger.PrintOutput("Day over account balance floor reached: $" + DayOverAccountBalanceFloorDollars.ToString("N2") + "/ $" + netLiquidationBalance.ToString("N2"), PrintTo.OutputTab1, false);

                                    FlattenEverything("DayOverAccountBalanceFloorDollars", true, null);
                                }
                                else if (IsDayOverMaxLossEnabled() && (activeDayOverMaxLossAutoClose || (!hasStopLoss && (lastDayOverMaxLossDollars > 0 && unrealizedProfitLoss < 0 && (unrealizedProfitLoss * -1) >= lastDayOverMaxLossDollars)))) // ||
                                {
                                    string formattedDailyMaxLossDollars = "";
                                    if (lastDayOverMaxLossDollars > 0)
                                    {
                                        formattedDailyMaxLossDollars = "$" + lastDayOverMaxLossDollars.ToString("N0");
                                    }
                                    else
                                    {
                                        formattedDailyMaxLossDollars = "($" + lastDayOverMaxLossDollars.ToString("N0") + ")";
                                    }

                                    DeactivateAutoEntryFeatures(signalName);

                                    RealLogger.PrintOutput("Day over max loss reached: $" + dayOverMaxLossDollars.ToString("N0") + " / " + formattedDailyMaxLossDollars, PrintTo.OutputTab1, false);

                                    FlattenEverything("DayOverMaxLoss", true, null);
                                    activeDayOverMaxLossAutoClose = false;
                                }
                                else if (IsExcessIntradayMarginMinDollarsEnabled() && lastAccountIntradayExcessMargin != 0 && lastAccountIntradayExcessMargin < ExcessIntradayMarginMinDollars)
                                {
                                    RealLogger.PrintOutput("Excess intraday margin min dollars reached: $" + lastAccountIntradayExcessMargin.ToString("N0")
                                        + " ($" + ExcessIntradayMarginMinDollars.ToString("N0") + ")");

                                    FlattenEverything("ExcessIntradayMarginMinDollars", true, null);
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception calling AttemptToClosePositionsInLoss:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                    throw;
                }
                finally
                {
                    if (lockTaken)
                    {
                        Monitor.Exit(ClosePositionsInLossLock);
                    }
                }
            }

        }

        private void CreateSellStop(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.SellShort)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            OrderType orderType = OrderType.StopMarket;

            lock (account.Orders)
            {
                string orderName = RealOrderService.BuildEntryOrderName();


                try
                {
                    Order entryOrder = account.CreateOrder(instrument, orderAction, orderType, orderEntry, TimeInForce.Day, quantity, 0, price, "", orderName, Core.Globals.MaxDate, null);

                    if (HasATMStrategy()) NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategyName, entryOrder);

                    if (orderAction == OrderAction.Buy || orderAction == OrderAction.BuyToCover)
                    {
                        double askPrice = RealInstrumentService.GetAskPrice(instrument);

                        RealLogger.PrintOutput("Opening stop order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + askPrice + " with volume (" + quantity + ")  via " + signalName);
                    }
                    else
                    {
                        double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                        RealLogger.PrintOutput("Opening stop order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + bidPrice + " with volume (" + quantity + ")  via " + signalName);

                    }
                    account.Submit(new[] { entryOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CreateSellStop:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }
            }
        }

        private void CreateBuyStop(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.SellShort)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            OrderType orderType = OrderType.StopMarket;

            lock (account.Orders)
            {
                string orderName = RealOrderService.BuildEntryOrderName();

                try
                {
                    Order entryOrder = account.CreateOrder(instrument, orderAction, orderType, orderEntry, TimeInForce.Day, quantity, 0, price, "", orderName, Core.Globals.MaxDate, null);

                    if (HasATMStrategy()) NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategyName, entryOrder);


                    if (orderAction == OrderAction.Buy || orderAction == OrderAction.BuyToCover)
                    {
                        double askPrice = RealInstrumentService.GetAskPrice(instrument);

                        RealLogger.PrintOutput("Opening stop order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + askPrice + " with volume (" + quantity + ")  via " + signalName);
                    }
                    else
                    {
                        double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                        RealLogger.PrintOutput("Opening stop order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + bidPrice + " with volume (" + quantity + ")  via " + signalName);
                    }


                    account.Submit(new[] { entryOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CreateBuyStop:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }
            }
        }

        private void CreateSellLimit(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.Buy && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            OrderType orderType = OrderType.Limit;

            lock (account.Orders)
            {
                string orderName = RealOrderService.BuildEntryOrderName();

                try
                {
                    Order entryOrder = account.CreateOrder(instrument, orderAction, orderType, orderEntry, TimeInForce.Day, quantity, price, 0, "", orderName, Core.Globals.MaxDate, null);

                    if (HasATMStrategy()) NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategyName, entryOrder);

                    if (orderAction == OrderAction.Buy || orderAction == OrderAction.BuyToCover)
                    {
                        double askPrice = RealInstrumentService.GetAskPrice(instrument);

                        RealLogger.PrintOutput("Opening limit order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + askPrice + " with volume (" + quantity + ")  via " + signalName);
                    }
                    else
                    {
                        double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                        RealLogger.PrintOutput("Opening limit order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + bidPrice + " with volume (" + quantity + ")  via " + signalName);
                    }

                    account.Submit(new[] { entryOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CreateSellLimit:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }
            }
        }

        private void CreateBuyLimit(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.Buy && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            OrderType orderType = OrderType.Limit;

            lock (account.Orders)
            {
                string orderName = RealOrderService.BuildEntryOrderName();

                try
                {
                    Order entryOrder = account.CreateOrder(instrument, orderAction, orderType, orderEntry, TimeInForce.Day, quantity, price, 0, "", orderName, Core.Globals.MaxDate, null);

                    if (HasATMStrategy()) NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategyName, entryOrder);

                    if (orderAction == OrderAction.Buy || orderAction == OrderAction.BuyToCover)
                    {
                        double askPrice = RealInstrumentService.GetAskPrice(instrument);

                        RealLogger.PrintOutput("Opening limit order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + askPrice + " with volume (" + quantity + ")  via " + signalName);
                    }
                    else
                    {
                        double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                        RealLogger.PrintOutput("Opening limit order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + bidPrice + " with volume (" + quantity + ")  via " + signalName);
                    }

                    account.Submit(new[] { entryOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CreateBuyLimit:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }
            }
        }

        private void UpdateStopOrder(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.SellShort)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported in UpdateStopOrder.");
                return;
            }

            double lastPrice = RealInstrumentService.GetLastPrice(instrument);


            if (orderAction == OrderAction.BuyToCover && price <= lastPrice)
            {
                RealLogger.PrintOutput("ERROR: Stop order price must be greater than last price.");
                return;
            }
            else if (orderAction == OrderAction.SellShort && price >= lastPrice)
            {
                RealLogger.PrintOutput("ERROR: Stop order price must be less than last price.");
                return;
            }

            bool orderChanged = false;
            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidBuyStopOrder(order, instrument, OrderAction.BuyToCover) || RealOrderService.IsValidSellStopOrder(order, instrument, OrderAction.SellShort))
                    {
                        orderChanged = false;
                        Order foundNTOrder = GetNinjaTraderOrder(order);

                        if (foundNTOrder != null)
                        {

                            if (foundNTOrder.StopPrice != price)
                            {
                                foundNTOrder.StopPriceChanged = price;
                                orderChanged = true;
                            }

                            if (orderChanged)
                            {
                                try
                                {
                                    account.Change(new[] { foundNTOrder });
                                }
                                catch (Exception ex)
                                {
                                    RealLogger.PrintOutput("Exception in UpdateStopOrder:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                }
                            }
                        }
                    }
                }
            }

        }

        private void UpdateLimitOrder(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, double price)
        {
            if (orderAction != OrderAction.Buy && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported in UpdateLimitOrder.");
                return;
            }

            double lastPrice = RealInstrumentService.GetLastPrice(instrument);


            if (orderAction == OrderAction.Buy && price >= lastPrice)
            {
                RealLogger.PrintOutput("ERROR: Limit order price must be less than last price.");
                return;
            }
            else if (orderAction == OrderAction.Sell && price <= lastPrice)
            {
                RealLogger.PrintOutput("ERROR: Limit order price must be greater than last price.");
                return;
            }

            bool orderChanged = false;
            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidBuyLimitOrder(order, instrument, OrderAction.Buy) || RealOrderService.IsValidSellLimitOrder(order, instrument, OrderAction.Sell))
                    {
                        orderChanged = false;
                        Order foundNTOrder = GetNinjaTraderOrder(order);

                        if (foundNTOrder != null)
                        {
                            if (foundNTOrder.LimitPrice != price)
                            {
                                foundNTOrder.LimitPriceChanged = price;
                                orderChanged = true;
                            }

                            if (orderChanged)
                            {
                                try
                                {
                                    account.Change(new[] { foundNTOrder });
                                }
                                catch (Exception ex)
                                {
                                    RealLogger.PrintOutput("Exception in UpdateLimitOrder:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                }
                            }
                        }
                    }
                }
            }

        }

        private void CreatePositionStopLoss(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            double lastPrice = RealInstrumentService.GetLastPrice(instrument);
            bool isValid = RealOrderService.IsValidStopLossPrice(instrument, orderAction, price, lastPrice);
            if (orderAction == OrderAction.BuyToCover && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Stop Loss order price must be greater than last price.");
                return;
            }
            else if (orderAction == OrderAction.Sell && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Stop Loss order price must be less than last price.");
                return;
            }

            OrderType orderType = OrderType.StopMarket;

            lock (account.Orders)
            {
                string orderName = RealOrderService.BuildStopOrderName();

                try
                {
                    Order stopOrder = account.CreateOrder(instrument, orderAction, orderType, orderEntry, TimeInForce.Gtc, quantity, 0, price, "", orderName, Core.Globals.MaxDate, null);

                    account.Submit(new[] { stopOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CreatePositionStopLoss:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }
            }
        }

        private void UpdatePositionStopLoss(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            double lastPrice = RealInstrumentService.GetLastPrice(instrument);
            bool isValid = RealOrderService.IsValidStopLossPrice(instrument, orderAction, price, lastPrice);
            if (orderAction == OrderAction.BuyToCover && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Stop Loss order price must be greater than last price.");
                return;
            }
            else if (orderAction == OrderAction.Sell && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Stop Loss order price must be less than last price.");
                return;
            }


            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidStopLossOrder(order, instrument, orderAction))
                    {
                        bool orderChanged = false;
                        Order foundNTOrder = GetNinjaTraderOrder(order);

                        if (foundNTOrder != null)
                        {
                            if (foundNTOrder.Quantity != quantity && quantity != 0)
                            {
                                foundNTOrder.QuantityChanged = quantity;
                                orderChanged = true;
                            }
                            if (foundNTOrder.StopPrice != price)
                            {
                                foundNTOrder.StopPriceChanged = price;
                                orderChanged = true;
                            }

                            if (orderChanged)
                            {
                                try
                                {
                                    account.Change(new[] { foundNTOrder });
                                }
                                catch (Exception ex)
                                {
                                    RealLogger.PrintOutput("Exception in UpdatePositionStopLoss:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                }

                            }
                            if (quantity != 0) break; //only change one if also setting quantity
                        }
                    }
                }
            }

        }

        private void CreatePositionTakeProfit(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            double lastPrice = RealInstrumentService.GetLastPrice(instrument);
            bool isValid = RealOrderService.IsValidTakeProfitPrice(instrument, orderAction, price, lastPrice);
            if (orderAction == OrderAction.BuyToCover && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Take Profit order price must be less than last price.");
                return;
            }
            else if (orderAction == OrderAction.Sell && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Take Profit order price must be greater than last price.");
                return;
            }

            OrderType orderType = OrderType.Limit;

            lock (account.Orders)
            {
                string orderName = RealOrderService.BuildTargetOrderName();

                try
                {
                    Order targetOrder = account.CreateOrder(instrument, orderAction, orderType, orderEntry, TimeInForce.Gtc, quantity, price, 0, "", orderName, Core.Globals.MaxDate, null);

                    account.Submit(new[] { targetOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in CreatePositionTakeProfit:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }

            }
        }

        private bool ConsolidatePositionTPSLOrders(string signalName, Instrument instrument)
        {
            bool returnFlag = false;

            bool closeAll = false;

            int buyOrderCount = 0;
            int sellOrderCount = 0;

            bool hasSkippedFirst = false;
            OrderType stopLossOrderType = OrderType.StopMarket;
            OrderType takeProfitOrderType = OrderType.Limit;

            List<Order> cancelOrderList = new List<Order>();

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;
                bool isFirstStopLossOrder = false;
                bool isFirstTakeProfitOrder = false;
                Order firstStopLossOrder = null;
                Order firstTakeProfitOrder = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidStopLossOrder(order, instrument, OrderAction.BuyToCover) || RealOrderService.IsValidStopLossOrder(order, instrument, OrderAction.Sell)
                       || RealOrderService.IsValidTakeProfitOrder(order, instrument, OrderAction.BuyToCover) || RealOrderService.IsValidTakeProfitOrder(order, instrument, OrderAction.Sell))
                    {
                        if (order.OrderType == stopLossOrderType && (order.OrderState == OrderState.Accepted || order.OrderState == OrderState.Working))
                        {
                            if (!isFirstStopLossOrder)
                            {
                                isFirstStopLossOrder = true;
                                Order foundNTOrder = GetNinjaTraderOrder(order);
                                firstStopLossOrder = foundNTOrder;
                            }
                            else
                            {
                                Order foundNTOrder = GetNinjaTraderOrder(order);
                                cancelOrderList.Add(foundNTOrder);
                            }
                        }
                        else if (order.OrderType == takeProfitOrderType && order.OrderState == OrderState.Working)
                        {
                            if (!isFirstTakeProfitOrder)
                            {
                                isFirstTakeProfitOrder = true;
                                Order foundNTOrder = GetNinjaTraderOrder(order);
                                firstTakeProfitOrder = foundNTOrder;
                            }
                            else
                            {
                                Order foundNTOrder = GetNinjaTraderOrder(order);
                                cancelOrderList.Add(foundNTOrder);
                            }
                        }
                    }
                }

                int stopLossQuantity = 0;
                int takeProfitQuantity = 0;

                if (firstStopLossOrder != null)
                {
                    stopLossQuantity = firstStopLossOrder.Quantity;
                }

                if (firstTakeProfitOrder != null)
                {
                    takeProfitQuantity = firstTakeProfitOrder.Quantity;
                }

                foreach (Order cancelOrder in cancelOrderList)
                {
                    bool increamentStopLossQuantity = false;
                    bool increamentTakeProfitQuantity = false;
                    int initialStopLossQuantity = 0;
                    int initialTakeProfitQuantity = 0;
                    int cancelOrderQuantity = 0;

                    try
                    {
                        increamentStopLossQuantity = (cancelOrder.OrderType == stopLossOrderType && firstStopLossOrder != null);
                        increamentTakeProfitQuantity = (cancelOrder.OrderType == takeProfitOrderType && firstTakeProfitOrder != null);
                        cancelOrderQuantity = cancelOrder.Quantity;

                        account.Cancel(new[] { cancelOrder });

                        if (increamentStopLossQuantity)
                        {
                            stopLossQuantity += cancelOrderQuantity;

                            firstStopLossOrder.QuantityChanged = stopLossQuantity;

                            account.Change(new[] { firstStopLossOrder });

                            firstStopLossOrder.Quantity = stopLossQuantity;
                        }
                        else if (increamentTakeProfitQuantity)
                        {
                            takeProfitQuantity += cancelOrderQuantity;

                            firstTakeProfitOrder.QuantityChanged = takeProfitQuantity;

                            account.Change(new[] { firstTakeProfitOrder });

                            firstTakeProfitOrder.Quantity = takeProfitQuantity;
                        }

                        returnFlag = true;
                    }
                    catch (Exception ex)
                    {
                        RealLogger.PrintOutput("Exception in ConsolidatePositionTPSLOrders:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                    }
                }
            }

            return returnFlag;
        }

        private bool CancelPositionTPSLOrders(string signalName, Instrument instrument, OrderAction? orderAction = null)
        {
            bool returnFlag = false;
            bool closeAll = false;
            OrderAction tempOrderAction = OrderAction.BuyToCover;

            if (orderAction == null)
                closeAll = true;
            else if (orderAction == OrderAction.BuyToCover)
                tempOrderAction = OrderAction.BuyToCover;
            else if (orderAction == OrderAction.Sell)
                tempOrderAction = OrderAction.Sell;
            else
            {
                RealLogger.PrintOutput("Order action type not supported: " + Convert.ToString(orderAction));
            }

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (closeAll && (RealOrderService.IsValidStopLossOrder(order, instrument, OrderAction.BuyToCover) || RealOrderService.IsValidStopLossOrder(order, instrument, OrderAction.Sell)
                        || RealOrderService.IsValidTakeProfitOrder(order, instrument, OrderAction.BuyToCover) || RealOrderService.IsValidTakeProfitOrder(order, instrument, OrderAction.Sell))
                        || (!closeAll && (RealOrderService.IsValidStopLossOrder(order, instrument, tempOrderAction) || RealOrderService.IsValidTakeProfitOrder(order, instrument, tempOrderAction))))
                    {
                        Order foundNTOrder = GetNinjaTraderOrder(order);

                        if (foundNTOrder != null)
                        {
                            try
                            {

                                account.Cancel(new[] { foundNTOrder });
                                returnFlag = true;
                            }
                            catch (Exception ex)
                            {
                                RealLogger.PrintOutput("Exception in CancelPositionTPSLOrders:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                            }
                        }
                    }
                }
            }

            return returnFlag;
        }

        private bool CancelPositionTPOrders(string signalName, Instrument instrument, OrderAction? orderAction = null)
        {
            bool returnFlag = false;
            bool closeAll = false;
            OrderAction tempOrderAction = OrderAction.BuyToCover;

            if (orderAction == null)
                closeAll = true;
            else if (orderAction == OrderAction.BuyToCover)
                tempOrderAction = OrderAction.BuyToCover;
            else if (orderAction == OrderAction.Sell)
                tempOrderAction = OrderAction.Sell;
            else
            {
                RealLogger.PrintOutput("Order action type not supported: " + Convert.ToString(orderAction));
            }

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (closeAll
                        && (RealOrderService.IsValidTakeProfitOrder(order, instrument, OrderAction.BuyToCover)
                        || RealOrderService.IsValidTakeProfitOrder(order, instrument, OrderAction.Sell))
                        || (!closeAll && RealOrderService.IsValidTakeProfitOrder(order, instrument, tempOrderAction)))
                    {
                        Order foundNTOrder = GetNinjaTraderOrder(order);

                        if (foundNTOrder != null)
                        {
                            try
                            {

                                account.Cancel(new[] { foundNTOrder });
                                returnFlag = true;
                            }
                            catch (Exception ex)
                            {
                                RealLogger.PrintOutput("Exception in CancelPositionTPSLOrders:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                            }
                        }
                    }
                }
            }

            return returnFlag;
        }

        private void UpdatePositionTakeProfit(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, double price)
        {
            if (orderAction != OrderAction.BuyToCover && orderAction != OrderAction.Sell)
            {
                RealLogger.PrintOutput("ERROR: Order action of " + orderAction.ToString() + " not supported.");
                return;
            }

            double lastPrice = RealInstrumentService.GetLastPrice(instrument);
            bool isValid = RealOrderService.IsValidTakeProfitPrice(instrument, orderAction, price, lastPrice);
            if (orderAction == OrderAction.BuyToCover && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Take Profit order price must be less than last price.");
                return;
            }
            else if (orderAction == OrderAction.Sell && !isValid)
            {
                RealLogger.PrintOutput("ERROR: Take Profit order price must be greater than last price.");
                return;
            }

            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidTakeProfitOrder(order, instrument, orderAction))
                    {
                        bool orderChanged = false;
                        Order foundNTOrder = GetNinjaTraderOrder(order);

                        if (foundNTOrder != null)
                        {
                            if (foundNTOrder.Quantity != quantity && quantity != 0)
                            {
                                foundNTOrder.QuantityChanged = quantity;
                                orderChanged = true;
                            }
                            if (foundNTOrder.LimitPrice != price)
                            {
                                foundNTOrder.LimitPriceChanged = price;
                                orderChanged = true;
                            }

                            if (orderChanged)
                            {
                                try
                                {
                                    account.Change(new[] { foundNTOrder });
                                }
                                catch (Exception ex)
                                {
                                    RealLogger.PrintOutput("Exception in UpdatePositionTakeProfit:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                }
                            }
                            if (quantity != 0) break; //only change one if also setting quantity
                        }
                    }
                }
            }
        }

        private bool FlattenEverything(string signalName, bool continueTillZeroRemainingQuantity, Instrument limitToSingleInstrument, Instrument secondaryInstrument = null)
        {
            bool positionFound = false;

            var lockTimeout = TimeSpan.FromMilliseconds(250);
            bool lockTaken = false;

            try
            {
                Monitor.TryEnter(FlattenEverythingLock, lockTimeout, ref lockTaken);

                if (lockTaken)
                {
                    if (RealOrderService.AreAllOrderUpdateCyclesComplete())
                    {
                        bool isNextFlattenEverythingCycleReady = lastFlattenEverythingCycleChangeTime <= GetDateTimeNow();

                        if (isNextFlattenEverythingCycleReady)
                        {
                            lastFlattenEverythingCycleChangeTime = (GetDateTimeNow()).AddSeconds(FlattenEverythingThrottleSeconds + 5);

                            CloseAllAccountPendingOrders(signalName, limitToSingleInstrument);
                            if (secondaryInstrument != null) CloseAllAccountPendingOrders(signalName, secondaryInstrument);

                            if (!IsAccountFlat())
                            {
                                double unrealizedProfitLoss = 0;
                                OrderAction orderAction = OrderAction.Buy;
                                int positionCount = RealPositionService.PositionCount;

                                for (int index = 0; index < positionCount; index++)
                                {
                                    RealPosition position = null;
                                    if (RealPositionService.TryGetByIndex(index, out position))
                                    {
                                        if (limitToSingleInstrument == null || position.Instrument == limitToSingleInstrument || position.Instrument == secondaryInstrument)
                                        {
                                            position.StoreState();
                                            positionFound = true;

                                            unrealizedProfitLoss = GetPositionProfit(position);

                                            if (position.MarketPosition == MarketPosition.Long)
                                                orderAction = OrderAction.Sell;
                                            else if (position.MarketPosition == MarketPosition.Short)
                                                orderAction = OrderAction.Buy;

                                            if (position.Quantity > 0 && !position.HasStateChanged() && !position.IsFlat())
                                            {
                                                RealLogger.PrintOutput(signalName + " closing " + position.MarketPosition.ToString() + " " + position.Instrument.FullName + " Quantity=" + position.Quantity + " PnL=" + Convert.ToString(unrealizedProfitLoss) + " via " + signalName, PrintTo.OutputTab1);

                                                SubmitMarketOrderChunked(signalName, position.Instrument, orderAction, OrderEntry.Manual, position.Quantity, continueTillZeroRemainingQuantity);
                                            }

                                            if (!continueTillZeroRemainingQuantity) break;
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            RealLogger.PrintOutput("FlattenEverything skipped via " + signalName, PrintTo.OutputTab1);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception calling FlattenEverything:" + ex.Message + " " + ex.StackTrace + " via " + signalName);
                throw;
            }
            finally
            {
                if (lockTaken)
                {
                    Monitor.Exit(FlattenEverythingLock);
                }
            }

            return positionFound;
        }

        private bool IsMaxDDStopLossEnabled()
        {
            bool returnFlag = false;

            if (maxDDInDollars < 0)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsDayOverAccountBalanceFloorEnabled()
        {
            bool returnFlag = false;

            if (DayOverAccountBalanceFloorDollars > 0)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsDayOverMaxLossEnabled()
        {
            bool returnFlag = false;

            if (dayOverMaxLossDollars > 0)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsHODLEnabled()
        {
            bool returnFlag = false;

            if (breakEvenAutoHODLFlag)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsBogeyTargetEnabled()
        {
            bool returnFlag = false;

            if (BogeyTargetBaseDollars > 0 && currentBogeyTargetMultiplier != BogeyTargetMultiplierDisabled
                && currentProfitTargetStatus == TickHunterProfitTargetTypes.BogeyTarget)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsAutoPositionTakeProfitEnabled()
        {
            bool returnFlag = false;

            if (UseAutoPositionTakeProfit && !IsHODLEnabled())
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsAutoPositionStopLossEnabled()
        {
            bool returnFlag = false;

            if (UseAutoPositionStopLoss)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsECATPEnabled()
        {
            bool returnFlag = false;

            if ((ECATargetDollars > 0 || ECATargetDollarsPerOtherVolume > 0) && currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget)
            {
                returnFlag = true;
            }

            return (returnFlag);
        }

        private bool IsExcessIntradayMarginMinDollarsEnabled()
        {
            bool returnFlag = false;

            if (ExcessIntradayMarginMinDollars > 0)
                returnFlag = true;

            return (returnFlag);
        }

        private int GetValidVolumeSize(int volumeSize)
        {
            int newVolumeSize = DEFAULT_VOLUME_SIZE;

            bool isPositiveVolumeSize = volumeSize > 0;

            if (isPositiveVolumeSize)
            {
                newVolumeSize = volumeSize;
            }
            else
            {
                RealLogger.PrintOutput("GetValidVolumeSize: Invalid volume size: " + volumeSize.ToString("N0"));
            }

            return newVolumeSize;
        }

        private int GetLimitedIncrementVolumeSize(int incrementVolumeSize, int maxInitialTrancheVolumeSize, bool limitTrancheVolumeToInProfit)
        {
            int newVolumeSize = DEFAULT_VOLUME_SIZE;

            int validatedIncrementVolumeSize = GetValidVolumeSize(incrementVolumeSize);

            if (limitTrancheVolumeToInProfit)
            {
                int validatedMaxInitialTrancheVolumeSize = GetValidVolumeSize(maxInitialTrancheVolumeSize);

                bool isIncrementVolumeSizeValidForBogey = limitTrancheVolumeToInProfit && validatedIncrementVolumeSize <= validatedMaxInitialTrancheVolumeSize;

                if (!limitTrancheVolumeToInProfit
                   || isIncrementVolumeSizeValidForBogey)
                {
                    newVolumeSize = validatedIncrementVolumeSize;
                }
                else if (validatedIncrementVolumeSize <= validatedMaxInitialTrancheVolumeSize)
                {
                    newVolumeSize = validatedIncrementVolumeSize;
                }
                else
                {
                    newVolumeSize = validatedMaxInitialTrancheVolumeSize;
                    //RealLogger.PrintOutput("GetValidVolumeSize: Invalid increment volume size: IncrementVolumeSize=" + incrementVolumeSize.ToString("N0") + " MaxInitialTrancheVolumeSize=" + maxInitialTrancheVolumeSize.ToString("N0"));
                }
            }
            else
            {
                newVolumeSize = validatedIncrementVolumeSize;
            }

            return newVolumeSize;
        }

        private bool TryGetLimitTrancheVolumeSize(int positionVolumeSize, bool positionInProfit, int incrementVolumeSize, int maxInitialTrancheVolumeSize, out int newVolumeSize)
        {
            bool addOnVolumeAllowed = false;
            newVolumeSize = DEFAULT_VOLUME_SIZE;

            if (LimitToVolumeMaxOption)
            {

                bool maxVolumeGroup1Enabled = EntryVolumeMaxOption1 > 0;
                bool maxVolumeGroup2Enabled = EntryVolumeMaxOption2 > 0;
                bool maxVolumeGroup3Enabled = EntryVolumeMaxOption3 > 0;
                bool maxVolumeGroup4Enabled = EntryVolumeMaxOption4 > 0;
                bool maxVolumeGroup5Enabled = EntryVolumeMaxOption5 > 0;

                if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option1)
                {
                    if (maxVolumeGroup1Enabled)
                    {
                        bool isPositionVolumeAlreadyAtMaxVolumeSize = positionVolumeSize >= EntryVolumeMaxOption1;

                        if (limitTrancheVolumeToInProfitFlag && positionInProfit && isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            newVolumeSize = incrementVolumeSize;
                            addOnVolumeAllowed = true;
                        }
                        else if (isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            addOnVolumeAllowed = false;
                        }
                        else
                        {
                            int remainingVolumeSize = EntryVolumeMaxOption1 - positionVolumeSize;

                            bool isRemainingVolumeSizeValid = remainingVolumeSize > 0;
                            bool isFullIncrementTooLarge = incrementVolumeSize > remainingVolumeSize;

                            if (isRemainingVolumeSizeValid && isFullIncrementTooLarge)
                            {
                                newVolumeSize = remainingVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                            else if (isRemainingVolumeSizeValid && !isFullIncrementTooLarge)
                            {
                                newVolumeSize = incrementVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                        }
                    }
                    else
                    {
                        newVolumeSize = incrementVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                }
                else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option2)
                {
                    if (maxVolumeGroup2Enabled)
                    {
                        bool isPositionVolumeAlreadyAtMaxVolumeSize = positionVolumeSize >= EntryVolumeMaxOption2;

                        if (limitTrancheVolumeToInProfitFlag && positionInProfit && isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            newVolumeSize = incrementVolumeSize;
                            addOnVolumeAllowed = true;
                        }
                        else if (isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            addOnVolumeAllowed = false;
                        }
                        else
                        {
                            int remainingVolumeSize = EntryVolumeMaxOption2 - positionVolumeSize;

                            bool isRemainingVolumeSizeValid = remainingVolumeSize > 0;
                            bool isFullIncrementTooLarge = incrementVolumeSize > remainingVolumeSize;

                            if (isRemainingVolumeSizeValid && isFullIncrementTooLarge)
                            {
                                newVolumeSize = remainingVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                            else if (isRemainingVolumeSizeValid && !isFullIncrementTooLarge)
                            {
                                newVolumeSize = incrementVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                        }
                    }
                    else
                    {
                        newVolumeSize = incrementVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                }
                else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option3)
                {
                    if (maxVolumeGroup3Enabled)
                    {
                        bool isPositionVolumeAlreadyAtMaxVolumeSize = positionVolumeSize >= EntryVolumeMaxOption3;

                        if (limitTrancheVolumeToInProfitFlag && positionInProfit && isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            newVolumeSize = incrementVolumeSize;
                            addOnVolumeAllowed = true;
                        }
                        else if (isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            addOnVolumeAllowed = false;
                        }
                        else
                        {
                            int remainingVolumeSize = EntryVolumeMaxOption3 - positionVolumeSize;

                            bool isRemainingVolumeSizeValid = remainingVolumeSize > 0;
                            bool isFullIncrementTooLarge = incrementVolumeSize > remainingVolumeSize;

                            if (isRemainingVolumeSizeValid && isFullIncrementTooLarge)
                            {
                                newVolumeSize = remainingVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                            else if (isRemainingVolumeSizeValid && !isFullIncrementTooLarge)
                            {
                                newVolumeSize = incrementVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                        }
                    }
                    else
                    {
                        newVolumeSize = incrementVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                }
                else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option4)
                {
                    if (maxVolumeGroup4Enabled)
                    {
                        bool isPositionVolumeAlreadyAtMaxVolumeSize = positionVolumeSize >= EntryVolumeMaxOption4;

                        if (limitTrancheVolumeToInProfitFlag && positionInProfit && isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            newVolumeSize = incrementVolumeSize;
                            addOnVolumeAllowed = true;
                        }
                        else if (isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            addOnVolumeAllowed = false;
                        }
                        else
                        {
                            int remainingVolumeSize = EntryVolumeMaxOption4 - positionVolumeSize;

                            bool isRemainingVolumeSizeValid = remainingVolumeSize > 0;
                            bool isFullIncrementTooLarge = incrementVolumeSize > remainingVolumeSize;

                            if (isRemainingVolumeSizeValid && isFullIncrementTooLarge)
                            {
                                newVolumeSize = remainingVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                            else if (isRemainingVolumeSizeValid && !isFullIncrementTooLarge)
                            {
                                newVolumeSize = incrementVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                        }
                    }
                    else
                    {
                        newVolumeSize = incrementVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                }
                else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option5)
                {
                    if (maxVolumeGroup5Enabled)
                    {
                        bool isPositionVolumeAlreadyAtMaxVolumeSize = positionVolumeSize >= EntryVolumeMaxOption5;

                        if (limitTrancheVolumeToInProfitFlag && positionInProfit && isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            newVolumeSize = incrementVolumeSize;
                            addOnVolumeAllowed = true;
                        }
                        else if (isPositionVolumeAlreadyAtMaxVolumeSize)
                        {
                            addOnVolumeAllowed = false;
                        }
                        else
                        {
                            int remainingVolumeSize = EntryVolumeMaxOption5 - positionVolumeSize;

                            bool isRemainingVolumeSizeValid = remainingVolumeSize > 0;
                            bool isFullIncrementTooLarge = incrementVolumeSize > remainingVolumeSize;

                            if (isRemainingVolumeSizeValid && isFullIncrementTooLarge)
                            {
                                newVolumeSize = remainingVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                            else if (isRemainingVolumeSizeValid && !isFullIncrementTooLarge)
                            {
                                newVolumeSize = incrementVolumeSize;
                                addOnVolumeAllowed = true;
                            }
                        }
                    }
                    else
                    {
                        newVolumeSize = incrementVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                }
            }
            else if (limitTrancheVolumeToInProfitFlag)
            {
                int limitedIncrementVolumeSize = GetLimitedIncrementVolumeSize(incrementVolumeSize, maxInitialTrancheVolumeSize, limitTrancheVolumeToInProfitFlag);
                bool isPositionVolumeAlreadyAtBogeyVolumeSize = positionVolumeSize >= maxInitialTrancheVolumeSize;

                if (positionInProfit && isPositionVolumeAlreadyAtBogeyVolumeSize)
                {
                    newVolumeSize = incrementVolumeSize;
                    addOnVolumeAllowed = true;
                }
                else
                {
                    int remainingVolumeSize = maxInitialTrancheVolumeSize - positionVolumeSize;

                    bool isRemainingVolumeSizeValid = remainingVolumeSize > 0;
                    bool isFullIncrementTooLarge = limitedIncrementVolumeSize > remainingVolumeSize;

                    if (isRemainingVolumeSizeValid && isFullIncrementTooLarge)
                    {
                        newVolumeSize = remainingVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                    else if (isRemainingVolumeSizeValid && !isFullIncrementTooLarge)
                    {
                        newVolumeSize = limitedIncrementVolumeSize;
                        addOnVolumeAllowed = true;
                    }
                }

            }

            return addOnVolumeAllowed;
        }

        private int GetRandomNumber(int maxValue)
        {
            int randomNumber = 0;

            if (maxValue == 1)
            {
                randomNumber = maxValue;
            }
            else if (maxValue > 0)
            {
                int minValue = (int)maxValue / 2; // half number to create range
                Random random = new Random();
                randomNumber = random.Next(minValue, maxValue + 1);
            }

            return randomNumber;
        }

        private void SubmitMarketOrder(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity)
        {
            lock (MarketOrderLock)
            {
                string orderName = RealOrderService.BuildEntryOrderName();

                try
                {
                    Order entryOrder = account.CreateOrder(instrument, orderAction, OrderType.Market, orderEntry, TimeInForce.Day, quantity, 0, 0, "", orderName, Core.Globals.MaxDate, null);

                    if (HasATMStrategy())
                    {
                        NinjaTrader.NinjaScript.AtmStrategy.StartAtmStrategy(atmStrategyName, entryOrder);
                    }

                    if (orderAction == OrderAction.Buy || orderAction == OrderAction.BuyToCover)
                    {
                        double askPrice = RealInstrumentService.GetAskPrice(instrument);

                        RealLogger.PrintOutput("Opening market order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + askPrice + " with volume (" + quantity + ")  via " + signalName);
                    }
                    else
                    {
                        double bidPrice = RealInstrumentService.GetBidPrice(instrument);

                        RealLogger.PrintOutput("Opening market order type " + orderAction.ToString() + " for " + instrument.FullName + " at price " + bidPrice + " with volume (" + quantity + ")  via " + signalName);
                    }

                    account.Submit(new[] { entryOrder });
                }
                catch (Exception ex)
                {
                    RealLogger.PrintOutput("Exception in SubmitMarketOrder:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                }
            }
        }

        private void SubmitMarketOrderChunked(string signalName, Instrument instrument, OrderAction orderAction, OrderEntry orderEntry, int quantity, bool continueTillZeroRemainingQuantity = true)
        {

            int quantityRemaining = quantity;
            int chunkedQuantity = 0;
            int cycleCount = 1;

            lock (MarketOrderLock)
            {
                if (quantityRemaining > 0)
                {
                    lock (MarketOrderLock)
                    {
                        while (quantityRemaining > 0)
                        {
                            if (quantityRemaining > this.SingleOrderChunkMaxQuantity)
                            {
                                int randomQuantity = GetRandomNumber(this.SingleOrderChunkMaxQuantity);
                                chunkedQuantity = randomQuantity;
                            }
                            else if (quantityRemaining > this.SingleOrderChunkMinQuantity)
                            {
                                int randomQuantity = GetRandomNumber(this.SingleOrderChunkMinQuantity);
                                chunkedQuantity = randomQuantity;
                            }
                            else
                            {
                                chunkedQuantity = quantityRemaining;
                            }

                            quantityRemaining -= chunkedQuantity;

                            if (cycleCount > 1 && SingleOrderChunkDelayMilliseconds > 0) Thread.Sleep(SingleOrderChunkDelayMilliseconds);

                            string orderName = RealOrderService.BuildExitOrderName();

                            try
                            {
                                Order exitOrder = account.CreateOrder(instrument, orderAction, OrderType.Market, orderEntry, TimeInForce.Day, chunkedQuantity, 0, 0, "", orderName, Core.Globals.MaxDate, null);

                                account.Submit(new[] { exitOrder });
                            }
                            catch (Exception ex)
                            {
                                RealLogger.PrintOutput("Exception in SubmitMarketOrder:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                            }

                            cycleCount++;

                            if (!continueTillZeroRemainingQuantity) break;
                        }
                    }
                }
            }
        }

        private int CalculateAutoEntryVolume(TickHunterEntryVolumeAutoTypes entryVolumeAutoType)
        {
            int entryVolume = AutoEntryVolumeOption1;

            if (entryVolumeAutoType == TickHunterEntryVolumeAutoTypes.Option2)
            {
                entryVolume = AutoEntryVolumeOption2;
            }
            else if (entryVolumeAutoType == TickHunterEntryVolumeAutoTypes.Option3)
            {
                entryVolume = AutoEntryVolumeOption3;
            }
            else if (entryVolumeAutoType == TickHunterEntryVolumeAutoTypes.Option4)
            {
                entryVolume = AutoEntryVolumeOption4;
            }
            else if (entryVolumeAutoType == TickHunterEntryVolumeAutoTypes.Option5)
            {
                entryVolume = AutoEntryVolumeOption5;
            }

            return entryVolume;
        }

        private void GenerateEntryVolumeAutoButtonText()
        {
            const string AutoEntryButtonPrefix = "V(";
            const string AutoEntryButtonSuffix = ")";
            const string AutoEntryButtonToolTipPrefix = "Volume (";

            ToggleAutoEntryVolOption1ButtonEnabledText = AutoEntryButtonPrefix + AutoEntryVolumeOption1 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption1ButtonEnabledToolTip = AutoEntryButtonToolTipPrefix + AutoEntryVolumeOption1 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption2ButtonEnabledText = AutoEntryButtonPrefix + AutoEntryVolumeOption2 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption2ButtonEnabledToolTip = AutoEntryButtonToolTipPrefix + AutoEntryVolumeOption2 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption3ButtonEnabledText = AutoEntryButtonPrefix + AutoEntryVolumeOption3 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption3ButtonEnabledToolTip = AutoEntryButtonToolTipPrefix + AutoEntryVolumeOption3 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption4ButtonEnabledText = AutoEntryButtonPrefix + AutoEntryVolumeOption4 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption4ButtonEnabledToolTip = AutoEntryButtonToolTipPrefix + AutoEntryVolumeOption4 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption5ButtonEnabledText = AutoEntryButtonPrefix + AutoEntryVolumeOption5 + AutoEntryButtonSuffix;
            ToggleAutoEntryVolOption5ButtonEnabledToolTip = AutoEntryButtonToolTipPrefix + AutoEntryVolumeOption5 + AutoEntryButtonSuffix;
        }

        private int CalculateEntryVolumeMax(TickHunterEntryVolumeMaxTypes entryVolumeMaxType)
        {
            int entryVolume = EntryVolumeMaxOption1;

            if (entryVolumeMaxType == TickHunterEntryVolumeMaxTypes.Option2)
            {
                entryVolume = EntryVolumeMaxOption2;
            }
            else if (entryVolumeMaxType == TickHunterEntryVolumeMaxTypes.Option3)
            {
                entryVolume = EntryVolumeMaxOption3;
            }
            else if (entryVolumeMaxType == TickHunterEntryVolumeMaxTypes.Option4)
            {
                entryVolume = EntryVolumeMaxOption4;
            }
            else if (entryVolumeMaxType == TickHunterEntryVolumeMaxTypes.Option5)
            {
                entryVolume = EntryVolumeMaxOption5;
            }

            return entryVolume;
        }

        private void GenerateEntryVolumeMaxButtonText()
        {
            const string EntryButtonPrefix = "VM(";
            const string EntryButtonSuffix = ")";
            const string EntryButtonToolTipPrefix = "Volume Max (";

            ToggleEntryVolMaxOption1ButtonEnabledText = EntryButtonPrefix + EntryVolumeMaxOption1 + EntryButtonSuffix;
            ToggleEntryVolMaxOption1ButtonEnabledToolTip = EntryButtonToolTipPrefix + EntryVolumeMaxOption1 + EntryButtonSuffix;
            ToggleEntryVolMaxOption2ButtonEnabledText = EntryButtonPrefix + EntryVolumeMaxOption2 + EntryButtonSuffix;
            ToggleEntryVolMaxOption2ButtonEnabledToolTip = EntryButtonToolTipPrefix + EntryVolumeMaxOption2 + EntryButtonSuffix;
            ToggleEntryVolMaxOption3ButtonEnabledText = EntryButtonPrefix + EntryVolumeMaxOption3 + EntryButtonSuffix;
            ToggleEntryVolMaxOption3ButtonEnabledToolTip = EntryButtonToolTipPrefix + EntryVolumeMaxOption3 + EntryButtonSuffix;
            ToggleEntryVolMaxOption4ButtonEnabledText = EntryButtonPrefix + EntryVolumeMaxOption4 + EntryButtonSuffix;
            ToggleEntryVolMaxOption4ButtonEnabledToolTip = EntryButtonToolTipPrefix + EntryVolumeMaxOption4 + EntryButtonSuffix;
            ToggleEntryVolMaxOption5ButtonEnabledText = EntryButtonPrefix + EntryVolumeMaxOption5 + EntryButtonSuffix;
            ToggleEntryVolMaxOption5ButtonEnabledToolTip = EntryButtonToolTipPrefix + EntryVolumeMaxOption5 + EntryButtonSuffix;
        }

        private void GetBogeyTargetTypeButtonText(int bogeyTargetMultiplier, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            if (bogeyTargetMultiplier > BogeyTargetMultiplierDisabled)
            {
                const string StarText = "*";
                const string ZeroPnLText = " (ZeroPnL)";

                string flagActiveText = "";
                string flagActiveTextToolTip = "";

                if (!bogeyTargetStartWithFullPnLFlag)
                {
                    flagActiveText = StarText;
                    flagActiveTextToolTip = ZeroPnLText;
                }

                buttonText = String.Format(ToggleProfitTargetX0ButtonEnabledText, bogeyTargetMultiplier, flagActiveText);
                buttonToolTipText = String.Format(ToggleProfitTargetX0ButtonEnabledToolTip, bogeyTargetMultiplier, flagActiveTextToolTip);
            }
            else
            {
                buttonText = ToggleProfitTargetButtonDisabledText;
                buttonToolTipText = ToggleProfitTargetButtonDisabledToolTip;
            }
        }

        private bool IsAccountFlat()
        {
            bool returnFlag = true;

            returnFlag = (RealPositionService.PositionCount == 0);

            return returnFlag;
        }

        private bool IsAccountFlat(Instrument instrument)
        {
            bool returnFlag = true;

            RealPosition position = new RealPosition();

            returnFlag = (!RealPositionService.TryGetByInstrumentFullName(instrument.FullName, out position));

            return returnFlag;
        }

        private void CloseAllAccountPendingOrders(string signalName, Instrument limitToSingleInstrument)
        {
            int orderCount = RealOrderService.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (RealOrderService.TryGetByIndex(index, out order))
                {
                    if (limitToSingleInstrument == null || order.Instrument == limitToSingleInstrument)
                    {
                        if (!Order.IsTerminalState(order.OrderState))
                        {
                            if (DebugLogLevel > 0) RealLogger.PrintOutput(signalName + " is cancelling pending order " + order.Instrument.FullName + " Type=" + order.OrderType.ToString() + " via " + signalName);
                            Order foundNTOrder = GetNinjaTraderOrder(order);

                            if (foundNTOrder != null)
                            {
                                try
                                {
                                    account.Cancel(new[] { foundNTOrder });
                                }
                                catch (Exception ex)
                                {
                                    RealLogger.PrintOutput("Exception in CloseAllAccountPendingOrders:" + ex.Message + " " + ex.StackTrace + " via " + signalName);  //log and ignore exception
                                }
                            }
                        }
                    }
                }
            }
        }

        protected override void OnRender(ChartControl chartControl, ChartScale chartScale)
        {
            try
            {
                base.OnRender(chartControl, chartScale);

                if (!hasDrawnButtons)
                {
                    if (IsStrategyAttachedToChart() && HasRanOnceFirstCycle())
                    {
                        DrawButtonPanel();
                        if (!IsTickHunterActivated())
                        {
                            string signalName = "OnRender";
                            DeactivateTickHunter(signalName);
                        }
                        else
                        {
                            SetButtonPanelVisiblity();
                        }

                        hasDrawnButtons = true;
                    }
                }
            }
            catch (Exception ex)
            {
                RealLogger.PrintOutput("Exception in OnRender:" + ex.Message + " " + ex.StackTrace);  //log and rethrow
                throw;
            }
        }

        private bool HasRanOnceFirstCycle()
        {
            string signalName = "HasRanOnceFirstCycle";

            if (!hasRanOnceFirstCycle && attachedInstrumentServerSupported && BarsInProgress == 0 && CurrentBar > 0) //&& BarsInProgress == 0 && this.State == State.Realtime)
            {
                lock (AccountLock)
                {
                    if (!hasRanOnceFirstCycle)
                    {
                        this.RealOrderService = new RealOrderService();
                        this.RealPositionService = new RealPositionService();

                        lastOrderOutputTime = DateTime.MinValue;

                        DeactivateAutoEntryFeatures(signalName);

                        if (ChartControl.Dispatcher.CheckAccess())
                        {
                            LoadAccount();
                        }
                        else
                        {
                            ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                            {
                                LoadAccount();
                            }));
                        }

                        if (account != null)
                        {
                            LoadATMStrategy();
                            LoadPositions();

                            if (IsDayOverAccountBalanceFloorEnabled())
                            {
                                RealLogger.PrintOutput("Day Over Account Balance Floor: $" + DayOverAccountBalanceFloorDollars.ToString("N2"), PrintTo.OutputTab1);
                                RealLogger.PrintOutput("Day Over Account Balance Floor: $" + DayOverAccountBalanceFloorDollars.ToString("N2"), PrintTo.OutputTab2);
                            }

                            if (IsBogeyTargetEnabled())
                            {
                                double bogeyTargetMultiplier = currentBogeyTargetMultiplier; // CalculateBogeyTargetMutiplier(currentBogeyTargetStatus);
                                double dpMultipliedAmount = (BogeyTargetBaseDollars * bogeyTargetMultiplier);

                                RealLogger.PrintOutput("Bogey Target Base: $" + BogeyTargetBaseDollars.ToString("N2") + " x " + bogeyTargetMultiplier.ToString("N0") + " ($" + dpMultipliedAmount.ToString("N0") + ")", PrintTo.OutputTab1);
                                RealLogger.PrintOutput("Bogey Target Base: $" + BogeyTargetBaseDollars.ToString("N2") + " x " + bogeyTargetMultiplier.ToString("N0") + " ($" + dpMultipliedAmount.ToString("N0") + ")", PrintTo.OutputTab2);
                            }

                            bool maxInitialTrancheVolumeSizeEnabled = MaxInitialTrancheVolumeSize > 0;
                            maxInitialTrancheVolumeSize = 0;

                            if (maxInitialTrancheVolumeSizeEnabled)
                                maxInitialTrancheVolumeSize = GetValidVolumeSize(MaxInitialTrancheVolumeSize);

                            if (limitTrancheVolumeToInProfitFlag)
                            {
                                RealLogger.PrintOutput("Max Initial Tranche Volume Size: " + maxInitialTrancheVolumeSize.ToString("N0"));
                            }

                            if (limitTrancheVolumePerBarFlag)
                            {
                                RealLogger.PrintOutput("Min Tranche Volume Per Bar Delay Seconds: " + MinTrancheVolumeDelaySeconds.ToString("N0"));
                            }

                            if (IsDayOverMaxLossEnabled())
                            {
                                RealLogger.PrintOutput("Day Over Max Loss: $" + dayOverMaxLossDollars.ToString("N2"), PrintTo.OutputTab1);
                                RealLogger.PrintOutput("Day Over Max Loss: $" + dayOverMaxLossDollars.ToString("N2"), PrintTo.OutputTab2);
                            }

                            if (IsMaxDDStopLossEnabled())
                            {
                                RealLogger.PrintOutput("Max DD: $" + maxDDInDollars.ToString("N2"), PrintTo.OutputTab1);
                                RealLogger.PrintOutput("Max DD: $" + maxDDInDollars.ToString("N2"), PrintTo.OutputTab2);
                            }

                            attachedInstrumentCommissionPerSide = GetInstrumentCommissionPerSide(attachedInstrument);
                            RealLogger.PrintOutput("Detected commission per side: $" + attachedInstrumentCommissionPerSide.ToString("N2") + " for " + attachedInstrument.FullName, PrintTo.OutputTab1);
                            RealLogger.PrintOutput("Detected commission per side: $" + attachedInstrumentCommissionPerSide.ToString("N2") + " for " + attachedInstrument.FullName, PrintTo.OutputTab2);

                            attachedInstrumentIntradayMarginDollars = GetInstrumentIntradayMarginDollars(attachedInstrument);
                            RealLogger.PrintOutput("Detected intraday margin dollars: $" + attachedInstrumentIntradayMarginDollars.ToString("N2") + " for " + attachedInstrument.FullName, PrintTo.OutputTab1);
                            RealLogger.PrintOutput("Detected intraday margin dollars: $" + attachedInstrumentIntradayMarginDollars.ToString("N2") + " for " + attachedInstrument.FullName, PrintTo.OutputTab2);

                            attachedInstrumentPositionMaxVolume = GetInstrumentPositionMaxVolume(attachedInstrument);
                            RealLogger.PrintOutput("Detected position max volume: " + attachedInstrumentPositionMaxVolume.ToString("N0") + " for " + attachedInstrument.FullName, PrintTo.OutputTab1);
                            RealLogger.PrintOutput("Detected position max volume: " + attachedInstrumentPositionMaxVolume.ToString("N0") + " for " + attachedInstrument.FullName, PrintTo.OutputTab2);


                            /*
                            if (UseHedgehogEntry && attachedInstrumentIsFuture)
                            {
                                RealLogger.PrintOutput("Validating HedgehogEntrySymbol1...", PrintTo.OutputTab2);
                                ValidateInstrument(HedgehogEntrySymbol1FullName);

                                RealLogger.PrintOutput("Validating HedgehogEntrySymbol2...", PrintTo.OutputTab2);
                                ValidateInstrument(HedgehogEntrySymbol2FullName);
                            }
                            */





                            /*
                            if (ChartControl.Dispatcher.CheckAccess())
                            {
                                LoadAccount();
                            }
                            else
                            {
                                ChartControl.Dispatcher.InvokeAsync((Action)(() =>
                                {
                                    LoadAccount();
                                }));
                            }
                            */

                            /*

                            if (IsStrategyAttachedToChart() && UserControlCollection.Contains(buttonGrid))
                            {
                                if (ChartControl != null)
                                {
                                    if (ChartControl.Dispatcher.CheckAccess())
                                    {
                                        SetButtonPanelVisiblity();
                                    }
                                    else
                                    {
                                        ChartControl.Dispatcher.InvokeAsync((() =>
                                        {
                                            SetButtonPanelVisiblity();
                                        }));
                                    }
                                }
                            }
                            */

                            hasRanOnceFirstCycle = true;
                        }
                    }
                }
            }

            return hasRanOnceFirstCycle;
        }

        private void OnAccountStatusUpdate(object sender, AccountStatusEventArgs e)
        {

            // Output the account name and status

            //NinjaTrader.Code.Output.Process(string.Format("OnAccountStatusUpdate - Account: {0} Status: {1}", e.Account.Name, e.Status), PrintTo.OutputTab1);

        }

        private void OnAccountItemUpdate(object sender, AccountItemEventArgs e)

        {

            // Output the account item

            //NinjaTrader.Code.Output.Process(string.Format("OnAccountItemUpdate - Account: {0} AccountItem: {1} Value: {2}", e.Account.Name, e.AccountItem, e.Value), PrintTo.OutputTab1);

        }

        private void OnExecutionUpdate(object sender, ExecutionEventArgs e)
        {
            /*
            lastExecutionUpdatePrice = 0;

            if (e != null)
            {
                lastExecutionUpdatePrice = e.Execution.Price;
            }
            */

            // Output the execution

            //Print("OnExecutionUpdate - OrderId=" + Convert.ToString(e.OrderId) + " ExecId=" + Convert.ToString(e.ExecutionId) + " quanity=" + Convert.ToString(e.Quantity) + " price=" + e.Execution.Price + " op=" + e.Operation + " name=" + e.Execution.Name + " mp=" + e.MarketPosition + " e.instra=" + e.Execution.Instrument.FullName);
            //NinjaTrader.Code.Output.Process(string.Format("Instrument: {0} Quantity: {1} Price: {2}", e.Execution.Instrument.FullName, e.Quantity, e.Price), PrintTo.OutputTab1);


            //if (entryOrder != null && execution.Order == entryOrder)
            //{
            //    string ocoString = "ocoString";
            //    profitTarget = SubmitOrderUnmanaged(1, OrderAction.Sell, OrderType.StopMarket, e.Execution.Order.Filled, e.Execution.Order.AverageFillPrice + 60, 0, ocoString, "profit target");
            //}

            try
            {
                //Print("OnExecutionUpdate running RealTimePipeline");
                Dispatcher.InvokeAsync(() =>
                {
                    if (hasRanOnceFirstCycle)
                    {
                        try
                        {
                            lock (ThreadManagerLock)
                            {
                                TriggerCustomEvent(o =>
                                {
                                    RealTimePipeline();
                                }, null);
                            }
                        }
                        catch (Exception ex)
                        {
                            //log and stuff exception
                            RealLogger.PrintOutput("Exception calling OnExecutionUpdate Dispatcher.InvokeAsync:" + ex.Message + " " + ex.StackTrace);
                        }
                    }
                });
            }
            catch (Exception ex)
            {
                //log and stuff exception
                RealLogger.PrintOutput("Exception calling OnExecutionUpdate:" + ex.Message + " " + ex.StackTrace);
            }
        }

        private void OnPositionUpdate(object sender, PositionEventArgs e)
        {
            string signalName = "OnPositionUpdate";

            //NinjaTrader.Code.Output.Process(string.Format("OnPositionUpdate - Instrument: {0} MarketPosition: {1} AveragePrice: {2} Quantity: {3} Operation: {4}", e.Position.Instrument.FullName, e.MarketPosition, e.AveragePrice, e.Quantity, e.Operation), PrintTo.OutputTab1);

            if (e != null && e.Position != null && e.Position.Instrument != null)
            {
                RealLogger.PrintOutput(string.Format("OnPositionUpdate - Instrument: {0} - MarketPosition: {1} - AveragePrice: {2} - Quantity: {3} - Operation: {4}", e.Position.Instrument.FullName, e.MarketPosition, e.AveragePrice, e.Quantity, e.Operation));
                //Print("*** DEBUG e.AveragePrice=" + e.AveragePrice + " pos.ap=" + e.Position.AveragePrice + " exp=" + lastExecutionPrice);

                RealPosition updatedPosition = RealPositionService.BuildRealPosition(e.Position.Account, e.Position.Instrument, e.MarketPosition, e.Quantity, e.AveragePrice, GetDateTimeNow());

                if (e.Operation == Operation.Add)
                {
                    RealPositionService.AddPosition(updatedPosition);
                }
                else if (e.Operation == Operation.Update)
                {
                    RealPositionService.UpdatePosition(updatedPosition);
                }
                else if (e.Operation == Operation.Remove)
                {
                    RealPositionService.RemovePosition(updatedPosition);
                }



                /*
                 RealPosition foundPosition = null;
                if (RealPositionService.TryGetByInstrumentFullName(e.Position.Instrument.FullName, out foundPosition))
                {
                    bool arePositionCountsInSync = (e.Quantity == foundPosition.Quantity);

                    if (!arePositionCountsInSync)
                    {
                        RealLogger.PrintOutput("*** ERROR: Position quantity counts out of sync internalQuantityCount=" + foundPosition.Quantity + " vs  actualQuantityCount=" + e.Quantity + " via " + signalName);
                    }
                }
                else if (e.Quantity != 0)
                {
                    RealLogger.PrintOutput("*** ERROR: Position quantity counts out of sync internalQuantityCount=0 vs actualQuantityCount=" + e.Quantity + " via " + signalName);
                }
                */

                bool isInstrumentFlat = (e.MarketPosition == MarketPosition.Flat);

                if (isInstrumentFlat)
                {
                    PositionCloseCleanUp(e.Position.Instrument);
                }


                bool isAttachedInstrument = (e.Position.Instrument == attachedInstrument);
                bool isBlendedInstrument = IsBlendedInstrumentEnabled() && (e.Position.Instrument == blendedInstrument);

                if (isAttachedInstrument || isBlendedInstrument)
                {
                    if (!isInstrumentFlat)
                    {
                        if (validateAttachedPositionStopLossQuantityStage1)
                        {
                            validateAttachedPositionStopLossQuantity = true;

                            validateAttachedPositionStopLossQuantityStage1 = false;
                        }

                        if (validateAttachedPositionTakeProfitQuantityStage1)
                        {
                            validateAttachedPositionTakeProfitQuantity = true;

                            validateAttachedPositionTakeProfitQuantityStage1 = false;
                        }

                        if (validateBlendedPositionStopLossQuantityStage1)
                        {
                            validateBlendedPositionStopLossQuantity = true;

                            validateBlendedPositionStopLossQuantityStage1 = false;
                        }

                        if (validateBlendedPositionTakeProfitQuantityStage1)
                        {
                            validateBlendedPositionTakeProfitQuantity = true;

                            validateBlendedPositionTakeProfitQuantityStage1 = false;
                        }
                    }
                }
            }
        }

        private void PositionCloseCleanUp(Instrument instrument)
        {
            if (instrument == attachedInstrument)
            {
                CancelPositionTPSLOrders("TPSLRefresh-All", attachedInstrument);

                ExitCloseAlertWindows();

                attachedInstrumentHasPosition = false;
                attachedInstrumentPositionBarCount = 0;
                attachedInstrumentPositionCreeperCycleCount = 0;
                attachedInstrumentPositionCreeperSurging = false;
                attachedInstrumentPositionCreeperGushing1 = false;
                attachedInstrumentPositionFlowing1 = false;
                attachedInstrumentPositionFlowing2 = false;
                attachedInstrumentPositionFlowing3 = false;
                attachedInstrumentPositionFlowing4 = false;
                attachedInstrumentMarketPosition = MarketPosition.Flat;
                attachedInstrumentPositionPrice = 0;
                attachedInstrumentPositionQuantity = 0;
                attachedInstrumentPositionStopLossPrice = 0;
                attachedInstrumentPositionTakeProfitPrice = 0;
                attachedInstrumentPositionPnL = 0;
                attachedInstrumentHasChanged = true;

                riskInfoHasChanged = true;

                profitInfoHasChanged = true;

                dayOverMaxLossHasChanged = true;

                bogeyTargetHasChanged = true;

                dayOverAccountBalanceFloorHasChanged = true;

                ecaTakeProfitHasChanged = true;

                averagePriceHasChanged = true;
            }
            else if (IsBlendedInstrumentEnabled() && instrument == blendedInstrument)
            {
                CancelPositionTPSLOrders("TPSLRefresh-All", blendedInstrument);

                ExitCloseAlertWindows();

                blendedInstrumentHasPosition = false;
                blendedInstrumentPositionCreeperCycleCount = 0;
                blendedInstrumentPositionCreeperSurging = false;
                blendedInstrumentMarketPosition = MarketPosition.Flat;
                blendedInstrumentPositionPrice = 0;
                blendedInstrumentPositionQuantity = 0;
                blendedInstrumentPositionStopLossPrice = 0;
                blendedInstrumentPositionTakeProfitPrice = 0;
                blendedInstrumentHasChanged = true;

                bogeyTargetHasChanged = true;

                ecaTakeProfitHasChanged = true;

                averagePriceHasChanged = true;
            }
        }

        private string GetATMStrategy()
        {
            string tempATMStrategyName = null;

            try
            {
                AtmStrategy atmStrategy = this.ChartControl.OwnerChart.ChartTrader.AtmStrategy;
                if (atmStrategy != null)
                {
                    tempATMStrategyName = atmStrategy.Template + "";
                }
            }
            catch (Exception ex)
            {
                //stuff exception
            }

            return tempATMStrategyName;
        }

        private void LoadATMStrategy(string newATMStrategyName = "")
        {
            //lock (account)
            {
                string tempATMStrategyName = newATMStrategyName;

                if (tempATMStrategyName == string.Empty)
                {
                    tempATMStrategyName = GetATMStrategy();
                }
                else
                {
                    tempATMStrategyName = newATMStrategyName;
                }

                if (tempATMStrategyName != atmStrategyName)
                {
                    atmStrategyName = tempATMStrategyName;

                    string displayATMStrategyName = (string.IsNullOrEmpty(atmStrategyName)) ? "None" : atmStrategyName;

                    RealLogger.PrintOutput("Found ATM strategy name (" + displayATMStrategyName + ")", PrintTo.OutputTab1);
                    RealLogger.PrintOutput("Found ATM strategy name (" + displayATMStrategyName + ")", PrintTo.OutputTab2);
                }
            }
        }

        private Account GetAccount()
        {
            Account tempAccount = null;

            try
            {
                tempAccount = this.ChartControl.OwnerChart.ChartTrader.Account;
            }
            catch
            {
                //stuff exception
            }

            return tempAccount;
        }

        private void LoadAccount(Account newAccount = null)
        {
            string signalName = "LoadAccount";

            lock (AccountLock)
            {
                Account tempAccount = newAccount;

                if (newAccount == null)
                {
                    tempAccount = GetAccount();
                }
                else
                {
                    tempAccount = newAccount;
                }

                if (tempAccount != null && tempAccount != account)
                {
                    if (account != null) UnloadAccountEvents(signalName);

                    account = tempAccount;

                    RealLogger.PrintOutput("Found account name (" + Convert.ToString(account.DisplayName) + ")", PrintTo.OutputTab1);
                    RealLogger.PrintOutput("Found account name (" + Convert.ToString(account.DisplayName) + ")", PrintTo.OutputTab2);


                    SubscribeToOrderUpdate(account);
                    SubscribeToExecutionUpdate(account);
                    SubscribeToPositionUpdate(account);



                    //WeakEventManager<Account, AccountStatusEventArgs>.AddHandler(account, "AccountStatusUpdate", OnAccountStatusUpdate);
                    //WeakEventManager<Account, AccountItemEventArgs>.AddHandler(account, "AccountItemUpdate", OnAccountItemUpdate);

                    //if (this.DebugLogLevel > 10) RealLogger.PrintOutput("*** LoadAccount: Subscribing to PositionUpdate:");
                    //WeakEventManager<Account, PositionEventArgs>.AddHandler(account, "PositionUpdate", OnPositionUpdate);


                    //LoadDayOverMaxLossHighestPnLInSessionData();

                }
                else if (tempAccount == null)
                {
                    RealLogger.PrintOutput("Account name not found.", PrintTo.OutputTab1);
                    RealLogger.PrintOutput("Account name not found.", PrintTo.OutputTab2);
                }
            }


            /*
            Window currentWindow = Window.GetWindow(ChartControl.Parent);
            if (currentWindow != null)
            {
                NinjaTrader.Gui.Tools.AccountSelector accountSelector = currentWindow.FindFirst("ChartTraderControlAccountSelector") as NinjaTrader.Gui.Tools.AccountSelector;
                if (accountSelector != null)
                {
                    if (accountSelector.SelectedAccount != null)
                    {
                        RealLogger.PrintOutput("*** Found account name (" + Convert.ToString(accountSelector.SelectedAccount.DisplayName) + ")", PrintTo.OutputTab2);
                        account = accountSelector.SelectedAccount; //ChartControl.OwnerChart.ChartTrader.Account 

                        if (account != null)
                        {
                            //Account.ExecutionUpdate += OnExecutionUpdate;
                            WeakEventManager<Account, OrderEventArgs>.AddHandler(account, "OrderUpdate", OnOrderUpdate);
                            WeakEventManager<Account, PositionEventArgs>.AddHandler(account, "PositionUpdate", OnPositionUpdate);
                            //Account.OrderUpdate += OnOrderUpdate;
                            // Subscribe to position updates
                            //Account.PositionUpdate += OnPositionUpdate;

                        }
                    }
                }
                else
                    RealLogger.PrintOutput("*** Account name not found.", PrintTo.OutputTab2);

            }
            else
                RealLogger.PrintOutput("*** Account name not found and no window.", PrintTo.OutputTab2);
            */
        }

        private void SetButtonPanelVisiblity()
        {
            if (buttonGrid != null)
            {
                buttonGrid.Background = Brushes.Black;

                if (thLayoutGrid != null)
                {
                    thLayoutGrid.Visibility = Visibility.Visible;
                }
                if (labelGrid != null)
                {
                    labelGrid.Visibility = Visibility.Visible;
                }
                if (riskInfoLabel != null)
                {
                    riskInfoLabel.Visibility = Visibility.Visible;
                }
                if (profitInfoLabel != null)
                {
                    profitInfoLabel.Visibility = Visibility.Visible;
                }
                if (bogeyTargetInfoLabel != null)
                {
                    bogeyTargetInfoLabel.Visibility = Visibility.Visible;
                }
                if (dayOverMaxLossInfoLabel != null)
                {
                    dayOverMaxLossInfoLabel.Visibility = Visibility.Visible;
                }
                if (revButton != null && ShowButtonReverse)
                {
                    revButton.Visibility = Visibility.Visible;
                }
                if (closeAllButton != null && ShowButtonClose)
                {
                    closeAllButton.Visibility = Visibility.Visible;
                }
                if (toggleAutoCloseButton != null && ShowButtonAutoClose)
                {
                    toggleAutoCloseButton.Visibility = Visibility.Visible;
                }
                if (toggleAutoBEButton != null && ShowButtonAutoBreakEven)
                {
                    toggleAutoBEButton.Visibility = Visibility.Visible;
                }
                if (toggleProfitTargetButton != null && ShowButtonProfitTarget)
                {
                    toggleProfitTargetButton.Visibility = Visibility.Visible;
                }
                if (TPButton != null && ShowButtonTPPlus)
                {
                    TPButton.Visibility = Visibility.Visible;
                }
                if (BEButton != null && ShowButtonBEPlus)
                {
                    BEButton.Visibility = Visibility.Visible;
                }
                if (SLButton != null && ShowButtonSLPlus)
                {
                    SLButton.Visibility = Visibility.Visible;
                }
                if (BuyMarketButton != null && ShowButtonBuyMarket)
                {
                    BuyMarketButton.Visibility = Visibility.Visible;
                }
                if (SellMarketButton != null && ShowButtonSellMarket)
                {
                    SellMarketButton.Visibility = Visibility.Visible;
                }
                if (BuyPopButton != null && ShowButtonPopPlus)
                {
                    BuyPopButton.Visibility = Visibility.Visible;
                }
                if (SellPopButton != null && ShowButtonPopMinus)
                {
                    SellPopButton.Visibility = Visibility.Visible;
                }
                if (BuyDropButton != null && ShowButtonDropPlus)
                {
                    BuyDropButton.Visibility = Visibility.Visible;
                }
                if (SellDropButton != null && ShowButtonDropMinus)
                {
                    SellDropButton.Visibility = Visibility.Visible;
                }
                if (toggleEntryVolumeAutoButton != null && ShowButtonVolume)
                {
                    toggleEntryVolumeAutoButton.Visibility = Visibility.Visible;
                }
                if (toggleEntryVolumeMaxButton != null && ShowButtonVolumeMax && LimitToVolumeMaxOption)
                {
                    toggleEntryVolumeMaxButton.Visibility = Visibility.Visible;
                }
                if (toggleAutoPilotButton != null && ShowButtonAutoPilot)
                {
                    toggleAutoPilotButton.Visibility = Visibility.Visible;
                }
                if (toggleAutoPilotProfileButton != null && ShowButtonAutoPilotProfile)
                {
                    toggleAutoPilotProfileButton.Visibility = Visibility.Visible;
                }
                if (toggleTradeSignalButton != null && ShowButtonTradeSignal && !UseAutoPilotLite)
                {
                    toggleTradeSignalButton.Visibility = Visibility.Visible;
                }
                if (toggleAutoAddOnButton != null && ShowButtonAutoAddOn)
                {
                    toggleAutoAddOnButton.Visibility = Visibility.Visible;
                }
            }
        }

        private void SetButtonPanelHidden()
        {
            if (buttonGrid != null)
            {
                buttonGrid.Background = Brushes.Transparent;

                if (thLayoutGrid != null)
                {
                    thLayoutGrid.Visibility = Visibility.Visible;
                }
                if (labelGrid != null)
                {
                    labelGrid.Visibility = Visibility.Hidden;
                }
                if (riskInfoLabel != null)
                {
                    riskInfoLabel.Visibility = Visibility.Hidden;
                }
                if (profitInfoLabel != null)
                {
                    profitInfoLabel.Visibility = Visibility.Hidden;
                }
                if (bogeyTargetInfoLabel != null)
                {
                    bogeyTargetInfoLabel.Visibility = Visibility.Hidden;
                }
                if (dayOverMaxLossInfoLabel != null)
                {
                    dayOverMaxLossInfoLabel.Visibility = Visibility.Hidden;
                }
                if (revButton != null)
                {
                    revButton.Visibility = Visibility.Hidden;
                }
                if (closeAllButton != null)
                {
                    closeAllButton.Visibility = Visibility.Hidden;
                }
                if (toggleAutoCloseButton != null)
                {
                    toggleAutoCloseButton.Visibility = Visibility.Hidden;
                }
                if (toggleAutoBEButton != null)
                {
                    toggleAutoBEButton.Visibility = Visibility.Hidden;
                }
                if (toggleProfitTargetButton != null)
                {
                    toggleProfitTargetButton.Visibility = Visibility.Hidden;
                }
                if (TPButton != null)
                {
                    TPButton.Visibility = Visibility.Hidden;
                }
                if (BEButton != null)
                {
                    BEButton.Visibility = Visibility.Hidden;
                }
                if (SLButton != null)
                {
                    SLButton.Visibility = Visibility.Hidden;
                }
                if (BuyPopButton != null)
                {
                    BuyPopButton.Visibility = Visibility.Hidden;
                }
                if (SellPopButton != null)
                {
                    SellPopButton.Visibility = Visibility.Hidden;
                }
                if (BuyDropButton != null)
                {
                    BuyDropButton.Visibility = Visibility.Hidden;
                }
                if (SellDropButton != null)
                {
                    SellDropButton.Visibility = Visibility.Hidden;
                }
                if (BuyMarketButton != null)
                {
                    BuyMarketButton.Visibility = Visibility.Hidden;
                }
                if (SellMarketButton != null)
                {
                    SellMarketButton.Visibility = Visibility.Hidden;
                }
                if (toggleAutoAddOnButton != null)
                {
                    toggleAutoAddOnButton.Visibility = Visibility.Hidden;
                }
                if (toggleAutoPilotButton != null)
                {
                    toggleAutoPilotButton.Visibility = Visibility.Hidden;
                }
                if (toggleAutoPilotProfileButton != null)
                {
                    toggleAutoPilotProfileButton.Visibility = Visibility.Hidden;
                }
                if (toggleTradeSignalButton != null)
                {
                    toggleTradeSignalButton.Visibility = Visibility.Hidden;
                }
                if (toggleEntryVolumeAutoButton != null)
                {
                    toggleEntryVolumeAutoButton.Visibility = Visibility.Hidden;
                }
                if (toggleEntryVolumeMaxButton != null)
                {
                    toggleEntryVolumeMaxButton.Visibility = Visibility.Hidden;
                }
            }
        }
        private bool IsStrategyAttachedToChart()
        {
            return (this.ChartBars != null);
        }

        private void RemoveButtonPanel()
        {
            if (buttonGrid != null)
            {
                if (UserControlCollection.Contains(buttonGrid))
                {
                    if (revButton != null)
                    {
                        UnsubscribeToButtonClick(revButton);
                        buttonGrid.Children.Remove(revButton);
                        revButton = null;
                    }
                    if (closeAllButton != null)
                    {
                        UnsubscribeToButtonClick(closeAllButton);
                        buttonGrid.Children.Remove(closeAllButton);
                        closeAllButton = null;
                    }
                    if (toggleAutoCloseButton != null)
                    {
                        UnsubscribeToButtonClick(toggleAutoCloseButton);
                        buttonGrid.Children.Remove(toggleAutoCloseButton);
                        toggleAutoCloseButton = null;
                    }
                    if (toggleAutoBEButton != null)
                    {
                        UnsubscribeToButtonClick(toggleAutoBEButton);
                        buttonGrid.Children.Remove(toggleAutoBEButton);
                        toggleAutoBEButton = null;
                    }
                    if (toggleProfitTargetButton != null)
                    {
                        UnsubscribeToButtonClick(toggleProfitTargetButton);
                        buttonGrid.Children.Remove(toggleProfitTargetButton);
                        toggleProfitTargetButton = null;
                    }
                    if (toggleEntryVolumeAutoButton != null)
                    {
                        UnsubscribeToButtonClick(toggleEntryVolumeAutoButton);
                        buttonGrid.Children.Remove(toggleEntryVolumeAutoButton);
                        toggleEntryVolumeAutoButton = null;
                    }
                    if (toggleEntryVolumeMaxButton != null)
                    {
                        UnsubscribeToButtonClick(toggleEntryVolumeMaxButton);
                        buttonGrid.Children.Remove(toggleEntryVolumeMaxButton);
                        toggleEntryVolumeMaxButton = null;
                    }

                    if (toggleAutoAddOnButton != null)
                    {
                        UnsubscribeToButtonClick(toggleAutoAddOnButton);
                        buttonGrid.Children.Remove(toggleAutoAddOnButton);
                        toggleAutoAddOnButton = null;
                    }

                    if (toggleTradeSignalButton != null)
                    {
                        UnsubscribeToButtonClick(toggleTradeSignalButton);
                        buttonGrid.Children.Remove(toggleTradeSignalButton);
                        toggleTradeSignalButton = null;
                    }

                    if (toggleAutoPilotButton != null)
                    {
                        UnsubscribeToButtonClick(toggleAutoPilotButton);
                        buttonGrid.Children.Remove(toggleAutoPilotButton);
                        toggleAutoPilotButton = null;
                    }

                    if (toggleAutoPilotProfileButton != null)
                    {
                        UnsubscribeToButtonClick(toggleAutoPilotProfileButton);
                        buttonGrid.Children.Remove(toggleAutoPilotProfileButton);
                        toggleAutoPilotProfileButton = null;
                    }

                    if (TPButton != null)
                    {
                        UnsubscribeToButtonClick(TPButton);
                        buttonGrid.Children.Remove(TPButton);
                        TPButton = null;
                    }
                    if (BEButton != null)
                    {
                        UnsubscribeToButtonClick(BEButton);
                        buttonGrid.Children.Remove(BEButton);
                        BEButton = null;
                    }
                    if (SLButton != null)
                    {
                        UnsubscribeToButtonClick(SLButton);
                        buttonGrid.Children.Remove(SLButton);
                        SLButton = null;
                    }

                    if (BuyPopButton != null)
                    {
                        UnsubscribeToButtonClick(BuyPopButton);
                        buttonGrid.Children.Remove(BuyPopButton);
                        BuyPopButton = null;
                    }

                    if (SellPopButton != null)
                    {
                        UnsubscribeToButtonClick(SellPopButton);
                        buttonGrid.Children.Remove(SellPopButton);
                        SellPopButton = null;
                    }

                    if (BuyDropButton != null)
                    {
                        UnsubscribeToButtonClick(BuyDropButton);
                        buttonGrid.Children.Remove(BuyDropButton);
                        BuyDropButton = null;
                    }

                    if (SellDropButton != null)
                    {
                        UnsubscribeToButtonClick(SellDropButton);
                        buttonGrid.Children.Remove(SellDropButton);
                        SellDropButton = null;
                    }

                    if (BuyMarketButton != null)
                    {
                        UnsubscribeToButtonClick(BuyMarketButton);
                        buttonGrid.Children.Remove(BuyMarketButton);
                        BuyMarketButton = null;
                    }

                    if (SellMarketButton != null)
                    {
                        UnsubscribeToButtonClick(SellMarketButton);
                        buttonGrid.Children.Remove(SellMarketButton);
                        SellMarketButton = null;
                    }


                    thLayoutGrid = null;
                }
            }
        }

        private void DrawButtonPanel()
        {
            if (thLayoutGrid == null)
            {
                if (!UserControlCollection.Contains(thLayoutGrid))
                {
                    thLayoutGrid = new System.Windows.Controls.Grid
                    {
                        Name = "HHTHLayoutGrid",
                        Margin = new Thickness(0, 0, 40, 0),
                        HorizontalAlignment = HorizontalAlignment.Right,
                        VerticalAlignment = VerticalAlignment.Top
                        //ShowGridLines = true,
                        //Background = Brushes.Black
                    };

                    System.Windows.Controls.RowDefinition thLayoutRow1 = new System.Windows.Controls.RowDefinition();
                    System.Windows.Controls.RowDefinition thLayoutRow2 = new System.Windows.Controls.RowDefinition();
                    thLayoutGrid.RowDefinitions.Add(thLayoutRow1);
                    thLayoutGrid.RowDefinitions.Add(thLayoutRow2);

                    System.Windows.Controls.ColumnDefinition thLayoutColumn1 = new System.Windows.Controls.ColumnDefinition();

                    thLayoutGrid.ColumnDefinitions.Add(thLayoutColumn1);


                    buttonGrid = new System.Windows.Controls.Grid
                    {
                        Name = "HHButtonGrid",
                        Margin = new Thickness(0, 0, 0, 0),
                        HorizontalAlignment = HorizontalAlignment.Right,
                        VerticalAlignment = VerticalAlignment.Top,
                        //ShowGridLines = true,
                        Background = Brushes.Black

                    };

                    System.Windows.Controls.RowDefinition row1 = new System.Windows.Controls.RowDefinition();



                    //System.Windows.Controls.RowDefinition row3 = new System.Windows.Controls.RowDefinition();
                    //row2.Height = new GridLength(50);
                    buttonGrid.RowDefinitions.Add(row1);
                    //buttonGrid.RowDefinitions.Add(row3);

                    System.Windows.Controls.ColumnDefinition column1 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column2 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column3 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column4 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column5 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column6 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column7 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column8 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column9 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column10 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column11 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column12 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column13 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column14 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column15 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column16 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column17 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column18 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column19 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition column20 = new System.Windows.Controls.ColumnDefinition();


                    buttonGrid.ColumnDefinitions.Add(column1);
                    buttonGrid.ColumnDefinitions.Add(column2);
                    buttonGrid.ColumnDefinitions.Add(column3);
                    buttonGrid.ColumnDefinitions.Add(column4);
                    buttonGrid.ColumnDefinitions.Add(column5);
                    buttonGrid.ColumnDefinitions.Add(column6);
                    buttonGrid.ColumnDefinitions.Add(column7);
                    buttonGrid.ColumnDefinitions.Add(column8);
                    buttonGrid.ColumnDefinitions.Add(column9);
                    buttonGrid.ColumnDefinitions.Add(column10);
                    buttonGrid.ColumnDefinitions.Add(column11);
                    buttonGrid.ColumnDefinitions.Add(column12);
                    buttonGrid.ColumnDefinitions.Add(column13);
                    buttonGrid.ColumnDefinitions.Add(column14);
                    buttonGrid.ColumnDefinitions.Add(column15);
                    buttonGrid.ColumnDefinitions.Add(column16);
                    buttonGrid.ColumnDefinitions.Add(column17);
                    buttonGrid.ColumnDefinitions.Add(column18);
                    buttonGrid.ColumnDefinitions.Add(column19);
                    buttonGrid.ColumnDefinitions.Add(column20);


                    revButton = new System.Windows.Controls.Button
                    {
                        Name = HHRevButtonName,
                        Content = (IsBlendedInstrumentEnabled()) ? ToggleReverseBButtonText : ToggleReverseButtonText,
                        ToolTip = (IsBlendedInstrumentEnabled()) ? ToggleReverseBButtonToolTip : ToggleReverseButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.DarkOrange,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };

                    string closeButtonText = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? ToggleFlatButtonText : (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonText : ToggleCloseButtonText;
                    string closeButtonToolTip = (currentProfitTargetStatus == TickHunterProfitTargetTypes.EquityCloseAllTarget) ? ToggleFlatButtonToolTip : (IsBlendedInstrumentEnabled()) ? ToggleCloseBButtonToolTip : ToggleCloseButtonToolTip;

                    closeAllButton = new System.Windows.Controls.Button
                    {
                        Name = HHCloseAllButtonName,
                        Content = closeButtonText,
                        ToolTip = closeButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.DarkGreen,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };

                    string tempContent;
                    string tempToolTip;

                    if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage1Slope)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage2Slope)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage3Slope)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.MovingAverage4Break)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.DriftLine4Break)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieStackedFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZombieBoostedFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.KLineDualFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.CreeperFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.ZLineDualFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentCloseAutoStatus == TickHunterCloseAutoTypes.KZFlip)
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else
                    {
                        lastToggleEntryCloseAutoStatus = currentCloseAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetAutoCloseButtonText(lastToggleEntryCloseAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }

                    Brush tempBrush = (currentCloseAutoStatus != TickHunterCloseAutoTypes.Disabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleAutoCloseButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleAutoCloseButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.Enabled)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.HODL)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail1Bar)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail2Bar)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail3Bar)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrail5Bar)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMix)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek1)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailCreek5)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKLineDual)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLine2)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailZipLineDual)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailKZ)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMonster)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftMonster)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else if (currentBreakEvenAutoStatus == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
                    {
                        lastToggleEntryBreakEvenAutoStatus = currentBreakEvenAutoStatus;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }
                    else
                    {
                        lastToggleEntryBreakEvenAutoStatus = TickHunterBreakEvenAutoTypes.Disabled;
                        string buttonText = "";
                        string buttonToolTip = "";
                        GetBreakEvenAutoButtonText(lastToggleEntryBreakEvenAutoStatus, out buttonText, out buttonToolTip);

                        tempContent = buttonText;
                        tempToolTip = buttonToolTip;
                    }

                    tempBrush = (currentBreakEvenAutoStatus != TickHunterBreakEvenAutoTypes.Disabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleAutoBEButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleAutoBEButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    GetBogeyTargetTypeButtonText(currentBogeyTargetMultiplier, out tempContent, out tempToolTip);

                    tempBrush = (currentBogeyTargetMultiplier != BogeyTargetMultiplierDisabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleProfitTargetButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleProfitTargetButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    TPButton = new System.Windows.Controls.Button
                    {
                        Name = HHTPButtonName,
                        Content = ToggleTPButtonText,
                        ToolTip = ToggleTPButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.Silver,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden

                    };

                    BEButton = new System.Windows.Controls.Button
                    {
                        Name = HHBEButtonName,
                        Content = ToggleBEButtonText,
                        ToolTip = ToggleBEButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.DarkCyan,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden

                    };

                    SLButton = new System.Windows.Controls.Button
                    {
                        Name = HHSLButtonName,
                        Content = ToggleSLButtonText,
                        ToolTip = ToggleSLButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.Silver,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    BuyDropButton = new System.Windows.Controls.Button
                    {
                        Name = HHBuyDropButtonName,
                        Content = ToggleDropBuyButtonText,
                        ToolTip = ToggleDropBuyButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.Blue,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    SellDropButton = new System.Windows.Controls.Button
                    {
                        Name = HHSellDropButtonName,
                        Content = ToggleDropSellButtonText,
                        ToolTip = ToggleDropSellButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.OrangeRed,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    GetPopButtonText(TickHunterPopTypes.PopPlus, currentBuyPopDelayedStatus, out tempContent, out tempToolTip);

                    BuyPopButton = new System.Windows.Controls.Button
                    {
                        Name = HHBuyPopButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = (popCTRLDelayedEntryFlag) ? Brushes.Blue : Brushes.DimGray,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    GetPopButtonText(TickHunterPopTypes.PopMinus, currentSellPopDelayedStatus, out tempContent, out tempToolTip);

                    SellPopButton = new System.Windows.Controls.Button
                    {
                        Name = HHSellPopButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = (popCTRLDelayedEntryFlag) ? Brushes.OrangeRed : Brushes.DimGray,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    BuyMarketButton = new System.Windows.Controls.Button
                    {
                        Name = HHBuyMarketButtonName,
                        Content = ToggleBuyMarketButtonText,
                        ToolTip = ToggleBuyMarketButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.Blue,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    SellMarketButton = new System.Windows.Controls.Button
                    {
                        Name = HHSellMarketButtonName,
                        Content = ToggleSellMarketButtonText,
                        ToolTip = ToggleSellMarketButtonToolTip,
                        Foreground = Brushes.White,
                        Background = Brushes.OrangeRed,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    if (currentEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option2)
                    {
                        tempContent = ToggleAutoEntryVolOption2ButtonEnabledText;
                        tempToolTip = ToggleAutoEntryVolOption2ButtonEnabledToolTip;
                    }
                    else if (currentEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option3)
                    {
                        tempContent = ToggleAutoEntryVolOption3ButtonEnabledText;
                        tempToolTip = ToggleAutoEntryVolOption3ButtonEnabledToolTip;
                    }
                    else if (currentEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option4)
                    {
                        tempContent = ToggleAutoEntryVolOption4ButtonEnabledText;
                        tempToolTip = ToggleAutoEntryVolOption4ButtonEnabledToolTip;
                    }
                    else if (currentEntryVolumeAutoStatus == TickHunterEntryVolumeAutoTypes.Option5)
                    {
                        tempContent = ToggleAutoEntryVolOption5ButtonEnabledText;
                        tempToolTip = ToggleAutoEntryVolOption5ButtonEnabledToolTip;
                    }
                    else
                    {
                        tempContent = ToggleAutoEntryVolOption1ButtonEnabledText;
                        tempToolTip = ToggleAutoEntryVolOption1ButtonEnabledToolTip;
                    }

                    tempBrush = Brushes.SaddleBrown;


                    toggleEntryVolumeAutoButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleEntryVolumeAutoButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };


                    if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option2)
                    {
                        tempContent = ToggleEntryVolMaxOption2ButtonEnabledText;
                        tempToolTip = ToggleEntryVolMaxOption2ButtonEnabledToolTip;
                    }
                    else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option3)
                    {
                        tempContent = ToggleEntryVolMaxOption3ButtonEnabledText;
                        tempToolTip = ToggleEntryVolMaxOption3ButtonEnabledToolTip;
                    }
                    else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option4)
                    {
                        tempContent = ToggleEntryVolMaxOption4ButtonEnabledText;
                        tempToolTip = ToggleEntryVolMaxOption4ButtonEnabledToolTip;
                    }
                    else if (currentEntryVolumeMaxStatus == TickHunterEntryVolumeMaxTypes.Option5)
                    {
                        tempContent = ToggleEntryVolMaxOption5ButtonEnabledText;
                        tempToolTip = ToggleEntryVolMaxOption5ButtonEnabledToolTip;
                    }
                    else
                    {
                        tempContent = ToggleEntryVolMaxOption1ButtonEnabledText;
                        tempToolTip = ToggleEntryVolMaxOption1ButtonEnabledToolTip;
                    }

                    tempBrush = Brushes.SaddleBrown;


                    toggleEntryVolumeMaxButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleEntryVolumeMaxButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    if (currentAutoAddOnStatus == TickHunterAutoAddOnTypes.Enabled)
                    {
                        tempContent = ToggleAutoAddOnButtonEnabledText;
                        tempToolTip = string.Format(ToggleAutoAddOnButtonEnabledToolTip, autoAddOnMaxDollars.ToString("N0"));
                    }
                    else
                    {
                        tempContent = ToggleAutoAddOnButtonDisabledText;
                        tempToolTip = string.Format(ToggleAutoAddOnButtonDisabledToolTip, autoAddOnMaxDollars.ToString("N0"));
                    }

                    tempBrush = (currentAutoAddOnStatus != TickHunterAutoAddOnTypes.Disabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleAutoAddOnButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleAutoAddOnButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };


                    if (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellAll)
                    {
                        tempContent = ToggleTradeSignalBSAButtonEnabledText;
                        tempToolTip = ToggleTradeSignalBSAButtonEnabledTextToolTip;
                    }
                    else if (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuySellFiltered)
                    {
                        tempContent = ToggleTradeSignalBSFButtonEnabledText;
                        tempToolTip = ToggleTradeSignalBSFButtonEnabledTextToolTip;
                    }
                    else if (currentTradeSignalStatus == TickHunterTradeSignalTypes.BuyOnly)
                    {
                        tempContent = ToggleTradeSignalBOButtonEnabledText;
                        tempToolTip = ToggleTradeSignalBOButtonEnabledTextToolTip;
                    }
                    else if (currentTradeSignalStatus == TickHunterTradeSignalTypes.SellOnly)
                    {
                        tempContent = ToggleTradeSignalSOButtonEnabledText;
                        tempToolTip = ToggleTradeSignalSOButtonEnabledTextToolTip;
                    }
                    else
                    {
                        tempContent = ToggleTradeSignalButtonDisabledText;
                        tempToolTip = ToggleTradeSignalButtonDisabledToolTip;
                    }


                    tempBrush = (currentTradeSignalStatus != TickHunterTradeSignalTypes.Disabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleTradeSignalButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleTradeSignalButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    if (UseAutoPilotLite)
                    {
                        GetAutoPilotLiteButtonText(currentAutoPilotLiteStatus, out tempContent, out tempToolTip);
                    }
                    else
                    {
                        GetAutoPilotButtonText(currentAutoPilotStatus, out tempContent, out tempToolTip);
                    }

                    tempBrush = (currentAutoPilotStatus != TickHunterAutoPilotTypes.Disabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleAutoPilotButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleAutoPilotButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };


                    GetAutoPilotProfileButtonText(currentAutoPilotProfileStatus, out tempContent, out tempToolTip);

                    tempBrush = (currentAutoPilotProfileStatus != TickHunterAutoPilotProfileTypes.Disabled) ? Brushes.HotPink : Brushes.DimGray;

                    toggleAutoPilotProfileButton = new System.Windows.Controls.Button
                    {
                        Name = HHToggleAutoPilotProfileButtonName,
                        Content = tempContent,
                        ToolTip = tempToolTip,
                        Foreground = Brushes.White,
                        Background = tempBrush,
                        HorizontalAlignment = HorizontalAlignment.Center,
                        Margin = new Thickness(0, 0, 2, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden
                    };

                    SubscribeToButtonClick(closeAllButton);
                    SubscribeToButtonClick(revButton);
                    SubscribeToButtonClick(toggleAutoCloseButton);
                    SubscribeToButtonClick(toggleAutoBEButton);
                    SubscribeToButtonClick(toggleProfitTargetButton);
                    SubscribeToButtonClick(TPButton);
                    SubscribeToButtonClick(BEButton);
                    SubscribeToButtonClick(SLButton);
                    SubscribeToButtonClick(BuyDropButton);
                    SubscribeToButtonClick(SellDropButton);
                    SubscribeToButtonClick(BuyPopButton);
                    SubscribeToButtonClick(SellPopButton);
                    SubscribeToButtonClick(BuyMarketButton);
                    SubscribeToButtonClick(SellMarketButton);
                    SubscribeToButtonClick(toggleEntryVolumeAutoButton);
                    SubscribeToButtonClick(toggleEntryVolumeMaxButton);
                    SubscribeToButtonClick(toggleAutoAddOnButton);
                    SubscribeToButtonClick(toggleAutoPilotProfileButton);
                    SubscribeToButtonClick(toggleTradeSignalButton);
                    SubscribeToButtonClick(toggleAutoPilotButton);


                    int gridColumnIndex = buttonGrid.ColumnDefinitions.Count - 1;

                    if (ShowButtonVolume)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleEntryVolumeAutoButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleEntryVolumeAutoButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleEntryVolumeAutoButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleEntryVolumeAutoButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleEntryVolumeAutoButton, 0);
                        toggleEntryVolumeAutoButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonVolume) gridColumnIndex--;

                    if (ShowButtonVolumeMax && LimitToVolumeMaxOption)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleEntryVolumeMaxButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleEntryVolumeMaxButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleEntryVolumeMaxButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleEntryVolumeMaxButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleEntryVolumeMaxButton, 0);
                        toggleEntryVolumeMaxButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonVolumeMax && LimitToVolumeMaxOption) gridColumnIndex--;

                    if (ShowButtonAutoPilot)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoPilotButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoPilotButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 75;
                        buttonGrid.Children.Add(toggleAutoPilotButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoPilotButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoPilotButton, 0);
                        toggleAutoPilotButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonAutoPilot) gridColumnIndex--;

                    if (ShowButtonTradeSignal && !UseAutoPilotLite)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleTradeSignalButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleTradeSignalButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleTradeSignalButton);

                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleTradeSignalButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleTradeSignalButton, 0);
                        toggleTradeSignalButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonTradeSignal && !UseAutoPilotLite) gridColumnIndex--;

                    if (ShowButtonAutoPilotProfile)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoPilotProfileButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoPilotProfileButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleAutoPilotProfileButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoPilotProfileButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoPilotProfileButton, 0);
                        toggleAutoPilotProfileButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonAutoPilotProfile) gridColumnIndex--;

                    if (ShowButtonAutoAddOn)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoAddOnButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoAddOnButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleAutoAddOnButton);

                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoAddOnButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoAddOnButton, 0);
                        toggleAutoAddOnButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonAutoAddOn) gridColumnIndex--;

                    if (ShowButtonDropPlus)
                    {
                        System.Windows.Controls.Grid.SetColumn(BuyDropButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BuyDropButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(BuyDropButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(BuyDropButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BuyDropButton, 0);
                        BuyDropButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonDropPlus) gridColumnIndex--;

                    if (ShowButtonDropMinus)
                    {
                        System.Windows.Controls.Grid.SetColumn(SellDropButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SellDropButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(SellDropButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(SellDropButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SellDropButton, 0);
                        SellDropButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonDropMinus) gridColumnIndex--;

                    if (ShowButtonPopMinus)
                    {
                        System.Windows.Controls.Grid.SetColumn(SellPopButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SellPopButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(SellPopButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(SellPopButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SellPopButton, 0);
                        SellPopButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonPopMinus) gridColumnIndex--;

                    if (ShowButtonPopPlus)
                    {
                        System.Windows.Controls.Grid.SetColumn(BuyPopButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BuyPopButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(BuyPopButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(BuyPopButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BuyPopButton, 0);
                        BuyPopButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonPopPlus) gridColumnIndex--;

                    if (ShowButtonSellMarket)
                    {
                        System.Windows.Controls.Grid.SetColumn(SellMarketButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SellMarketButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(SellMarketButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(SellMarketButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SellMarketButton, 0);
                        SellMarketButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonSellMarket) gridColumnIndex--;

                    if (ShowButtonBuyMarket)
                    {
                        System.Windows.Controls.Grid.SetColumn(BuyMarketButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BuyMarketButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(BuyMarketButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(BuyMarketButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BuyMarketButton, 0);
                        BuyMarketButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonBuyMarket) gridColumnIndex--;

                    if (ShowButtonSLPlus)
                    {
                        System.Windows.Controls.Grid.SetColumn(SLButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SLButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(SLButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(SLButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(SLButton, 0);
                        SLButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonSLPlus) gridColumnIndex--;

                    if (ShowButtonBEPlus)
                    {
                        System.Windows.Controls.Grid.SetColumn(BEButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BEButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(BEButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(BEButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(BEButton, 0);
                        BEButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonBEPlus) gridColumnIndex--;

                    if (ShowButtonTPPlus)
                    {
                        System.Windows.Controls.Grid.SetColumn(TPButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(TPButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(TPButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(TPButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(TPButton, 0);
                        TPButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonTPPlus) gridColumnIndex--;

                    if (ShowButtonProfitTarget)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleProfitTargetButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleProfitTargetButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleProfitTargetButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleProfitTargetButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleProfitTargetButton, 0);
                        toggleProfitTargetButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonProfitTarget) gridColumnIndex--;

                    if (ShowButtonAutoClose)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoCloseButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoCloseButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(toggleAutoCloseButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoCloseButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoCloseButton, 0);
                        toggleAutoCloseButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonAutoClose) gridColumnIndex--;

                    if (ShowButtonClose)
                    {
                        System.Windows.Controls.Grid.SetColumn(closeAllButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(closeAllButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(closeAllButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(closeAllButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(closeAllButton, 0);
                        closeAllButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonClose) gridColumnIndex--;

                    if (ShowButtonReverse)
                    {
                        System.Windows.Controls.Grid.SetColumn(revButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(revButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 70;
                        buttonGrid.Children.Add(revButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(revButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(revButton, 0);
                        revButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonReverse) gridColumnIndex--;

                    if (ShowButtonAutoBreakEven)
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoBEButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoBEButton, 0);
                        buttonGrid.ColumnDefinitions[gridColumnIndex].MinWidth = 75;
                        buttonGrid.Children.Add(toggleAutoBEButton);
                    }
                    else
                    {
                        System.Windows.Controls.Grid.SetColumn(toggleAutoBEButton, gridColumnIndex);
                        System.Windows.Controls.Grid.SetRow(toggleAutoBEButton, 0);
                        toggleAutoBEButton.Visibility = Visibility.Hidden;
                    }
                    if (ShowButtonAutoBreakEven) gridColumnIndex--;




                    #region LabelGrid
                    labelGrid = new System.Windows.Controls.Grid
                    {
                        Name = "HHLabelGrid",
                        Margin = new Thickness(0, 0, 0, 0),
                        HorizontalAlignment = HorizontalAlignment.Right,
                        VerticalAlignment = VerticalAlignment.Top,
                        //ShowGridLines = true,
                        Background = Brushes.Black

                    };

                    System.Windows.Controls.RowDefinition labelRow1 = new System.Windows.Controls.RowDefinition();
                    labelGrid.RowDefinitions.Add(labelRow1);

                    System.Windows.Controls.ColumnDefinition labelColumn1 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition labelColumn2 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition labelColumn3 = new System.Windows.Controls.ColumnDefinition();
                    System.Windows.Controls.ColumnDefinition labelColumn4 = new System.Windows.Controls.ColumnDefinition();

                    labelColumn1.Width = GridLength.Auto;
                    labelColumn2.Width = GridLength.Auto;
                    labelColumn3.Width = GridLength.Auto;
                    labelColumn4.Width = GridLength.Auto;

                    labelGrid.ColumnDefinitions.Add(labelColumn1);
                    labelGrid.ColumnDefinitions.Add(labelColumn2);
                    labelGrid.ColumnDefinitions.Add(labelColumn3);
                    labelGrid.ColumnDefinitions.Add(labelColumn4);

                    #endregion

                    riskInfoLabel = new System.Windows.Controls.Label
                    {
                        Name = HHRiskInfoLabelName,
                        Content = "",
                        Foreground = Brushes.White,
                        Background = Brushes.Transparent,
                        HorizontalAlignment = HorizontalAlignment.Right,
                        Margin = new Thickness(0, 0, 0, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };

                    profitInfoLabel = new System.Windows.Controls.Label
                    {
                        Name = HHProfitInfoLabelName,
                        Content = "",
                        Foreground = Brushes.White,
                        Background = Brushes.Transparent,
                        HorizontalAlignment = HorizontalAlignment.Right,
                        Margin = new Thickness(0, 0, 0, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };

                    bogeyTargetInfoLabel = new System.Windows.Controls.Label
                    {
                        Name = HHBogeyTargetInfoLabelName,
                        Content = "",
                        Foreground = Brushes.Silver,
                        Background = Brushes.Transparent,
                        HorizontalAlignment = HorizontalAlignment.Right,
                        Margin = new Thickness(0, 0, 0, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };

                    dayOverMaxLossInfoLabel = new System.Windows.Controls.Label
                    {
                        Name = HHDayOverMaxLossInfoLabelName,
                        Content = "",
                        Foreground = dayOverMaxLossInfoTextColor,
                        Background = Brushes.Transparent,
                        HorizontalAlignment = HorizontalAlignment.Right,
                        Margin = new Thickness(0, 0, 0, 0),
                        Visibility = (hasRanOnceFirstCycle) ? Visibility.Visible : Visibility.Hidden,
                    };
                    //if (IsDayOverMaxLossEnabled()) dayOverMaxLossInfoLabel.Background = Brushes.Black;


                    System.Windows.Controls.Grid.SetColumn(dayOverMaxLossInfoLabel, 3);
                    System.Windows.Controls.Grid.SetRow(dayOverMaxLossInfoLabel, 3);

                    System.Windows.Controls.Grid.SetColumn(bogeyTargetInfoLabel, 2);
                    System.Windows.Controls.Grid.SetRow(bogeyTargetInfoLabel, 2);

                    System.Windows.Controls.Grid.SetColumn(riskInfoLabel, 1);
                    System.Windows.Controls.Grid.SetRow(riskInfoLabel, 1);


                    System.Windows.Controls.Grid.SetColumn(profitInfoLabel, 0);
                    System.Windows.Controls.Grid.SetRow(profitInfoLabel, 0);

                    labelGrid.Children.Add(riskInfoLabel);
                    labelGrid.Children.Add(profitInfoLabel);
                    labelGrid.Children.Add(bogeyTargetInfoLabel);
                    labelGrid.Children.Add(dayOverMaxLossInfoLabel);



                    System.Windows.Controls.Grid.SetColumn(labelGrid, 0);
                    System.Windows.Controls.Grid.SetRow(labelGrid, 1);
                    //System.Windows.Controls.Grid.SetColumnSpan(labelGrid, buttonGrid.ColumnDefinitions.Count);

                    /*
                    System.Windows.Controls.Grid.SetColumn(riskInfoLabel, 6);
                    System.Windows.Controls.Grid.SetRow(riskInfoLabel, 1);
                    System.Windows.Controls.Grid.SetColumnSpan(riskInfoLabel, 3);

                    System.Windows.Controls.Grid.SetColumn(dayOverMaxLossInfoLabel, 10);
                    System.Windows.Controls.Grid.SetRow(dayOverMaxLossInfoLabel, 1);
                    System.Windows.Controls.Grid.SetColumnSpan(dayOverMaxLossInfoLabel, 3);
                    

                    buttonGrid.Children.Add(riskInfoLabel);
                    buttonGrid.Children.Add(dayOverMaxLossInfoLabel);
                    */

                    thLayoutGrid.Children.Add(labelGrid);

                    /*
                    buttonGrid.Children.Add(toggleAutoBEButton);
                    buttonGrid.Children.Add(revButton);
                    buttonGrid.Children.Add(closeAllButton);
                    buttonGrid.Children.Add(toggleAutoCloseButton);
                    buttonGrid.Children.Add(toggleProfitTargetButton);
                    buttonGrid.Children.Add(TPButton);
                    buttonGrid.Children.Add(BEButton);
                    buttonGrid.Children.Add(SLButton);
                    buttonGrid.Children.Add(BuyMarketButton);
                    buttonGrid.Children.Add(SellMarketButton);
                    buttonGrid.Children.Add(BuyPopButton);
                    buttonGrid.Children.Add(SellPopButton);
                    buttonGrid.Children.Add(BuyDropButton);
                    buttonGrid.Children.Add(SellDropButton);
                    buttonGrid.Children.Add(toggleAutoAddOnButton);
                    buttonGrid.Children.Add(toggleTradeSignalButton);
                    buttonGrid.Children.Add(toggleAutoPilotButton);
                    buttonGrid.Children.Add(toggleEntryVolumeAutoButton);
                    */



                    thLayoutGrid.Children.Add(buttonGrid);

                    System.Windows.Controls.Grid.SetColumn(buttonGrid, 0);
                    System.Windows.Controls.Grid.SetRow(buttonGrid, 0);

                    UserControlCollection.Add(thLayoutGrid);
                }
            }
        }

        private void SubscribeToMarketDataUpdate(Instrument instrument)
        {
            if (instrument != null)
            {
                UnsubscribeToMarketDataUpdate(instrument);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to MarketDataUpdate for " + instrument);
                WeakEventManager<Instrument, MarketDataEventArgs>.AddHandler(instrument, "MarketDataUpdate", MarketData_Update);
            }
        }

        private void UnsubscribeToMarketDataUpdate(Instrument instrument)
        {
            if (instrument != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to MarketDataUpdate for " + instrument);
                WeakEventManager<Instrument, MarketDataEventArgs>.RemoveHandler(instrument, "MarketDataUpdate", MarketData_Update);
            }
        }

        private void SubscribeToOrderUpdate(Account account)
        {
            if (account != null)
            {
                UnsubscribeToOrderUpdate(account);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to OrderUpdate for " + account);
                WeakEventManager<Account, OrderEventArgs>.AddHandler(account, "OrderUpdate", OnOrderUpdate);
            }
        }

        private void UnsubscribeToOrderUpdate(Account account)
        {
            if (account != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to OrderUpdate for " + account);
                WeakEventManager<Account, OrderEventArgs>.RemoveHandler(account, "OrderUpdate", OnOrderUpdate);
            }
        }

        private void SubscribeToExecutionUpdate(Account account)
        {
            if (account != null)
            {
                UnsubscribeToExecutionUpdate(account);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to ExecutionUpdate for " + account);
                WeakEventManager<Account, ExecutionEventArgs>.AddHandler(account, "ExecutionUpdate", OnExecutionUpdate);
            }
        }

        private void UnsubscribeToExecutionUpdate(Account account)
        {
            if (account != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to ExecutionUpdate for " + account);
                WeakEventManager<Account, ExecutionEventArgs>.RemoveHandler(account, "ExecutionUpdate", OnExecutionUpdate);
            }
        }

        private void SubscribeToPositionUpdate(Account account)
        {
            if (account != null)
            {
                UnsubscribeToPositionUpdate(account);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to PositionUpdate for " + account);
                WeakEventManager<Account, PositionEventArgs>.AddHandler(account, "PositionUpdate", OnPositionUpdate);
            }
        }

        private void UnsubscribeToPositionUpdate(Account account)
        {
            if (account != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to PositionUpdate for " + account);
                WeakEventManager<Account, PositionEventArgs>.RemoveHandler(account, "PositionUpdate", OnPositionUpdate);
            }
        }

        private void SubscribeToPreviewMouseLeftButtonDown(ChartControl chartControl)
        {
            if (chartControl != null)
            {
                UnsubscribeToPreviewMouseLeftButtonDown(chartControl);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to PreviewMouseLeftButtonDown for " + chartControl);
                WeakEventManager<ChartControl, MouseButtonEventArgs>.AddHandler(chartControl, "PreviewMouseLeftButtonDown", ChartControl_PreviewMouseLeftButtonDown);
            }
        }

        private void UnsubscribeToPreviewMouseLeftButtonDown(ChartControl chartControl)
        {
            if (chartControl != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to PreviewMouseLeftButtonDown for " + chartControl);
                WeakEventManager<ChartControl, MouseButtonEventArgs>.RemoveHandler(chartControl, "PreviewMouseLeftButtonDown", ChartControl_PreviewMouseLeftButtonDown);
            }
        }

        private void SubscribeToButtonClick(System.Windows.Controls.Button button)
        {
            if (button != null)
            {
                UnsubscribeToButtonClick(button);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to ButtonClick for " + button);
                WeakEventManager<System.Windows.Controls.Button, RoutedEventArgs>.AddHandler(button, "Click", OnButtonClick);
            }
        }

        private void UnsubscribeToButtonClick(System.Windows.Controls.Button button)
        {
            if (button != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to ButtonClick for " + button);
                WeakEventManager<System.Windows.Controls.Button, RoutedEventArgs>.RemoveHandler(button, "Click", OnButtonClick);
            }
        }

        private void SubscribeToTimerTick(System.Windows.Threading.DispatcherTimer timer)
        {
            if (timer != null)
            {
                UnsubscribeToTimerTick(timer);
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Subscribing to TimerTick for " + timer);
                WeakEventManager<System.Windows.Threading.DispatcherTimer, EventArgs>.AddHandler(timer, "Tick", OnTimerTick);
            }
        }

        private void UnsubscribeToTimerTick(System.Windows.Threading.DispatcherTimer timer)
        {
            if (timer != null)
            {
                if (this.DebugLogLevel > 90) RealLogger.PrintOutput("*** Unsubscribing to TimerTick for " + timer);
                WeakEventManager<System.Windows.Threading.DispatcherTimer, EventArgs>.RemoveHandler(timer, "Tick", OnTimerTick);
            }
        }


        private void GetBreakEvenAutoButtonText(TickHunterBreakEvenAutoTypes breakEvenAutoType, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            const string StarText = "*";
            const string AutoTrailNowText = " (AutoTrailNow)";
            const string DoubleStarText = "**";
            const string AutoTrailNowAfterProfitText = " (AutoTrailNowAfterProfit)";

            string flagActiveText = "";
            string flagActiveTextToolTip = "";

            if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.TrailNowAfterProfit)
            {
                flagActiveText = DoubleStarText;
                flagActiveTextToolTip = AutoTrailNowAfterProfitText;
            }
            else if (breakEvenAutoTrailNowFlag == TickHunterBreakEvenAutoTrailNowTypes.TrailNowBeforeBE)
            {
                flagActiveText = StarText;
                flagActiveTextToolTip = AutoTrailNowText;
            }

            if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.Enabled)
            {
                buttonText = ToggleAutoBEButtonEnabledText;
                buttonToolTipText = ToggleAutoBEButtonEnabledToolTip;
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.HODL)
            {
                buttonText = ToggleAutoBEHDLButtonEnabledText;
                buttonToolTipText = ToggleAutoBEHDLButtonEnabledToolTip;
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.CreeperZombieFlipTrail)
            {
                buttonText = ToggleCZFTButtonEnabledText;
                buttonToolTipText = ToggleCZFTButtonEnabledToolTip;
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.CreeperFlipTrail)
            {
                buttonText = string.Format(ToggleCFTButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleCFTButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrail1Bar)
            {
                buttonText = string.Format(ToggleAutoBET1BButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBET1BButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrail2Bar)
            {
                buttonText = string.Format(ToggleAutoBET2BButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBET2BButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrail3Bar)
            {
                buttonText = string.Format(ToggleAutoBET3BButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBET3BButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrail5Bar)
            {
                buttonText = string.Format(ToggleAutoBET5BButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBET5BButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailMix)
            {
                buttonText = string.Format(ToggleAutoBETMXButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETMXButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailSpeedLine)
            {
                buttonText = string.Format(ToggleAutoBETSLButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETSLButtonEnabledToolTip, flagActiveTextToolTip, this.AutoPilotSpeedLineFilterPeriod);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailRushLine)
            {
                buttonText = string.Format(ToggleAutoBETRLButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETRLButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailRLPeriod);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailRiver1)
            {
                buttonText = string.Format(ToggleAutoBETR1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETR1ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailR1Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailRiver5)
            {
                buttonText = string.Format(ToggleAutoBETR5ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETR5ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailR5Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailCreek1)
            {
                buttonText = string.Format(ToggleAutoBETC1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETC1ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailDL3Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailCreek5)
            {
                buttonText = string.Format(ToggleAutoBETC5ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETC5ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailDL4Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailKLineDual)
            {
                buttonText = string.Format(ToggleAutoBETKLDButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETKLDButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailZL2Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailZipLine2)
            {
                buttonText = string.Format(ToggleAutoBETZL2ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETZL2ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailZL2Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailZipLineDual)
            {
                buttonText = string.Format(ToggleAutoBETZLDButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETZLDButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailZL2Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailKZ)
            {
                buttonText = string.Format(ToggleAutoBETKZDButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETKZDButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailZL2Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailStingRay)
            {
                buttonText = string.Format(ToggleAutoBETSButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETSButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailMonster)
            {
                buttonText = string.Format(ToggleAutoBETMButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETMButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailDriftMonster)
            {
                buttonText = string.Format(ToggleAutoBETDMButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETDMButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage1)
            {
                buttonText = string.Format(ToggleAutoBETM1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETM1ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailMA1Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage2)
            {
                buttonText = string.Format(ToggleAutoBETM2ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETM2ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailMA2Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage3)
            {
                buttonText = string.Format(ToggleAutoBETM3ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETM3ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailMA3Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailMovingAverage4)
            {
                buttonText = string.Format(ToggleAutoBETM4ButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETM4ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailMA4Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine1)
            {
                buttonText = string.Format(ToggleAutoBETD1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoBETD1ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailDL1Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine2)
            {
                buttonText = string.Format(ToggleAutoBETD2ButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETD2ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailDL2Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine3)
            {
                buttonText = string.Format(ToggleAutoBETD3ButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETD3ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailDL3Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.PlusTrailDriftLine4)
            {
                buttonText = string.Format(ToggleAutoBETD4ButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETD4ButtonEnabledToolTip, flagActiveTextToolTip, this.AutoCloseAndTrailDL4Period);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.ZombieFlipResumeTrail)
            {
                buttonText = string.Format(ToggleAutoBETZRButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBETZRButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.ProfilePeppy)
            {
                buttonText = string.Format(ToggleAutoBEPLButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBEPLButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (breakEvenAutoType == TickHunterBreakEvenAutoTypes.ProfileSleepy)
            {
                buttonText = string.Format(ToggleAutoBEPSButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoBEPSButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else
            {
                buttonText = ToggleAutoBEButtonDisabledText;
                buttonToolTipText = ToggleAutoBEButtonDisabledToolTip;
            }
        }

        private void GetAutoCloseButtonText(TickHunterCloseAutoTypes closeAutoType, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            const string StarText = "*";
            const string MinProfitText = " (MinProfit)";

            string flagActiveText = "";
            string flagActiveTextToolTip = "";

            if (closeAutoMinProfitFlag)
            {
                flagActiveText = StarText;
                flagActiveTextToolTip = MinProfitText;
            }

            if (closeAutoType == TickHunterCloseAutoTypes.DriftLine4Break)
            {
                buttonText = string.Format(ToggleAutoCloseDL4BButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseDL4BButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.ZombieStackedFlip)
            {
                buttonText = string.Format(ToggleAutoCloseZSFButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseZSFButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.KLineDualFlip)
            {
                buttonText = string.Format(ToggleAutoCloseKLDFButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseKLDFButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.ZombieFlip)
            {
                buttonText = string.Format(ToggleAutoCloseZFButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseZFButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.ZombieBoostedFlip)
            {
                buttonText = string.Format(ToggleAutoCloseZBFButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseZBFButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.CreeperFlip)
            {
                buttonText = string.Format(ToggleAutoCloseCFButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseCFButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.ZLineDualFlip)
            {
                buttonText = string.Format(ToggleAutoCloseZLDButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseZLDButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.KZFlip)
            {
                buttonText = string.Format(ToggleAutoCloseKZButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseKZButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.MovingAverage1Slope)
            {
                buttonText = string.Format(ToggleAutoCloseM1SButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseM1SButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.MovingAverage2Slope)
            {
                buttonText = string.Format(ToggleAutoCloseM2SButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseM2SButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.MovingAverage3Slope)
            {
                buttonText = string.Format(ToggleAutoCloseM3SButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseM3SButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.MovingAverage4Break)
            {
                buttonText = string.Format(ToggleAutoCloseM4BButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoCloseM4BButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.ProfilePeppy)
            {
                buttonText = string.Format(ToggleAutoClosePLButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoClosePLButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (closeAutoType == TickHunterCloseAutoTypes.ProfileSleepy)
            {
                buttonText = string.Format(ToggleAutoClosePSButtonEnabledText, flagActiveText);
                buttonToolTipText = string.Format(ToggleAutoClosePSButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else
            {
                buttonText = ToggleAutoCloseButtonDisabledText;
                buttonToolTipText = ToggleAutoCloseButtonDisabledToolTip;
            }
        }


        private void GetPopButtonText(TickHunterPopTypes popType, TickHunterPopDelayedTypes popDelayedType, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            const string StarText = "*";
            const string LimitToPullbackText = " (LimitToPullback)";

            string flagActiveText = "";
            string flagActiveTextToolTip = "";

            if (popLimitToPullbackFlag)
            {
                flagActiveText = StarText;
                flagActiveTextToolTip = LimitToPullbackText;
            }

            if (popType == TickHunterPopTypes.PopPlus)
            {
                if (useBuyPopActivateFlag || !popCTRLDelayedEntryFlag)
                {
                    if (popDelayedType == TickHunterPopDelayedTypes.TradeCount1)
                    {
                        buttonText = String.Format(TogglePopBuyDelayedButtonCount1Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopBuyDelayedButtonCount1ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount2)
                    {
                        buttonText = String.Format(TogglePopBuyDelayedButtonCount2Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopBuyDelayedButtonCount2ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount3)
                    {
                        buttonText = String.Format(TogglePopBuyDelayedButtonCount3Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopBuyDelayedButtonCount3ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount4)
                    {
                        buttonText = String.Format(TogglePopBuyDelayedButtonCount4Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopBuyDelayedButtonCount4ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount5)
                    {
                        buttonText = String.Format(TogglePopBuyDelayedButtonCount5Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopBuyDelayedButtonCount5ToolTip, flagActiveTextToolTip);
                    }
                    else
                    {
                        buttonText = String.Format(TogglePopBuyDelayedButtonDisabledText, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopBuyDelayedButtonDisabledToolTip, flagActiveTextToolTip);
                    }
                }
                else
                {
                    buttonText = String.Format(TogglePopBuyButtonText, flagActiveText);
                    buttonToolTipText = String.Format(TogglePopBuyButtonToolTip, flagActiveTextToolTip);
                }

            }
            else if (popType == TickHunterPopTypes.PopMinus)
            {

                if (useSellPopActivateFlag || !popCTRLDelayedEntryFlag)
                {
                    if (popDelayedType == TickHunterPopDelayedTypes.TradeCount1)
                    {
                        buttonText = String.Format(TogglePopSellDelayedButtonCount1Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopSellDelayedButtonCount1ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount2)
                    {
                        buttonText = String.Format(TogglePopSellDelayedButtonCount2Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopSellDelayedButtonCount2ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount3)
                    {
                        buttonText = String.Format(TogglePopSellDelayedButtonCount3Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopSellDelayedButtonCount3ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount4)
                    {
                        buttonText = String.Format(TogglePopSellDelayedButtonCount4Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopSellDelayedButtonCount4ToolTip, flagActiveTextToolTip);
                    }
                    else if (popDelayedType == TickHunterPopDelayedTypes.TradeCount5)
                    {
                        buttonText = String.Format(TogglePopSellDelayedButtonCount5Text, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopSellDelayedButtonCount5ToolTip, flagActiveTextToolTip);
                    }
                    else
                    {
                        buttonText = String.Format(TogglePopSellDelayedButtonDisabledText, flagActiveText);
                        buttonToolTipText = String.Format(TogglePopSellDelayedButtonDisabledToolTip, flagActiveTextToolTip);
                    }
                }
                else
                {
                    buttonText = String.Format(TogglePopSellButtonText, flagActiveText);
                    buttonToolTipText = String.Format(TogglePopSellButtonToolTip, flagActiveTextToolTip);
                }
            }
        }

        private void GetAutoPilotProfileButtonText(TickHunterAutoPilotProfileTypes autoPilotProfileType, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            const string StarText = "*";

            string flagActiveText = "";

            if (autoPilotProfileAutoAdjustFlag)
            {
                flagActiveText = StarText;
            }

            if (autoPilotProfileType == TickHunterAutoPilotProfileTypes.Peppy)
            {
                buttonText = String.Format(ToggleAutoPPPButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPPPButtonEnabledToolTip, flagActiveText);
            }
            else if (autoPilotProfileType == TickHunterAutoPilotProfileTypes.Sleepy)
            {
                buttonText = String.Format(ToggleAutoPPSButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPPSButtonEnabledToolTip, flagActiveText);
            }
            else
            {
                buttonText = ToggleAutoPPButtonDisabledText;
                buttonToolTipText = ToggleAutoPPButtonDisabledToolTip;
            }
        }

        private void GetAutoPilotButtonText(TickHunterAutoPilotTypes autoPilotType, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            const string StarText = "*";
            const string AutoPilotAddOnText = " (AutoPilotAddOn)";


            string flagActiveText = "";
            string flagActiveTextToolTip = "";

            if (useAutoPilotAddOnFlag)
            {
                flagActiveText = StarText;
                flagActiveTextToolTip = AutoPilotAddOnText;
            }

            if (autoPilotType == TickHunterAutoPilotTypes.TradeCount1)
            {
                buttonText = String.Format(ToggleAutoPilotCount1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount1ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount2)
            {
                buttonText = String.Format(ToggleAutoPilotCount2ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount2ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount3)
            {
                buttonText = String.Format(ToggleAutoPilotCount3ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount3ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount4)
            {
                buttonText = String.Format(ToggleAutoPilotCount4ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount4ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount5)
            {
                buttonText = String.Format(ToggleAutoPilotCount5ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount5ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount6)
            {
                buttonText = String.Format(ToggleAutoPilotCount6ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount6ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount7)
            {
                buttonText = String.Format(ToggleAutoPilotCount7ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount7ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount8)
            {
                buttonText = String.Format(ToggleAutoPilotCount8ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount8ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount9)
            {
                buttonText = String.Format(ToggleAutoPilotCount9ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount9ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotType == TickHunterAutoPilotTypes.TradeCount10)
            {
                buttonText = String.Format(ToggleAutoPilotCount10ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotCount10ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else
            {
                buttonText = ToggleAutoPilotButtonDisabledText;
                buttonToolTipText = ToggleAutoPilotButtonDisabledToolTip;
            }

        }

        private void GetAutoPilotLiteButtonText(TickHunterAutoPilotLiteTypes autoPilotLiteType, out string buttonText, out string buttonToolTipText)
        {
            buttonText = "";
            buttonToolTipText = "";

            const string StarText = "*";
            const string AutoPilotAddOnText = " (AutoPilotAddOn)";


            string flagActiveText = "";
            string flagActiveTextToolTip = "";

            if (useAutoPilotAddOnFlag)
            {
                flagActiveText = StarText;
                flagActiveTextToolTip = AutoPilotAddOnText;
            }

            if (autoPilotLiteType == TickHunterAutoPilotLiteTypes.NextSetup)
            {
                buttonText = String.Format(ToggleAutoPilotLiteNext1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotLiteNext1ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotLiteType == TickHunterAutoPilotLiteTypes.NextFilteredSetup)
            {
                buttonText = String.Format(ToggleAutoPilotLiteNextFiltered1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotLiteNextFiltered1ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotLiteType == TickHunterAutoPilotLiteTypes.BuySetup)
            {
                buttonText = String.Format(ToggleAutoPilotLiteBuy1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotLiteBuy1ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotLiteType == TickHunterAutoPilotLiteTypes.SellSetup)
            {
                buttonText = String.Format(ToggleAutoPilotLiteSell1ButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotLiteSell1ButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else if (autoPilotLiteType == TickHunterAutoPilotLiteTypes.AlertSetup)
            {
                buttonText = String.Format(ToggleAutoPilotLiteAlertButtonEnabledText, flagActiveText);
                buttonToolTipText = String.Format(ToggleAutoPilotLiteAlertButtonEnabledToolTip, flagActiveTextToolTip);
            }
            else
            {
                buttonText = ToggleAutoPilotLiteButtonDisabledText;
                buttonToolTipText = ToggleAutoPilotLiteButtonDisabledToolTip;
            }

        }


        private bool HasATMStrategy()
        {
            return !string.IsNullOrEmpty(atmStrategyName);
        }

        private void ValidateInstrument(string instrumentName)
        {
            Instrument instrument = Instrument.GetInstrument(instrumentName);
            if (instrument != null)
            {
                RealLogger.PrintOutput("Instrument =" + instrument.FullName + " Tick Size=" + Convert.ToString(instrument.MasterInstrument.TickSize) + " Tick Value=" + Convert.ToString(RealInstrumentService.GetTickValue(instrument)), PrintTo.OutputTab2);
            }
        }

        private string GetCurrentFuturesMonthYearPrefix()
        {
            string tempText = null;

            if (attachedInstrumentIsFuture)
            {
                tempText = this.attachedInstrument.FullName.Substring(this.attachedInstrument.MasterInstrument.Name.Length, 6);
            }
            return tempText;
        }

        private bool IsCtrlKeyDown()
        {
            bool returnFlag = false;

            if (Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl))
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        private bool IsShiftKeyDown()
        {
            bool returnFlag = false;

            if (Keyboard.IsKeyDown(Key.LeftShift) || Keyboard.IsKeyDown(Key.RightShift))
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        #region Properties

        [NinjaScriptProperty]
        [Display(Name = "IndicatorName", Order = 0, GroupName = "0) Indicator Information")]
        public string IndicatorName
        {
            get { return FullSystemName; }
            set { }
        }

        [NinjaScriptProperty]
        [Display(Name = "IndicatorTermsOfUse", Description = SystemDescription, Order = 1, GroupName = "0) Indicator Information")]
        public string IndicatorTermsOfUse
        {
            get { return SystemDescription; }
            set { }
        }

        [NinjaScriptProperty]
        [Display(Name = "ShowIndicatorName", Order = 2, GroupName = "0) Indicator Information")]
        public bool ShowIndicatorName
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "IndicatorInfoLink", Order = 2, GroupName = "0) Indicator Information")]
        public string IndicatorInfoLink
        {
            get { return InfoLink; }
            set { }
        }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoPositionStopLoss", Order = 0, GroupName = "01) Stop Loss Settings")]
        public bool UseAutoPositionStopLoss
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "StopLossInitialTicks", Order = 1, GroupName = "01) Stop Loss Settings")]
        public int StopLossInitialTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "StopLossInitialATRMultiplier", Order = 2, GroupName = "01) Stop Loss Settings")]
        public double StopLossInitialATRMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "StopLossInitialSnapType", Order = 3, GroupName = "01) Stop Loss Settings")]
        public TickHunterStopLossSnapTypes StopLossInitialSnapType
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "StopLossInitialMaxTicks", Order = 4, GroupName = "01) Stop Loss Settings")]
        public int StopLossInitialMaxTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "StopLossInitialDollars", Order = 5, GroupName = "01) Stop Loss Settings")]
        public double StopLossInitialDollars
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "StopLossInitialDollarsCombined", Order = 6, GroupName = "01) Stop Loss Settings")]
        public bool StopLossInitialDollarsCombined
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "StopLossJumpTicks", Order = 7, GroupName = "01) Stop Loss Settings")]
        public int StopLossJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "StopLossCTRLJumpTicks", Order = 8, GroupName = "01) Stop Loss Settings")]
        public bool StopLossCTRLJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "StopLossRefreshOnVolumeChange", Order = 9, GroupName = "01) Stop Loss Settings")]
        public bool StopLossRefreshOnVolumeChange
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "StopLossRefreshManagementEnabled ", Order = 10, GroupName = "01) Stop Loss Settings")]
        public bool StopLossRefreshManagementEnabled
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoPositionTakeProfit", Order = 0, GroupName = "02) Take Profit Settings")]
        public bool UseAutoPositionTakeProfit
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "TakeProfitInitialTicks", Order = 1, GroupName = "02) Take Profit Settings")]
        public int TakeProfitInitialTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "TakeProfitInitialATRMultiplier", Order = 2, GroupName = "02) Take Profit Settings")]
        public double TakeProfitInitialATRMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "TakeProfitSyncBogeyTargetPrice", Order = 3, GroupName = "02) Take Profit Settings")]
        public bool TakeProfitSyncBogeyTargetPrice
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "TakeProfitSyncECATargetPrice", Order = 4, GroupName = "02) Take Profit Settings")]
        public bool TakeProfitSyncECATargetPrice
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "TakeProfitJumpTicks", Order = 5, GroupName = "02) Take Profit Settings")]
        public int TakeProfitJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.1, double.MaxValue)]
        [Display(Name = "TakeProfitCtrlSLMultiplier", Order = 6, GroupName = "02) Take Profit Settings")]
        public double TakeProfitCtrlSLMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "TakeProfitRefreshManagementEnabled", Order = 7, GroupName = "02) Take Profit Settings")]
        public bool TakeProfitRefreshManagementEnabled
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "AutoPositionBreakEvenType", Order = 0, GroupName = "03) Break-Even Settings")]
        public TickHunterBreakEvenAutoTypes AutoPositionBreakEvenType
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "BreakEvenInitialTicks", Order = 1, GroupName = "03) Break-Even Settings")]
        public int BreakEvenInitialTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "BreakEvenJumpTicks", Order = 2, GroupName = "03) Break-Even Settings")]
        public int BreakEvenJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "BreakEvenTurboJumpTicks", Order = 3, GroupName = "03) Break-Even Settings")]
        public int BreakEvenTurboJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "BreakEvenAutoTrailNow", Order = 4, GroupName = "03) Break-Even Settings")]
        public TickHunterBreakEvenAutoTrailNowTypes BreakEvenAutoTrailNow
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "BreakEvenAutoTriggerTicks", Order = 6, GroupName = "03) Break-Even Settings")]
        public int BreakEvenAutoTriggerTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "BreakEvenAutoTriggerATRMultiplier", Order = 7, GroupName = "03) Break-Even Settings")]
        public double BreakEvenAutoTriggerATRMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "BreakEvenAutoZombieFlipResumeSnapType", Order = 8, GroupName = "03) Break-Even Settings")]
        public TickHunterStopLossSnapTypes BreakEvenAutoZombieFlipResumeSnapType
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "BreakEvenAutoCreeperFlipSnapType", Order = 9, GroupName = "03) Break-Even Settings")]
        public TickHunterStopLossSnapTypes BreakEvenAutoCreeperFlipSnapType
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "UseIntradayMarginCheck", Order = 0, GroupName = "04) Buy/Sell Settings")]
        public bool UseIntradayMarginCheck
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "LimitTrancheVolumeToInProfit", Order = 1, GroupName = "04) Buy/Sell Settings")]
        public bool LimitTrancheVolumeToInProfit
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "LimitToVolumeMaxOption", Order = 2, GroupName = "04) Buy/Sell Settings")]
        public bool LimitToVolumeMaxOption
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "EntryVolumeMaxOption1", Order = 3, GroupName = "04) Buy/Sell Settings")]
        public int EntryVolumeMaxOption1
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "EntryVolumeMaxOption2", Order = 4, GroupName = "04) Buy/Sell Settings")]
        public int EntryVolumeMaxOption2
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "EntryVolumeMaxOption3", Order = 5, GroupName = "04) Buy/Sell Settings")]
        public int EntryVolumeMaxOption3
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "EntryVolumeMaxOption4", Order = 6, GroupName = "04) Buy/Sell Settings")]
        public int EntryVolumeMaxOption4
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "EntryVolumeMaxOption5", Order = 7, GroupName = "04) Buy/Sell Settings")]
        public int EntryVolumeMaxOption5
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "MaxInitialTrancheVolumeSize", Order = 8, GroupName = "04) Buy/Sell Settings")]
        public int MaxInitialTrancheVolumeSize
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "LimitTrancheVolumePerBar", Order = 9, GroupName = "04) Buy/Sell Settings")]
        public bool LimitTrancheVolumePerBar
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "MinTrancheVolumeDelaySeconds", Order = 10, GroupName = "04) Buy/Sell Settings")]
        public int MinTrancheVolumeDelaySeconds
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "UsePopCTRLDelayedEntry", Order = 0, GroupName = "05) Pop/Drop Settings")]
        public bool UsePopCTRLDelayedEntry
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePopLimitToPullback", Order = 1, GroupName = "05) Pop/Drop Settings")]
        public bool UsePopLimitToPullback
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, 5)]
        [Display(Name = "PopDelayedEntryMaxCount", Order = 2, GroupName = "05) Pop/Drop Settings")]
        public int PopDelayedEntryMaxCount
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "PopInitialTicks", Order = 3, GroupName = "05) Pop/Drop Settings")]
        public int PopInitialTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "PopInitialATRMultiplier", Order = 4, GroupName = "05) Pop/Drop Settings")]
        public double PopInitialATRMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "PopJumpTicks", Order = 5, GroupName = "05) Pop/Drop Settings")]
        public int PopJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePopAutoJumpToSnap", Order = 6, GroupName = "05) Pop/Drop Settings")]
        public bool UsePopAutoJumpToSnap
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "DropInitialTicks", Order = 7, GroupName = "05) Pop/Drop Settings")]
        public int DropInitialTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "DropInitialATRMultiplier", Order = 8, GroupName = "05) Pop/Drop Settings")]
        public double DropInitialATRMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "DropJumpTicks", Order = 9, GroupName = "05) Pop/Drop Settings")]
        public int DropJumpTicks
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseDropAutoJumpToSnap", Order = 10, GroupName = "05) Pop/Drop Settings")]
        public bool UseDropAutoJumpToSnap
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePopDropOnBarUpdateDelay", Order = 11, GroupName = "05) Pop/Drop Settings")]
        public bool UsePopDropOnBarUpdateDelay
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, long.MaxValue)]
        [Display(Name = "PopDropThrottleMilliseconds", Order = 12, GroupName = "05) Pop/Drop Settings")]
        public long PopDropThrottleMilliseconds
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "AutoEntryVolumeType", Order = 0, GroupName = "06) Volume Settings")]
        public TickHunterEntryVolumeAutoTypes AutoEntryVolumeType
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoEntryVolumeOption1", Order = 1, GroupName = "06) Volume Settings")]
        public int AutoEntryVolumeOption1
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoEntryVolumeOption2", Order = 2, GroupName = "06) Volume Settings")]
        public int AutoEntryVolumeOption2
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoEntryVolumeOption3", Order = 3, GroupName = "06) Volume Settings")]
        public int AutoEntryVolumeOption3
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoEntryVolumeOption4", Order = 4, GroupName = "06) Volume Settings")]
        public int AutoEntryVolumeOption4
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoEntryVolumeOption5", Order = 5, GroupName = "06) Volume Settings")]
        public int AutoEntryVolumeOption5
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "AutoPilotOrderType", Order = 0, GroupName = "07) AutoPilot Settings")]
        public TickHunterAutoPilotOrderTypes AutoPilotOrderType
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "AutoPilotTradeSignalType", Order = 1, GroupName = "07) AutoPilot Settings")]
        public TickHunterTradeSignalTypes AutoPilotTradeSignalType
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "AutoPilotSetupTypes", Order = 2, GroupName = "07) AutoPilot Settings")]
        public TickHunterAutoPilotSetupTypes AutoPilotSetupType
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoPilotLite", Order = 4, GroupName = "07) AutoPilot Settings")]
        public bool UseAutoPilotLite
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoPilotAddOn", Order = 5, GroupName = "07) AutoPilot Settings")]
        public bool UseAutoPilotAddOn
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "AutoPilotMaxVolume", Order = 6, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoPilotSpeedLineFilter", Order = 7, GroupName = "07) AutoPilot Settings")]
        public bool UseAutoPilotSpeedLineFilter
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSpeedLineFilterPeriod", Order = 8, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSpeedLineFilterPeriod
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSetupFilterPeriod", Order = 9, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSetupFilterPeriod
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSetupZombiePeriod", Order = 10, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSetupZombiePeriod
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "AutoPilotSetupZombieMultiplier", Order = 11, GroupName = "07) AutoPilot Settings")]
        public double AutoPilotSetupZombieMultiplier
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSetupCreeperPeriod1", Order = 12, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSetupCreeperPeriod1
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSetupCreeperPeriod2", Order = 13, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSetupCreeperPeriod2
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSetupCreeperPeriod3", Order = 14, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSetupCreeperPeriod3
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoPilotSetupWalkerPeriod", Order = 15, GroupName = "07) AutoPilot Settings")]
        public int AutoPilotSetupWalkerPeriod
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "AutoPilotSetupWalkerFreshCrossOnly", Order = 16, GroupName = "07) AutoPilot Settings")]
        public bool AutoPilotSetupWalkerFreshCrossOnly
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "AutoPilotProfileSetupTypes", Order = 0, GroupName = "08) AutoPilot Profile Settings")]
        public TickHunterAutoPilotProfileSetupTypes AutoPilotProfileSetupType
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePeppyLimitPopDelayedEntry", Order = 1, GroupName = "08) AutoPilot Profile Settings")]
        public bool UsePeppyLimitPopDelayedEntry
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePeppyLimitPopToPullback", Order = 2, GroupName = "08) AutoPilot Profile Settings")]
        public bool UsePeppyLimitPopToPullback
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePeppyLimitPopAlignedCreeper", Order = 3, GroupName = "08) AutoPilot Profile Settings")]
        public bool UsePeppyLimitPopAlignedCreeper
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UsePeppyLimitPopAlignedRushLine", Order = 4, GroupName = "08) AutoPilot Profile Settings")]
        public bool UsePeppyLimitPopAlignedRushLine
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseSleepyLimitPopDelayedEntry", Order = 5, GroupName = "08) AutoPilot Profile Settings")]
        public bool UseSleepyLimitPopDelayedEntry
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseSleepyLimitPopToPullback", Order = 6, GroupName = "08) AutoPilot Profile Settings")]
        public bool UseSleepyLimitPopToPullback
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseSleepyLimitPopCounterCreeper", Order = 7, GroupName = "08) AutoPilot Profile Settings")]
        public bool UseSleepyLimitPopCounterCreeper
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseSleepyLimitPopCounterRushLine", Order = 8, GroupName = "08) AutoPilot Profile Settings")]
        public bool UseSleepyLimitPopCounterRushLine
        { get; set; }



        [NinjaScriptProperty]
        [Display(Name = "AutoPositionCloseType", Order = 0, GroupName = "09) Auto Close Settings")]
        public TickHunterCloseAutoTypes AutoPositionCloseType
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoCloseMinProfit", Order = 1, GroupName = "09) Auto Close Settings")]
        public bool UseAutoCloseMinProfit
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "AutoCloseMinProfitDollarsPerVolume", Order = 2, GroupName = "09) Auto Close Settings")]
        public double AutoCloseMinProfitDollarsPerVolume
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAutoCloseAlert", Order = 3, GroupName = "09) Auto Close Settings")]
        public bool UseAutoCloseAlert
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailOffsetTicks", Order = 4, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailOffsetTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailMA1Period", Order = 5, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailMA1Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailMA2Period", Order = 6, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailMA2Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailMA3Period", Order = 7, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailMA3Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailMA4Period", Order = 8, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailMA4Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailZL1Period", Order = 9, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailZL1Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailZL2Period", Order = 10, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailZL2Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailRLPeriod", Order = 11, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailRLPeriod
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailDL1Period", Order = 12, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailDL1Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailDL2Period", Order = 13, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailDL2Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailDL3Period", Order = 14, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailDL3Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailDL4Period", Order = 15, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailDL4Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailR1Period", Order = 16, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailR1Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailR5Period", Order = 17, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailR5Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailKLine1Period", Order = 18, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailKLine1Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "AutoCloseAndTrailKLine1Multiplier", Order = 19, GroupName = "09) Auto Close Settings")]
        public double AutoCloseAndTrailKLine1Multiplier
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "AutoCloseAndTrailKLine2Period", Order = 20, GroupName = "09) Auto Close Settings")]
        public int AutoCloseAndTrailKLine2Period
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "AutoCloseAndTrailKLine2Multiplier", Order = 21, GroupName = "09) Auto Close Settings")]
        public double AutoCloseAndTrailKLine2Multiplier
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "BogeyTargetStartWithFullPnL", Order = 0, GroupName = "10) Bogey Target Settings")]
        public bool BogeyTargetStartWithFullPnL
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "BogeyTargetBaseDollars", Order = 1, GroupName = "10) Bogey Target Settings")]
        public double BogeyTargetBaseDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.0, double.MaxValue)]
        [Display(Name = "BogeyTargetDailyBaseDollars", Order = 2, GroupName = "10) Bogey Target Settings")]
        public double BogeyTargetDailyBaseDollars
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowBogeyTargetDailyBreakEvenLine", Order = 3, GroupName = "10) Bogey Target Settings")]
        public bool ShowBogeyTargetDailyBreakEvenLine
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowBogeyTargetDaily1Line", Order = 4, GroupName = "10) Bogey Target Settings")]
        public bool ShowBogeyTargetDaily1Line
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowBogeyTargetDaily2Line", Order = 5, GroupName = "10) Bogey Target Settings")]
        public bool ShowBogeyTargetDaily2Line
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowBogeyTargetDaily3Line", Order = 6, GroupName = "10) Bogey Target Settings")]
        public bool ShowBogeyTargetDaily3Line
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowBogeyTargetDaily4Line", Order = 7, GroupName = "10) Bogey Target Settings")]
        public bool ShowBogeyTargetDaily4Line
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowBogeyTargetDaily5Line", Order = 8, GroupName = "10) Bogey Target Settings")]
        public bool ShowBogeyTargetDaily5Line
        { get; set; }


        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "ECATargetDollars", Order = 0, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerOtherVolume", Order = 1, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerOtherVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerMNQVolume", Order = 3, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerMNQVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerNQVolume", Order = 4, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerNQVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerM2KVolume", Order = 5, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerM2KVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerRTYVolume", Order = 6, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerRTYVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerMESVolume", Order = 7, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerMESVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerESVolume", Order = 8, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerESVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerMYMVolume", Order = 9, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerMYMVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(Name = "ECATargetDollarsPerYMVolume", Order = 10, GroupName = "11) ECA Target Settings")]
        public double ECATargetDollarsPerYMVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "ECATargetATRMultiplierPerVolume", Order = 11, GroupName = "11) ECA Target Settings")]
        public double ECATargetATRMultiplierPerVolume
        { get; set; }


        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "AutoAddOnMaxDollars", Order = 0, GroupName = "12) Auto Entry Settings")]
        public double AutoAddOnMaxDollars
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "UseDayOverMaxLossTrailing", Order = 0, GroupName = "13) Account Risk Settings")]
        public bool UseDayOverMaxLossTrailing
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "DayOverMaxLossDollars", Order = 1, GroupName = "13) Account Risk Settings")]
        public double DayOverMaxLossDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "DayOverMaxLossBTBaseRatio", Order = 2, GroupName = "13) Account Risk Settings")]
        public double DayOverMaxLossBTBaseRatio
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "DayOverMaxAccountPnLPeakDollars", Order = 3, GroupName = "13) Account Risk Settings")]
        public double DayOverMaxAccountPnLPeakDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "DayOverAccountBalanceFloorDollars", Order = 4, GroupName = "13) Account Risk Settings")]
        public double DayOverAccountBalanceFloorDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "ECAMaxDDInDollars", Order = 5, GroupName = "13) Account Risk Settings")]
        public double ECAMaxDDInDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, double.MaxValue)]
        [Display(Name = "ExcessIntradayMarginMinDollars", Order = 6, GroupName = "13) Account Risk Settings")]
        public double ExcessIntradayMarginMinDollars
        { get; set; }


        [Display(ResourceType = typeof(Custom.Resource), Name = "PlaySoundOnSetupAlert", Order = 0, GroupName = "14) Sound Alert Settings")]
        public bool PlaySoundOnSetupAlert
        {
            get; set;
        }

        [Display(ResourceType = typeof(Custom.Resource), Name = "SoundFile", Order = 1, GroupName = "14) Sound Alert Settings")]
        [PropertyEditor("NinjaTrader.Gui.Tools.FilePathPicker", Filter = "Any Files (*.wav)|*.wav")]
        public string SoundFile
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "ShowButtonAutoBreakEven", Order = 1, GroupName = "15) Button Settings")]
        public bool ShowButtonAutoBreakEven
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonReverse", Order = 2, GroupName = "15) Button Settings")]
        public bool ShowButtonReverse
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonClose", Order = 3, GroupName = "15) Button Settings")]
        public bool ShowButtonClose
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonAutoClose", Order = 4, GroupName = "15) Button Settings")]
        public bool ShowButtonAutoClose
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonProfitTarget", Order = 5, GroupName = "15) Button Settings")]
        public bool ShowButtonProfitTarget
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonTPPlus", Order = 6, GroupName = "15) Button Settings")]
        public bool ShowButtonTPPlus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonBEPlus", Order = 7, GroupName = "15) Button Settings")]
        public bool ShowButtonBEPlus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonSLPlus", Order = 8, GroupName = "15) Button Settings")]
        public bool ShowButtonSLPlus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonBuyMarket", Order = 9, GroupName = "15) Button Settings")]
        public bool ShowButtonBuyMarket
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonSellMarket", Order = 10, GroupName = "15) Button Settings")]
        public bool ShowButtonSellMarket
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonPopPlus", Order = 11, GroupName = "15) Button Settings")]
        public bool ShowButtonPopPlus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonPopMinus", Order = 12, GroupName = "15) Button Settings")]
        public bool ShowButtonPopMinus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonDropMinus", Order = 13, GroupName = "15) Button Settings")]
        public bool ShowButtonDropMinus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonDropPlus", Order = 14, GroupName = "15) Button Settings")]
        public bool ShowButtonDropPlus
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonAutoAddOn", Order = 15, GroupName = "15) Button Settings")]
        public bool ShowButtonAutoAddOn
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonTradeSignal", Order = 16, GroupName = "15) Button Settings")]
        public bool ShowButtonTradeSignal
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonAutoPilotProfile", Order = 17, GroupName = "15) Button Settings")]
        public bool ShowButtonAutoPilotProfile
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonAutoPilot", Order = 18, GroupName = "15) Button Settings")]
        public bool ShowButtonAutoPilot
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonVolumeMax", Order = 19, GroupName = "15) Button Settings")]
        public bool ShowButtonVolumeMax
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowButtonVolume", Order = 20, GroupName = "15) Button Settings")]
        public bool ShowButtonVolume
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "UseBlendedInstruments", Order = 0, GroupName = "16) Instrument Settings")]
        public bool UseBlendedInstruments
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "ShowAveragePriceLine", Order = 1, GroupName = "16) Instrument Settings")]
        public bool ShowAveragePriceLine
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowAveragePriceLineQuantity", Order = 2, GroupName = "16) Instrument Settings")]
        public bool ShowAveragePriceLineQuantity
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "ShowAveragePriceLineQuantityInMicros", Order = 3, GroupName = "16) Instrument Settings")]
        public bool ShowAveragePriceLineQuantityInMicros
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 4, GroupName = "16) Instrument Settings")]
        public double OtherCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 5, GroupName = "16) Instrument Settings")]
        public double OtherIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 6, GroupName = "16) Instrument Settings")]
        public int OtherPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 7, GroupName = "16) Instrument Settings")]
        public double MNQCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 8, GroupName = "16) Instrument Settings")]
        public double MNQIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 9, GroupName = "16) Instrument Settings")]
        public int MNQPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 10, GroupName = "16) Instrument Settings")]
        public double NQCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 11, GroupName = "16) Instrument Settings")]
        public double NQIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 12, GroupName = "16) Instrument Settings")]
        public int NQPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 13, GroupName = "16) Instrument Settings")]
        public double MESCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 14, GroupName = "16) Instrument Settings")]
        public double MESIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 15, GroupName = "16) Instrument Settings")]
        public int MESPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 16, GroupName = "16) Instrument Settings")]
        public double ESCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 17, GroupName = "16) Instrument Settings")]
        public double ESIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 18, GroupName = "16) Instrument Settings")]
        public int ESPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 19, GroupName = "16) Instrument Settings")]
        public double MYMCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 20, GroupName = "16) Instrument Settings")]
        public double MYMIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 21, GroupName = "16) Instrument Settings")]
        public int MYMPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 22, GroupName = "16) Instrument Settings")]
        public double YMCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 23, GroupName = "16) Instrument Settings")]
        public double YMIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 24, GroupName = "16) Instrument Settings")]
        public int YMPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 25, GroupName = "16) Instrument Settings")]
        public double M2KCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 26, GroupName = "16) Instrument Settings")]
        public double M2KIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 27, GroupName = "16) Instrument Settings")]
        public int M2KPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 28, GroupName = "16) Instrument Settings")]
        public double RTYCommissionPerSide
        { get; set; }

        [NinjaScriptProperty]
        [Range(0.01, double.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 29, GroupName = "16) Instrument Settings")]
        public double RTYIntradayMarginDollars
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(ResourceType = typeof(Custom.Resource), Order = 30, GroupName = "16) Instrument Settings")]
        public int RTYPositionMaxVolume
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "IgnoreInstrumentServerSupport", Order = 31, GroupName = "16) Instrument Settings")]
        public bool IgnoreInstrumentServerSupport
        { get; set; }








        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "SnapOffsetTicks", Order = 0, GroupName = "17) Misc Settings")]
        public int SnapOffsetTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(2, int.MaxValue)]
        [Display(Name = "SnapPowerBoxPeriod", Order = 1, GroupName = "17) Misc Settings")]
        public int SnapPowerBoxPeriod
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "SnapPowerBoxAutoAdjustPeriodsOnM1", Order = 2, GroupName = "17) Misc Settings")]
        public bool SnapPowerBoxAutoAdjustPeriodsOnM1
        { get; set; }

        [NinjaScriptProperty]
        [Range(2, int.MaxValue)]
        [Display(Name = "ATRPeriod", Order = 3, GroupName = "17) Misc Settings")]
        public int ATRPeriod
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "RefreshTPSLOffsetTicks", Order = 4, GroupName = "17) Misc Settings")]
        public int RefreshTPSLOffsetTicks
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "RefreshTPSLOrderDelaySeconds", Order = 5, GroupName = "17) Misc Settings")]
        public int RefreshTPSLOrderDelaySeconds
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "SingleOrderChunkMaxQuantity", Order = 6, GroupName = "17) Misc Settings")]
        public int SingleOrderChunkMaxQuantity
        { get; set; }

        [NinjaScriptProperty]
        [Range(1, int.MaxValue)]
        [Display(Name = "SingleOrderChunkMinQuantity", Order = 7, GroupName = "17) Misc Settings")]
        public int SingleOrderChunkMinQuantity
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "SingleOrderChunkDelayMilliseconds", Order = 8, GroupName = "17) Misc Settings")]
        public int SingleOrderChunkDelayMilliseconds
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, long.MaxValue)]
        [Display(Name = "RealTimePipeLineThrottleMilliseconds", Order = 9, GroupName = "17) Misc Settings")]
        public long RealTimePipeLineThrottleMilliseconds
        { get; set; }


        [NinjaScriptProperty]
        [Display(Name = "UsePositionProfitLogging", Order = 1, GroupName = "18) Output Log Settings")]
        public bool UsePositionProfitLogging
        { get; set; }

        [NinjaScriptProperty]
        [Range(0, int.MaxValue)]
        [Display(Name = "DebugLogLevel", Order = 2, GroupName = "18) Output Log Settings")]
        public int DebugLogLevel
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "OrderWaitOutputThrottleSeconds", Order = 3, GroupName = "18) Output Log Settings")]
        public int OrderWaitOutputThrottleSeconds
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "UseAccountInfoLogging", Order = 1, GroupName = "19) Account Logging Settings")]
        public bool UseAccountInfoLogging
        { get; set; }

        [NinjaScriptProperty]
        [Display(Name = "AccountInfoLoggingPath", Order = 2, GroupName = "19) Account Logging Settings")]
        public string AccountInfoLoggingPath
        { get; set; }


        #endregion

    }
}

namespace NinjaTrader.NinjaScript.Indicators.TickHunterTA.TH
{
    public class RealSessionState
    {
        public long AccountId
        { get; set; }

        public DateTime ChangeDate
        { get; set; }

        public double HighestPnL
        { get; set; }

    }

    public class RealRunOncePerBar
    {
        private bool isNewBar = false;

        public bool IsFirstRunThisBar
        {
            get
            {
                return isNewBar;
            }
        }

        public void SetRunCompletedThisBar()
        {
            isNewBar = false;
        }

        public void SetNewBar()
        {
            isNewBar = true;
        }
    }

    public class RealUtility
    {

    }
    public class RealLogger
    {
        private string systemName = String.Empty;
        private int lastPrintOutputHashCode = 0;
        private const int delaySeconds = 1;
        private DateTime lastCheckTime = DateTime.MinValue;
        private DateTime lastRunTime = DateTime.MinValue;
        public RealLogger(string systemName)
        {
            this.systemName = systemName;
        }

        public void PrintOutput(string output, PrintTo outputTab = PrintTo.OutputTab1, bool blockDuplicateMessages = false, bool throttleEverySecond = false)
        {
            bool outputNow = true;

            if (throttleEverySecond)
            {
                lastCheckTime = DateTime.Now;

                if (lastCheckTime > lastRunTime)
                { outputNow = true; }
                else
                { outputNow = false; }
            }

            if (outputNow)
            {
                if (blockDuplicateMessages)
                {
                    int tempHashCode = output.GetHashCode();
                    if (tempHashCode != lastPrintOutputHashCode)
                    {
                        lastPrintOutputHashCode = tempHashCode;
                        lastRunTime = DateTime.Now.AddSeconds(delaySeconds);
                        Output.Process(DateTime.Now + " " + systemName + ": " + output, outputTab);
                    }
                }
                else
                {
                    lastRunTime = DateTime.Now.AddSeconds(delaySeconds);
                    Output.Process(DateTime.Now + " " + systemName + ": " + output, outputTab);
                }
            }
        }
    }
    public class RealInstrumentService
    {
        private readonly ConcurrentDictionary<string, double> askPriceCache = new ConcurrentDictionary<string, double>();
        private readonly ConcurrentDictionary<string, double> bidPriceCache = new ConcurrentDictionary<string, double>();
        private readonly ConcurrentDictionary<string, double> lastPriceCache = new ConcurrentDictionary<string, double>();
        private readonly Dictionary<double, int> tickSizeDecimalPlaceCountCache = new Dictionary<double, int>();

        private string BuildKeyName(Instrument instrument)
        {
            string keyName = instrument.FullName;

            return keyName;
        }

        public double NormalizePrice(Instrument instrument, double price)
        {
            double newPrice = 0;
            int decimalPlaces = GetTickSizeDecimalPlaces(instrument.MasterInstrument.TickSize);

            string formatText = string.Concat("N", decimalPlaces);
            string stringPriceValue = price.ToString(formatText);
            newPrice = double.Parse(stringPriceValue);

            return newPrice;
        }
        public int GetTickSizeDecimalPlaces(double tickSize)
        {
            int decimalPlaceCount = 0;

            if (tickSize < 0) return decimalPlaceCount;

            if (tickSizeDecimalPlaceCountCache.ContainsKey(tickSize))
            {
                decimalPlaceCount = tickSizeDecimalPlaceCountCache[tickSize];
            }
            else
            {
                var parts = tickSize.ToString(CultureInfo.InvariantCulture).Split('.');

                if (parts.Length < 2)
                    decimalPlaceCount = 0;
                else
                    decimalPlaceCount = parts[1].TrimEnd('0').Length;

                tickSizeDecimalPlaceCountCache.Add(tickSize, decimalPlaceCount);
            }

            return decimalPlaceCount;
        }

        public static double ConvertTicksToDollars(Instrument instrument, int ticks, int contracts)
        {
            double dollarValue = 0;

            if (ticks > 0 && contracts > 0)
            {
                double tickValue = GetTickValue(instrument);
                double tickSize = GetTickSize(instrument);

                dollarValue = tickValue * ticks * contracts;
            }

            return dollarValue;
        }
        public static double GetTickValue(Instrument instrument)
        {
            double tickValue = instrument.MasterInstrument.PointValue * instrument.MasterInstrument.TickSize;

            return tickValue;
        }

        public static int GetTicksPerPoint(double tickSize)
        {
            int tickPoint = 1;

            if (tickSize < 1)
            {
                tickPoint = (int)(1.0 / tickSize);
            }

            return (tickPoint);
        }
        public static bool IsFutureInstrumentType(Instrument instrument)
        {
            bool isFuture = (instrument.MasterInstrument.InstrumentType == InstrumentType.Future);
            return isFuture;

        }
        public static double GetTickSize(Instrument instrument)
        {
            double tickSize = instrument.MasterInstrument.TickSize;

            return (tickSize);
        }

        public double GetLastPrice(Instrument instrument)
        {
            double lastPrice = 0;
            string keyName = BuildKeyName(instrument);

            if (!lastPriceCache.TryGetValue(keyName, out lastPrice))
            {
                if (instrument.MarketData != null && instrument.MarketData.Last != null)
                {
                    lastPrice = instrument.MarketData.Last.Price;
                }
                else if (instrument.MarketData != null && instrument.MarketData.Bid != null)
                {
                    lastPrice = instrument.MarketData.Bid.Price;
                }
                else
                {
                    lastPrice = 0;
                }
            }

            return lastPrice;
        }

        public double GetAskPrice(Instrument instrument)
        {
            double askPrice = 0;
            string keyName = BuildKeyName(instrument);

            if (!askPriceCache.TryGetValue(keyName, out askPrice))
            {
                if (instrument.MarketData != null && instrument.MarketData.Last != null)
                {
                    askPrice = instrument.MarketData.Last.Ask;
                }
                else if (instrument.MarketData != null && instrument.MarketData.Ask != null)
                {
                    askPrice = instrument.MarketData.Ask.Price;
                }
                else
                {
                    askPrice = 0;
                }
            }

            return askPrice;
        }

        public double GetBidPrice(Instrument instrument)
        {
            double bidPrice = 0;
            string keyName = BuildKeyName(instrument);

            if (!bidPriceCache.TryGetValue(keyName, out bidPrice))
            {
                if (instrument.MarketData != null && instrument.MarketData.Last != null)
                {
                    bidPrice = instrument.MarketData.Last.Bid;
                }
                else if (instrument.MarketData != null && instrument.MarketData.Bid != null)
                {
                    bidPrice = instrument.MarketData.Bid.Price;
                }
                else
                {
                    bidPrice = 0;
                }
            }

            return bidPrice;
        }

        public double SetAskPrice(Instrument instrument, double askPrice)
        {
            string keyName = BuildKeyName(instrument);

            double newPrice = askPriceCache.AddOrUpdate(String.Copy(keyName), askPrice, (oldkey, oldvalue) => askPrice);

            return newPrice;
        }

        public double SetBidPrice(Instrument instrument, double bidPrice)
        {
            string keyName = BuildKeyName(instrument);

            double newPrice = bidPriceCache.AddOrUpdate(String.Copy(keyName), bidPrice, (oldkey, oldvalue) => bidPrice);

            return newPrice;
        }

        public double SetLastPrice(Instrument instrument, double lastPrice)
        {
            string keyName = BuildKeyName(instrument);

            double newPrice = lastPriceCache.AddOrUpdate(String.Copy(keyName), lastPrice, (oldkey, oldvalue) => lastPrice);

            return newPrice;
        }
    }


    public class RealMultiCycleCache
    {
        private Dictionary<string, DateTime> multiCycleCache = new Dictionary<string, DateTime>();
        private readonly object MultiCycleCacheLock = new object();
        private const int AutoExpireSeconds = 10;

        private DateTime GenerateExpirationTime()
        {
            return DateTime.Now.AddSeconds(AutoExpireSeconds);
        }
        public int Count
        {
            get { return multiCycleCache.Count; }
        }
        public bool HasElements(bool logExpiredElements = false)
        {
            bool hasElementsFlag = false;

            hasElementsFlag = (multiCycleCache.Count != 0);

            if (hasElementsFlag)
            {
                ClearExpiredElements(logExpiredElements);
            }

            hasElementsFlag = (multiCycleCache.Count != 0);

            return hasElementsFlag;
        }

        public bool ContainsKey(string uniqueId)
        {
            bool returnFlag = false;

            lock (MultiCycleCacheLock)
            {
                returnFlag = multiCycleCache.ContainsKey(uniqueId);
            }

            return returnFlag;
        }
        public bool TouchUniqueId(string uniqueId)
        {
            bool returnFlag = false;

            lock (MultiCycleCacheLock)
            {
                if (multiCycleCache.ContainsKey(uniqueId))
                {
                    DateTime expireDateTime = GenerateExpirationTime();
                    if (multiCycleCache[uniqueId] != null)
                    {
                        returnFlag = true;
                        multiCycleCache[uniqueId] = expireDateTime;
                    }
                }
            }

            return returnFlag;
        }

        public bool RegisterUniqueId(string uniqueId)
        {
            bool returnFlag = false;

            lock (MultiCycleCacheLock)
            {
                if (!multiCycleCache.ContainsKey(uniqueId))
                {
                    DateTime expireDateTime = GenerateExpirationTime();
                    multiCycleCache.Add(uniqueId, expireDateTime);
                    returnFlag = true;
                }
            }

            return returnFlag;
        }

        public void DeregisterUniqueId(string uniqueId)
        {
            lock (MultiCycleCacheLock)
            {
                multiCycleCache.Remove(uniqueId);
            }
        }

        public void ClearExpiredElements(bool logExpiredElements)
        {
            lock (MultiCycleCacheLock)
            {
                RealLogger logger = null;

                List<string> expiredElements = new List<string>();
                DateTime currentTime = DateTime.Now;

                foreach (KeyValuePair<string, DateTime> element in multiCycleCache)
                {
                    if (element.Value <= currentTime)
                    {
                        expiredElements.Add(element.Key);
                    }
                }

                foreach (string keyName in expiredElements)
                {
                    if (logExpiredElements)
                    {
                        if (logger == null) logger = new RealLogger("InternalLogger");

                        logger.PrintOutput("MultiCycleCache keyName=" + keyName + " has expired and was removed");
                    }

                    multiCycleCache.Remove(keyName);
                }
            }
        }

        public void Clear()
        {
            lock (MultiCycleCacheLock)
            {
                multiCycleCache.Clear();
            }
        }
    }

    public class RealOrder
    {
        private const int StateHasChanged = 1;
        private const int StateHasNotChanged = 0;
        private int stateChangeStatus = StateHasChanged;

        private long orderId = 0;
        private string exchangeOrderId = "";
        private string name = "";
        private OrderType orderType = OrderType.Unknown;
        private double averagePrice = 0;
        private double limitPrice = 0;
        private double limitPriceChanged = 0;
        private double stopPrice = 0;
        private double stopPriceChanged = 0;
        private OrderState orderState = OrderState.Unknown;
        private OrderAction orderAction = OrderAction.Buy;
        private Instrument instrument = null;
        private int quantity = 0;
        private int quantityChanged = 0;
        private int quantityFilled = 0;
        private Account account = null;

        public RealOrder()
        {

        }

        public string ExchangeOrderId
        {
            get
            {
                return exchangeOrderId;
            }
            set
            {
                ChangeStateFlag();
                exchangeOrderId = value;
            }
        }

        public long OrderId
        {
            get
            {
                return orderId;
            }
            set
            {
                ChangeStateFlag();
                orderId = value;
            }
        }

        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                ChangeStateFlag();
                name = value;
            }
        }

        public bool IsValid
        {
            get
            {
                if (orderType != OrderType.Unknown)
                    return true;
                else
                    return false;
            }
        }

        public bool IsLimit
        {
            get
            {
                return (this.OrderType == OrderType.Limit);
            }
        }

        public bool IsStopMarket
        {
            get
            {
                return (this.OrderType == OrderType.StopMarket);
            }
        }

        public bool IsMarket
        {
            get
            {
                return (this.OrderType == OrderType.Market);
            }
        }

        public Account Account
        {
            get
            {
                return account;
            }
            set
            {
                ChangeStateFlag();
                account = value;
            }
        }

        public OrderAction OrderAction
        {
            get
            {
                return orderAction;
            }
            set
            {
                ChangeStateFlag();
                orderAction = value;
            }
        }

        public OrderType OrderType
        {
            get
            {
                return orderType;
            }
            set
            {
                ChangeStateFlag();
                orderType = value;
            }
        }

        public OrderState OrderState
        {
            get
            {
                return orderState;
            }
            set
            {
                ChangeStateFlag();
                orderState = value;
            }
        }

        public double AveragePrice
        {
            get
            {
                return averagePrice;
            }
            set
            {
                ChangeStateFlag();
                averagePrice = value;
            }
        }

        public double LimitPrice
        {
            get
            {
                return limitPrice;
            }
            set
            {
                ChangeStateFlag();
                limitPrice = value;
            }
        }

        public double LimitPriceChanged
        {
            get
            {
                return limitPriceChanged;
            }
            set
            {
                ChangeStateFlag();
                limitPriceChanged = value;
            }
        }

        public double StopPrice
        {
            get
            {
                return stopPrice;
            }
            set
            {
                ChangeStateFlag();
                stopPrice = value;
            }
        }

        public double StopPriceChanged
        {
            get
            {
                return stopPriceChanged;
            }
            set
            {
                ChangeStateFlag();
                stopPriceChanged = value;
            }
        }

        public Instrument Instrument
        {
            get
            {
                return instrument;
            }
            set
            {
                ChangeStateFlag();
                instrument = value;
            }
        }

        public int Quantity
        {
            get
            {
                return quantity;
            }
            set
            {
                ChangeStateFlag();
                quantity = value;
            }
        }

        public int QuantityChanged
        {
            get
            {
                return quantityChanged;
            }
            set
            {
                ChangeStateFlag();
                quantityChanged = value;
            }
        }

        public int QuantityFilled
        {
            get
            {
                return quantityFilled;
            }
            set
            {
                ChangeStateFlag();
                quantityFilled = value;
            }
        }

        public int QuantityRemaining
        {
            get
            {
                return (quantity - quantityFilled);
            }
        }

        public bool HasStateChanged()
        {
            return (stateChangeStatus == StateHasChanged);
        }

        public void StoreState()
        {
            ResetStateFlag();
        }

        private void ChangeStateFlag()
        {
            Interlocked.Exchange(ref stateChangeStatus, StateHasChanged);
        }

        private void ResetStateFlag()
        {
            Interlocked.Exchange(ref stateChangeStatus, StateHasNotChanged);
        }
    }

    public class RealOrderService
    {
        private readonly Dictionary<string, int> orderPartialFillCache = new Dictionary<string, int>();
        public readonly object OrderPartialFillCacheLock = new object();
        private readonly RealMultiCycleCache orderUpdateMultiCycleCache = new RealMultiCycleCache();

        private readonly List<RealOrder> realOrders = new List<RealOrder>();
        private readonly object realOrderLock = new object();
        private const string TargetOrderName = "Target";
        private const string StopOrderName = "Stop";
        private const string EntryOrderName = "Entry";
        private const string ExitOrderName = "Exit";

        private const int InOrderUpdateCycleFinishedStatus = 0;
        private int inOrderUpdateCycleCounter = 0;

        public int OrderCount
        {
            get { return realOrders.Count; }
        }

        public void InOrderUpdateCycleIncrement()
        {
            Interlocked.Increment(ref inOrderUpdateCycleCounter);
        }

        public void InOrderUpdateCycleDecrement()
        {
            Interlocked.Decrement(ref inOrderUpdateCycleCounter);
        }

        public bool InOrderUpdateCycle()
        {
            return (inOrderUpdateCycleCounter > InOrderUpdateCycleFinishedStatus);
        }

        public bool IsValidOrder(RealOrder order, Instrument instrument)
        {
            bool returnFlag = false;

            if (order.Instrument.FullName == instrument.FullName && order.OrderType != OrderType.Unknown)
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        public Dictionary<string, int> OrderPartialFillCache
        {
            get { return orderPartialFillCache; }
        }

        public RealMultiCycleCache OrderUpdateMultiCycleCache
        {
            get { return orderUpdateMultiCycleCache; }
        }

        public string BuildOrderUniqueId(long orderId)
        {
            string keyName = orderId.ToString();

            return keyName;
        }

        public string BuildEntryOrderName()
        {
            string keyName = EntryOrderName;

            return keyName;
        }

        public string BuildExitOrderName()
        {
            string keyName = ExitOrderName;

            return keyName;
        }

        public string BuildTargetOrderName()
        {
            string keyName = TargetOrderName;

            return keyName;
        }

        public string BuildStopOrderName()
        {
            string keyName = StopOrderName;

            return keyName;
        }

        public bool TryGetByIndex(int index, out RealOrder realOrder)
        {
            bool returnFlag = false;
            realOrder = null;

            try
            {
                realOrder = realOrders.ElementAt(index);
                returnFlag = true;
            }
            catch
            {
                //stuff exception 
            }

            return returnFlag;
        }

        public bool TryGetById(long orderId, out RealOrder realOrder)
        {
            bool returnFlag = false;
            realOrder = null;

            int realOrderCount = OrderCount;

            try
            {
                RealOrder tempRealOrder = null;

                for (int index = 0; index < realOrderCount; index++)
                {
                    tempRealOrder = realOrders.ElementAt(index);

                    if (tempRealOrder != null)
                    {
                        if (tempRealOrder.OrderId == orderId)
                        {
                            realOrder = tempRealOrder;
                            returnFlag = true;
                            break;
                        }
                    }
                }
            }
            catch
            {
                //stuff exception 
            }

            return returnFlag;
        }

        public RealOrder BuildRealOrder(Account account, Instrument instrument, long orderId, string exchangeOrderId, string name, OrderType orderType, OrderAction orderAction, int quantity, int quantityChanged,
            double limitPrice, double limitPriceChanged, double stopPrice, double stopPriceChanged,
            OrderState orderState, int quantityFilled)
        {
            RealOrder realOrder = new RealOrder();
            realOrder.Account = account;
            realOrder.Instrument = instrument;
            realOrder.OrderId = orderId;
            realOrder.ExchangeOrderId = exchangeOrderId;
            realOrder.Name = name;
            realOrder.OrderType = orderType;
            realOrder.OrderAction = orderAction;
            realOrder.Quantity = quantity;
            realOrder.QuantityChanged = quantityChanged;
            realOrder.QuantityFilled = quantityFilled;
            realOrder.LimitPrice = limitPrice;
            realOrder.LimitPriceChanged = limitPriceChanged;
            realOrder.StopPrice = stopPrice;
            realOrder.StopPriceChanged = stopPriceChanged;
            realOrder.OrderState = orderState;

            return realOrder;
        }

        public void RemoveOrder(long orderId)
        {
            RealOrder foundOrder = null;
            lock (realOrderLock)
            {
                if (TryGetById(orderId, out foundOrder))
                {
                    realOrders.Remove(foundOrder);
                }
            }
        }
        public void RemoveAllTerminalStateOrders()
        {
            RealOrder tempRealOrder = null;
            List<RealOrder> removeOrderList = new List<RealOrder>();

            lock (realOrderLock)
            {
                int realOrderCount = OrderCount;

                for (int index = 0; index < realOrderCount; index++)
                {
                    tempRealOrder = realOrders.ElementAt(index);

                    if (tempRealOrder != null)
                    {
                        if (Order.IsTerminalState(tempRealOrder.OrderState))
                        {
                            removeOrderList.Add(tempRealOrder);
                        }
                    }
                }

                foreach (RealOrder removeOrder in removeOrderList)
                {
                    realOrders.Remove(removeOrder);
                }

            }
        }

        public int AddOrUpdateOrder(RealOrder order)
        {
            int orderQuantityRemaining = 0;

            lock (realOrderLock)
            {
                RealOrder foundOrder = null;

                if (TryGetById(order.OrderId, out foundOrder))
                {
                    foundOrder.ExchangeOrderId = order.ExchangeOrderId;
                    foundOrder.Quantity = order.Quantity;
                    foundOrder.QuantityChanged = order.QuantityChanged;
                    foundOrder.StopPrice = order.StopPrice;
                    foundOrder.StopPriceChanged = order.StopPriceChanged;
                    foundOrder.LimitPrice = order.LimitPrice;
                    foundOrder.LimitPriceChanged = order.LimitPriceChanged;
                    foundOrder.OrderState = order.OrderState;
                    foundOrder.OrderAction = order.OrderAction;
                    foundOrder.QuantityFilled = order.QuantityFilled;

                    orderQuantityRemaining = foundOrder.Quantity;
                }
                else
                {
                    realOrders.Add(order);

                    orderQuantityRemaining = order.Quantity;
                }
            }

            return orderQuantityRemaining;
        }

        public void LoadOrders(Account account, int positionCount)
        {
            lock (realOrderLock)
            {
                lock (account.Orders)
                {
                    realOrders.Clear();

                    foreach (Order orderItem in account.Orders)
                    {
                        //if (positionCount != 0 || (positionCount == 0 && !Order.IsTerminalState(orderItem.OrderState)))
                        if (!Order.IsTerminalState(orderItem.OrderState))
                        {
                            RealOrder order = BuildRealOrder(account,
                                orderItem.Instrument,
                                orderItem.Id,
                                orderItem.OrderId,
                                orderItem.Name,
                                orderItem.OrderType,
                                orderItem.OrderAction,
                                orderItem.Quantity,
                                orderItem.QuantityChanged,
                                orderItem.LimitPrice,
                                orderItem.LimitPriceChanged,
                                orderItem.StopPrice,
                                orderItem.StopPriceChanged,
                                orderItem.OrderState,
                                orderItem.Filled);

                            AddOrUpdateOrder(order);
                        }
                    }
                }
            }
        }

        public double GetStopLossInfo(Account account, Instrument instrument, OrderAction orderAction, out OrderType orderType, out int orderQuantity, out int orderCount)
        {
            double stopLossPrice = 0;
            orderType = OrderType.Unknown;
            orderQuantity = 0;
            orderCount = 0;

            int intOrderCount = OrderCount;

            for (int index = 0; index < intOrderCount; index++)
            {
                RealOrder order = null;

                if (TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidStopLossOrder(order, instrument, orderAction))
                    {
                        stopLossPrice = order.StopPrice;
                        orderType = order.OrderType;
                        orderQuantity += order.QuantityRemaining;
                        orderCount++;
                    }
                }
            }

            return stopLossPrice;
        }

        public double GetTakeProfitInfo(Account account, Instrument instrument, OrderAction orderAction, out OrderType orderType, out int orderQuantity, out int orderCount)
        {
            double takeProfitPrice = 0;
            orderType = OrderType.Unknown;
            orderQuantity = 0;
            orderCount = 0;

            int intOrderCount = OrderCount;

            for (int index = 0; index < intOrderCount; index++)
            {
                RealOrder order = null;

                if (TryGetByIndex(index, out order))
                {
                    if (RealOrderService.IsValidTakeProfitOrder(order, instrument, orderAction))
                    {
                        takeProfitPrice = order.LimitPrice;
                        orderType = order.OrderType;
                        orderQuantity += order.QuantityRemaining;
                        orderCount++;
                    }
                }
            }

            return takeProfitPrice;
        }
        public void SubmitLimitOrder(Account account, Order limitOrder)
        {
            //double price = limitOrder.

            //account.Submit(new[] { limitOrder });
        }

        public static bool IsValidStopLossPrice(Instrument instrument, OrderAction orderAction, double price, double lastPrice)
        {
            bool returnFlag = false;

            if (orderAction == OrderAction.BuyToCover && price > lastPrice)
            {
                returnFlag = true;
            }
            else if (orderAction == OrderAction.Sell && price < lastPrice)
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        public static bool IsValidTakeProfitPrice(Instrument instrument, OrderAction orderAction, double price, double lastPrice)
        {
            bool returnFlag = false;

            if (orderAction == OrderAction.BuyToCover && price < lastPrice)
            {
                returnFlag = true;
            }
            else if (orderAction == OrderAction.Sell && price > lastPrice)
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        public static bool IsValidStopLossOrder(RealOrder order, Instrument instrument, OrderAction orderAction)
        {
            bool returnFlag = false;

            if (!Order.IsTerminalState(order.OrderState) && order.OrderAction == orderAction && order.Instrument == instrument && order.IsStopMarket && order.Name.StartsWith(StopOrderName))
            {
                returnFlag = true;
            }

            return returnFlag;
        }
        public static bool IsValidTakeProfitOrder(RealOrder order, Instrument instrument, OrderAction orderAction)
        {
            bool returnFlag = false;

            if (!Order.IsTerminalState(order.OrderState) && order.OrderAction == orderAction && order.Instrument == instrument && order.IsLimit && order.Name.StartsWith(TargetOrderName))
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        public static bool IsValidSellStopOrder(RealOrder order, Instrument instrument, OrderAction orderAction)
        {
            bool returnFlag = false;

            if (!Order.IsTerminalState(order.OrderState) && order.OrderAction == orderAction && order.Instrument == instrument && order.IsStopMarket && order.Name.StartsWith(EntryOrderName))
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        public static bool IsValidBuyStopOrder(RealOrder order, Instrument instrument, OrderAction orderAction)
        {
            bool returnFlag = false;

            if (!Order.IsTerminalState(order.OrderState) && order.OrderAction == orderAction && order.Instrument == instrument && order.IsStopMarket && order.Name.StartsWith(EntryOrderName))
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        public static bool IsValidSellLimitOrder(RealOrder order, Instrument instrument, OrderAction orderAction)
        {
            bool returnFlag = false;

            if (!Order.IsTerminalState(order.OrderState) && order.OrderAction == orderAction && order.Instrument == instrument && order.IsLimit && order.Name.StartsWith(EntryOrderName))
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        public static bool IsValidBuyLimitOrder(RealOrder order, Instrument instrument, OrderAction orderAction)
        {
            bool returnFlag = false;

            if (!Order.IsTerminalState(order.OrderState) && order.OrderAction == orderAction && order.Instrument == instrument && order.IsLimit && order.Name.StartsWith(EntryOrderName))
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        public int GetFilledOrderQuantity(long orderId, OrderState orderState, int orderFilled)
        {
            int quantity = orderFilled;

            if (orderState == OrderState.PartFilled || orderState == OrderState.Filled)
            {
                lock (OrderPartialFillCacheLock)
                {
                    string orderUniqueId = BuildOrderUniqueId(orderId);
                    if (orderPartialFillCache.ContainsKey(orderUniqueId))
                    {
                        int currentFilledQuantity = orderPartialFillCache[orderUniqueId];

                        quantity = orderFilled - currentFilledQuantity;

                        if (orderState == OrderState.Filled)
                            orderPartialFillCache.Remove(orderUniqueId);
                        else
                            orderPartialFillCache[orderUniqueId] = orderFilled;
                    }
                    else
                    {
                        if (orderState == OrderState.PartFilled)
                            orderPartialFillCache[orderUniqueId] = orderFilled;
                    }
                }
            }

            return quantity;
        }

        public bool AreAllOrderUpdateCyclesComplete()
        {
            bool returnFlag = false;

            if (!HasActiveMarketOrders()
                && !this.OrderUpdateMultiCycleCache.HasElements()
                && !this.InOrderUpdateCycle())
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        public bool HasActiveMarketOrders()
        {
            bool hasActiveMarketOrders = false;
            bool isActiveMarketOrder = false;
            int orderCount = this.OrderCount;

            for (int index = 0; index < orderCount; index++)
            {
                RealOrder order = null;

                if (this.TryGetByIndex(index, out order))
                {
                    isActiveMarketOrder = (order.IsMarket && !Order.IsTerminalState(order.OrderState));

                    if (isActiveMarketOrder)
                    {
                        hasActiveMarketOrders = true;
                        break;
                    }
                }
            }

            return hasActiveMarketOrders;
        }
    }

    public class RealTradeService
    {

    }
    public class RealPositionService
    {
        private readonly List<RealPosition> realPositions = new List<RealPosition>();
        private readonly object realPositionLock = new object();

        private DateTime GetDateTimeNow()
        {
            DateTime now = DateTime.MinValue;

            bool isUsingPlaybackConnection = (NinjaTrader.Cbi.Connection.PlaybackConnection != null);

            if (isUsingPlaybackConnection)
            {
                now = NinjaTrader.Cbi.Connection.PlaybackConnection.Now;
            }
            else
            {
                now = DateTime.Now;
            }

            return now;
        }

        public int PositionCount
        {
            get { return realPositions.Count; }
        }

        public bool IsValidPosition(RealPosition position, Instrument instrument)
        {
            bool returnFlag = false;

            if (position.Instrument.FullName == instrument.FullName && !position.IsFlat())
            {
                returnFlag = true;
            }

            return returnFlag;
        }

        public bool TryGetByIndex(int index, out RealPosition realPosition)
        {
            bool returnFlag = false;
            realPosition = null;

            try
            {
                realPosition = realPositions.ElementAt(index);
                returnFlag = true;
            }
            catch
            {
                //stuff exception 
            }

            return returnFlag;
        }

        public bool TryGetByInstrumentFullName(string instrumentFullName, out RealPosition realPosition)
        {
            bool returnFlag = false;
            realPosition = null;

            int realPositionCount = PositionCount;

            try
            {
                RealPosition tempRealPosition = null;

                for (int index = 0; index < realPositionCount; index++)
                {
                    tempRealPosition = realPositions.ElementAt(index);

                    if (tempRealPosition != null)
                    {
                        if (tempRealPosition.Instrument.FullName == instrumentFullName)
                        {
                            realPosition = tempRealPosition;
                            returnFlag = true;
                            break;
                        }
                    }
                }

            }
            catch
            {
                //stuff exception 
            }

            return returnFlag;
        }

        public RealPosition BuildRealPosition(Account account, Instrument instrument, MarketPosition marketPosition, int quantity, double averagePrice, DateTime createDate)
        {
            RealPosition realPosition = new RealPosition();

            realPosition.Account = account;
            realPosition.Instrument = instrument;
            realPosition.MarketPosition = marketPosition;
            realPosition.Quantity = quantity;
            realPosition.AveragePrice = averagePrice;
            realPosition.CreateDate = createDate;
            realPosition.ModifyDate = createDate;


            return realPosition;
        }

        private int GetNewQuantity(RealPosition existingPosition, RealPosition newPosition)
        {
            int newQuantity = 0;

            if (existingPosition.MarketPosition == MarketPosition.Long)
            {
                if (newPosition.MarketPosition == MarketPosition.Long)
                    newQuantity = existingPosition.Quantity + newPosition.Quantity;
                else
                    newQuantity = existingPosition.Quantity - newPosition.Quantity;
            }
            else if (existingPosition.MarketPosition == MarketPosition.Short)
            {
                if (newPosition.MarketPosition == MarketPosition.Long)
                    newQuantity = existingPosition.Quantity - newPosition.Quantity;
                else
                    newQuantity = existingPosition.Quantity + newPosition.Quantity;
            }

            return newQuantity;
        }

        private MarketPosition FlipMarketPosition(MarketPosition marketPosition)
        {
            MarketPosition newMarketPosition = marketPosition;

            if (marketPosition == MarketPosition.Long)
            {
                newMarketPosition = MarketPosition.Short;
            }
            else if (marketPosition == MarketPosition.Short)
            {
                newMarketPosition = MarketPosition.Long;
            }

            return newMarketPosition;
        }

        public void AddPosition(RealPosition position)
        {
            lock (realPositionLock)
            {
                realPositions.Add(position);
            }
        }

        public void UpdatePosition(RealPosition position)
        {
            lock (realPositionLock)
            {
                RealPosition foundPosition = null;

                if (TryGetByInstrumentFullName(position.Instrument.FullName, out foundPosition))
                {
                    /*
                    bool marketPositionTypeChanged = (foundPosition.MarketPosition != position.MarketPosition);

                    double newAveragePrice = 0;

                    bool isIncreasingPositionQuantity = (position.Quantity > foundPosition.Quantity);

                    if (marketPositionTypeChanged)
                    {
                        newAveragePrice = position.AveragePrice;
                    }
                    else if (isIncreasingPositionQuantity)
                    {
                        int newQuantityTotal = position.Quantity;
                        int newQuantityDiff = (position.Quantity - foundPosition.Quantity);
                        newAveragePrice = ((foundPosition.AveragePrice * foundPosition.Quantity) + (position.AveragePrice * newQuantityDiff)) / newQuantityTotal;
                    }
                    else
                    {
                        newAveragePrice = foundPosition.AveragePrice;
                    }
                    */

                    foundPosition.ModifyDate = position.ModifyDate;
                    foundPosition.Quantity = position.Quantity;
                    foundPosition.MarketPosition = position.MarketPosition;

                    foundPosition.AveragePrice = position.AveragePrice;
                }
            }
        }

        public void RemovePosition(RealPosition position)
        {
            lock (realPositionLock)
            {
                RealPosition foundPosition = null;

                if (TryGetByInstrumentFullName(position.Instrument.FullName, out foundPosition))
                {
                    realPositions.Remove(foundPosition);
                }
            }
        }

        public int AddOrUpdatePosition(RealPosition position)
        {
            int positionQuantity = 0;

            lock (realPositionLock)
            {
                RealPosition foundPosition = null;

                if (TryGetByInstrumentFullName(position.Instrument.FullName, out foundPosition))
                {
                    MarketPosition newMarketPosition;
                    int newQuantity = GetNewQuantity(foundPosition, position);

                    if (newQuantity < 0)
                    {
                        newQuantity *= -1; // flip to positive number

                        newMarketPosition = FlipMarketPosition(foundPosition.MarketPosition);
                    }
                    else
                    {
                        newMarketPosition = foundPosition.MarketPosition;
                    }

                    if (newQuantity == 0)
                    {
                        realPositions.Remove(foundPosition);
                    }
                    else
                    {
                        bool isIncreasingPositionQuantity = (newQuantity > foundPosition.Quantity);

                        int quantitySum = foundPosition.Quantity + position.Quantity;
                        double newAveragePrice = foundPosition.AveragePrice;

                        if (isIncreasingPositionQuantity)
                        {
                            newAveragePrice = ((foundPosition.AveragePrice * foundPosition.Quantity) + (position.AveragePrice * position.Quantity)) / quantitySum;
                        }

                        //Output.Process(GetDateTimeNow() + ": " + " tempAveragePrice=" + tempAveragePrice.ToString() + " previousAP =" + foundPosition.AveragePrice.ToString() + " newAP=" + position.AveragePrice.ToString() + " previousquan=" + foundPosition.Quantity.ToString() + " origQuan=" + position.Quantity.ToString(), PrintTo.OutputTab1);

                        //Output.Process("isIncreasingPositionQuantity=" + isIncreasingPositionQuantity + " origAvgPri =" + position.AveragePrice.ToString() + " previousAP =" + foundPosition.AveragePrice.ToString() + " quantitySum=" + quantitySum.ToString() + " previousquan=" + foundPosition.Quantity.ToString() + " origQuantity=" + newQuantity.ToString(), PrintTo.OutputTab1);


                        double tickSize = position.Instrument.MasterInstrument.TickSize;
                        int ticksPerPoint = RealInstrumentService.GetTicksPerPoint(tickSize);

                        foundPosition.AveragePrice = newAveragePrice;
                        //Output.Process("**** " + " newAveragePrice=" + newAveragePrice.ToString() + " previousAP =" + foundPosition.AveragePrice.ToString() + " newAP=" + position.AveragePrice.ToString() + " previousquan=" + foundPosition.Quantity.ToString() + " newQuan=" + newQuantity.ToString(), PrintTo.OutputTab1);

                        //foreach (Position xPosition in foundPosition.Account.Positions)
                        //{
                        //    Output.Process(GetDateTimeNow() + ": " + " xPositionAP=" + xPosition.AveragePrice.ToString(), PrintTo.OutputTab1);
                        //}

                        //Output.Process("existingQuan=" + foundPosition.Quantity + " orderQuan=" + position.Quantity + " newAdjQuantity =" + newQuantity + " quantitySum=" + quantitySum + " newMarketPosition=" + newMarketPosition + " exiMP=" + foundPosition.MarketPosition + " orderMP=" + position.MarketPosition, PrintTo.OutputTab1);

                        foundPosition.ModifyDate = position.CreateDate;
                        foundPosition.Quantity = newQuantity;
                        foundPosition.MarketPosition = newMarketPosition;

                        positionQuantity = newQuantity;
                    }
                }
                else
                {
                    //Output.Process(GetDateTimeNow() + ": " + " newAP=" + position.AveragePrice.ToString() + " newQuan=" + position.Quantity.ToString(), PrintTo.OutputTab1);
                    realPositions.Add(position);
                    positionQuantity = position.Quantity;
                }
            }

            return positionQuantity;
        }

        public void LoadPositions(Account account)
        {
            lock (realPositionLock)
            {
                lock (account.Positions)
                {
                    realPositions.Clear();

                    foreach (Position positionItem in account.Positions)
                    {
                        RealPosition position = BuildRealPosition(account,
                            positionItem.Instrument,
                            positionItem.MarketPosition,
                            positionItem.Quantity,
                            positionItem.AveragePrice,
                            GetDateTimeNow());

                        AddOrUpdatePosition(position);
                    }
                }
            }
        }
    }
    public class RealPosition
    {
        private const int StateHasChanged = 1;
        private const int StateHasNotChanged = 0;
        private int stateChangeStatus = StateHasChanged;

        private string positionId = null;
        private bool isValid = true;
        private MarketPosition marketPosition = MarketPosition.Flat;
        private double averagePrice = 0;
        private Instrument instrument = null;
        private int quantity = 0;
        private Account account = null;
        private DateTime createDate = DateTime.MinValue;
        private DateTime modifyDate = DateTime.MinValue;

        public RealPosition()
        {
            this.positionId = Guid.NewGuid().ToString();
        }

        public string PositionId
        {
            get
            {
                return positionId;
            }
        }

        public bool IsValid
        {
            get
            {
                return isValid;
            }
            set
            {
                ChangeStateFlag();
                isValid = value;
            }
        }

        public Account Account
        {
            get
            {
                return account;
            }
            set
            {
                ChangeStateFlag();
                account = value;
            }
        }

        public MarketPosition MarketPosition
        {
            get
            {
                return marketPosition;
            }
            set
            {
                ChangeStateFlag();
                marketPosition = value;
            }
        }

        public double AveragePrice
        {
            get
            {
                return averagePrice;
            }
            set
            {
                ChangeStateFlag();
                averagePrice = value;
            }
        }

        public Instrument Instrument
        {
            get
            {
                return instrument;
            }
            set
            {
                ChangeStateFlag();
                instrument = value;
            }
        }

        public int Quantity
        {
            get
            {
                return quantity;
            }
            set
            {
                ChangeStateFlag();
                quantity = value;
            }
        }

        public DateTime CreateDate
        {
            get
            {
                return createDate;
            }
            set
            {
                ChangeStateFlag();
                createDate = value;
            }
        }

        public DateTime ModifyDate
        {
            get
            {
                return modifyDate;
            }
            set
            {
                ChangeStateFlag();
                modifyDate = value;
            }
        }

        public bool IsFlat()
        {
            return (marketPosition == MarketPosition.Flat || quantity == 0);
        }

        public bool HasStateChanged()
        {
            return (stateChangeStatus == StateHasChanged);
        }

        public void StoreState()
        {
            ResetStateFlag();
        }

        private void ChangeStateFlag()
        {
            Interlocked.Exchange(ref stateChangeStatus, StateHasChanged);
        }

        private void ResetStateFlag()
        {
            Interlocked.Exchange(ref stateChangeStatus, StateHasNotChanged);
        }
    }
}

#region NinjaScript generated code. Neither change nor remove.

namespace NinjaTrader.NinjaScript.Indicators
{
	public partial class Indicator : NinjaTrader.Gui.NinjaScript.IndicatorRenderBase
	{
		private TickHunterTA.TickHunter[] cacheTickHunter;
		public TickHunterTA.TickHunter TickHunter(string indicatorName, string indicatorTermsOfUse, bool showIndicatorName, string indicatorInfoLink, bool useAutoPositionStopLoss, int stopLossInitialTicks, double stopLossInitialATRMultiplier, TickHunterStopLossSnapTypes stopLossInitialSnapType, int stopLossInitialMaxTicks, double stopLossInitialDollars, bool stopLossInitialDollarsCombined, int stopLossJumpTicks, bool stopLossCTRLJumpTicks, bool stopLossRefreshOnVolumeChange, bool stopLossRefreshManagementEnabled, bool useAutoPositionTakeProfit, int takeProfitInitialTicks, double takeProfitInitialATRMultiplier, bool takeProfitSyncBogeyTargetPrice, bool takeProfitSyncECATargetPrice, int takeProfitJumpTicks, double takeProfitCtrlSLMultiplier, bool takeProfitRefreshManagementEnabled, TickHunterBreakEvenAutoTypes autoPositionBreakEvenType, int breakEvenInitialTicks, int breakEvenJumpTicks, int breakEvenTurboJumpTicks, TickHunterBreakEvenAutoTrailNowTypes breakEvenAutoTrailNow, int breakEvenAutoTriggerTicks, double breakEvenAutoTriggerATRMultiplier, TickHunterStopLossSnapTypes breakEvenAutoZombieFlipResumeSnapType, TickHunterStopLossSnapTypes breakEvenAutoCreeperFlipSnapType, bool useIntradayMarginCheck, bool limitTrancheVolumeToInProfit, bool limitToVolumeMaxOption, int entryVolumeMaxOption1, int entryVolumeMaxOption2, int entryVolumeMaxOption3, int entryVolumeMaxOption4, int entryVolumeMaxOption5, int maxInitialTrancheVolumeSize, bool limitTrancheVolumePerBar, int minTrancheVolumeDelaySeconds, bool usePopCTRLDelayedEntry, bool usePopLimitToPullback, int popDelayedEntryMaxCount, int popInitialTicks, double popInitialATRMultiplier, int popJumpTicks, bool usePopAutoJumpToSnap, int dropInitialTicks, double dropInitialATRMultiplier, int dropJumpTicks, bool useDropAutoJumpToSnap, bool usePopDropOnBarUpdateDelay, long popDropThrottleMilliseconds, TickHunterEntryVolumeAutoTypes autoEntryVolumeType, int autoEntryVolumeOption1, int autoEntryVolumeOption2, int autoEntryVolumeOption3, int autoEntryVolumeOption4, int autoEntryVolumeOption5, TickHunterAutoPilotOrderTypes autoPilotOrderType, TickHunterTradeSignalTypes autoPilotTradeSignalType, TickHunterAutoPilotSetupTypes autoPilotSetupType, bool useAutoPilotLite, bool useAutoPilotAddOn, int autoPilotMaxVolume, bool useAutoPilotSpeedLineFilter, int autoPilotSpeedLineFilterPeriod, int autoPilotSetupFilterPeriod, int autoPilotSetupZombiePeriod, double autoPilotSetupZombieMultiplier, int autoPilotSetupCreeperPeriod1, int autoPilotSetupCreeperPeriod2, int autoPilotSetupCreeperPeriod3, int autoPilotSetupWalkerPeriod, bool autoPilotSetupWalkerFreshCrossOnly, TickHunterAutoPilotProfileSetupTypes autoPilotProfileSetupType, bool usePeppyLimitPopDelayedEntry, bool usePeppyLimitPopToPullback, bool usePeppyLimitPopAlignedCreeper, bool usePeppyLimitPopAlignedRushLine, bool useSleepyLimitPopDelayedEntry, bool useSleepyLimitPopToPullback, bool useSleepyLimitPopCounterCreeper, bool useSleepyLimitPopCounterRushLine, TickHunterCloseAutoTypes autoPositionCloseType, bool useAutoCloseMinProfit, double autoCloseMinProfitDollarsPerVolume, bool useAutoCloseAlert, int autoCloseAndTrailOffsetTicks, int autoCloseAndTrailMA1Period, int autoCloseAndTrailMA2Period, int autoCloseAndTrailMA3Period, int autoCloseAndTrailMA4Period, int autoCloseAndTrailZL1Period, int autoCloseAndTrailZL2Period, int autoCloseAndTrailRLPeriod, int autoCloseAndTrailDL1Period, int autoCloseAndTrailDL2Period, int autoCloseAndTrailDL3Period, int autoCloseAndTrailDL4Period, int autoCloseAndTrailR1Period, int autoCloseAndTrailR5Period, int autoCloseAndTrailKLine1Period, double autoCloseAndTrailKLine1Multiplier, int autoCloseAndTrailKLine2Period, double autoCloseAndTrailKLine2Multiplier, bool bogeyTargetStartWithFullPnL, double bogeyTargetBaseDollars, double bogeyTargetDailyBaseDollars, bool showBogeyTargetDailyBreakEvenLine, bool showBogeyTargetDaily1Line, bool showBogeyTargetDaily2Line, bool showBogeyTargetDaily3Line, bool showBogeyTargetDaily4Line, bool showBogeyTargetDaily5Line, double eCATargetDollars, double eCATargetDollarsPerOtherVolume, double eCATargetDollarsPerMNQVolume, double eCATargetDollarsPerNQVolume, double eCATargetDollarsPerM2KVolume, double eCATargetDollarsPerRTYVolume, double eCATargetDollarsPerMESVolume, double eCATargetDollarsPerESVolume, double eCATargetDollarsPerMYMVolume, double eCATargetDollarsPerYMVolume, double eCATargetATRMultiplierPerVolume, double autoAddOnMaxDollars, bool useDayOverMaxLossTrailing, double dayOverMaxLossDollars, double dayOverMaxLossBTBaseRatio, double dayOverMaxAccountPnLPeakDollars, double dayOverAccountBalanceFloorDollars, double eCAMaxDDInDollars, double excessIntradayMarginMinDollars, bool showButtonAutoBreakEven, bool showButtonReverse, bool showButtonClose, bool showButtonAutoClose, bool showButtonProfitTarget, bool showButtonTPPlus, bool showButtonBEPlus, bool showButtonSLPlus, bool showButtonBuyMarket, bool showButtonSellMarket, bool showButtonPopPlus, bool showButtonPopMinus, bool showButtonDropMinus, bool showButtonDropPlus, bool showButtonAutoAddOn, bool showButtonTradeSignal, bool showButtonAutoPilotProfile, bool showButtonAutoPilot, bool showButtonVolumeMax, bool showButtonVolume, bool useBlendedInstruments, bool showAveragePriceLine, bool showAveragePriceLineQuantity, bool showAveragePriceLineQuantityInMicros, double otherCommissionPerSide, double otherIntradayMarginDollars, int otherPositionMaxVolume, double mNQCommissionPerSide, double mNQIntradayMarginDollars, int mNQPositionMaxVolume, double nQCommissionPerSide, double nQIntradayMarginDollars, int nQPositionMaxVolume, double mESCommissionPerSide, double mESIntradayMarginDollars, int mESPositionMaxVolume, double eSCommissionPerSide, double eSIntradayMarginDollars, int eSPositionMaxVolume, double mYMCommissionPerSide, double mYMIntradayMarginDollars, int mYMPositionMaxVolume, double yMCommissionPerSide, double yMIntradayMarginDollars, int yMPositionMaxVolume, double m2KCommissionPerSide, double m2KIntradayMarginDollars, int m2KPositionMaxVolume, double rTYCommissionPerSide, double rTYIntradayMarginDollars, int rTYPositionMaxVolume, bool ignoreInstrumentServerSupport, int snapOffsetTicks, int snapPowerBoxPeriod, bool snapPowerBoxAutoAdjustPeriodsOnM1, int aTRPeriod, int refreshTPSLOffsetTicks, int refreshTPSLOrderDelaySeconds, int singleOrderChunkMaxQuantity, int singleOrderChunkMinQuantity, int singleOrderChunkDelayMilliseconds, long realTimePipeLineThrottleMilliseconds, bool usePositionProfitLogging, int debugLogLevel, int orderWaitOutputThrottleSeconds, bool useAccountInfoLogging, string accountInfoLoggingPath)
		{
			return TickHunter(Input, indicatorName, indicatorTermsOfUse, showIndicatorName, indicatorInfoLink, useAutoPositionStopLoss, stopLossInitialTicks, stopLossInitialATRMultiplier, stopLossInitialSnapType, stopLossInitialMaxTicks, stopLossInitialDollars, stopLossInitialDollarsCombined, stopLossJumpTicks, stopLossCTRLJumpTicks, stopLossRefreshOnVolumeChange, stopLossRefreshManagementEnabled, useAutoPositionTakeProfit, takeProfitInitialTicks, takeProfitInitialATRMultiplier, takeProfitSyncBogeyTargetPrice, takeProfitSyncECATargetPrice, takeProfitJumpTicks, takeProfitCtrlSLMultiplier, takeProfitRefreshManagementEnabled, autoPositionBreakEvenType, breakEvenInitialTicks, breakEvenJumpTicks, breakEvenTurboJumpTicks, breakEvenAutoTrailNow, breakEvenAutoTriggerTicks, breakEvenAutoTriggerATRMultiplier, breakEvenAutoZombieFlipResumeSnapType, breakEvenAutoCreeperFlipSnapType, useIntradayMarginCheck, limitTrancheVolumeToInProfit, limitToVolumeMaxOption, entryVolumeMaxOption1, entryVolumeMaxOption2, entryVolumeMaxOption3, entryVolumeMaxOption4, entryVolumeMaxOption5, maxInitialTrancheVolumeSize, limitTrancheVolumePerBar, minTrancheVolumeDelaySeconds, usePopCTRLDelayedEntry, usePopLimitToPullback, popDelayedEntryMaxCount, popInitialTicks, popInitialATRMultiplier, popJumpTicks, usePopAutoJumpToSnap, dropInitialTicks, dropInitialATRMultiplier, dropJumpTicks, useDropAutoJumpToSnap, usePopDropOnBarUpdateDelay, popDropThrottleMilliseconds, autoEntryVolumeType, autoEntryVolumeOption1, autoEntryVolumeOption2, autoEntryVolumeOption3, autoEntryVolumeOption4, autoEntryVolumeOption5, autoPilotOrderType, autoPilotTradeSignalType, autoPilotSetupType, useAutoPilotLite, useAutoPilotAddOn, autoPilotMaxVolume, useAutoPilotSpeedLineFilter, autoPilotSpeedLineFilterPeriod, autoPilotSetupFilterPeriod, autoPilotSetupZombiePeriod, autoPilotSetupZombieMultiplier, autoPilotSetupCreeperPeriod1, autoPilotSetupCreeperPeriod2, autoPilotSetupCreeperPeriod3, autoPilotSetupWalkerPeriod, autoPilotSetupWalkerFreshCrossOnly, autoPilotProfileSetupType, usePeppyLimitPopDelayedEntry, usePeppyLimitPopToPullback, usePeppyLimitPopAlignedCreeper, usePeppyLimitPopAlignedRushLine, useSleepyLimitPopDelayedEntry, useSleepyLimitPopToPullback, useSleepyLimitPopCounterCreeper, useSleepyLimitPopCounterRushLine, autoPositionCloseType, useAutoCloseMinProfit, autoCloseMinProfitDollarsPerVolume, useAutoCloseAlert, autoCloseAndTrailOffsetTicks, autoCloseAndTrailMA1Period, autoCloseAndTrailMA2Period, autoCloseAndTrailMA3Period, autoCloseAndTrailMA4Period, autoCloseAndTrailZL1Period, autoCloseAndTrailZL2Period, autoCloseAndTrailRLPeriod, autoCloseAndTrailDL1Period, autoCloseAndTrailDL2Period, autoCloseAndTrailDL3Period, autoCloseAndTrailDL4Period, autoCloseAndTrailR1Period, autoCloseAndTrailR5Period, autoCloseAndTrailKLine1Period, autoCloseAndTrailKLine1Multiplier, autoCloseAndTrailKLine2Period, autoCloseAndTrailKLine2Multiplier, bogeyTargetStartWithFullPnL, bogeyTargetBaseDollars, bogeyTargetDailyBaseDollars, showBogeyTargetDailyBreakEvenLine, showBogeyTargetDaily1Line, showBogeyTargetDaily2Line, showBogeyTargetDaily3Line, showBogeyTargetDaily4Line, showBogeyTargetDaily5Line, eCATargetDollars, eCATargetDollarsPerOtherVolume, eCATargetDollarsPerMNQVolume, eCATargetDollarsPerNQVolume, eCATargetDollarsPerM2KVolume, eCATargetDollarsPerRTYVolume, eCATargetDollarsPerMESVolume, eCATargetDollarsPerESVolume, eCATargetDollarsPerMYMVolume, eCATargetDollarsPerYMVolume, eCATargetATRMultiplierPerVolume, autoAddOnMaxDollars, useDayOverMaxLossTrailing, dayOverMaxLossDollars, dayOverMaxLossBTBaseRatio, dayOverMaxAccountPnLPeakDollars, dayOverAccountBalanceFloorDollars, eCAMaxDDInDollars, excessIntradayMarginMinDollars, showButtonAutoBreakEven, showButtonReverse, showButtonClose, showButtonAutoClose, showButtonProfitTarget, showButtonTPPlus, showButtonBEPlus, showButtonSLPlus, showButtonBuyMarket, showButtonSellMarket, showButtonPopPlus, showButtonPopMinus, showButtonDropMinus, showButtonDropPlus, showButtonAutoAddOn, showButtonTradeSignal, showButtonAutoPilotProfile, showButtonAutoPilot, showButtonVolumeMax, showButtonVolume, useBlendedInstruments, showAveragePriceLine, showAveragePriceLineQuantity, showAveragePriceLineQuantityInMicros, otherCommissionPerSide, otherIntradayMarginDollars, otherPositionMaxVolume, mNQCommissionPerSide, mNQIntradayMarginDollars, mNQPositionMaxVolume, nQCommissionPerSide, nQIntradayMarginDollars, nQPositionMaxVolume, mESCommissionPerSide, mESIntradayMarginDollars, mESPositionMaxVolume, eSCommissionPerSide, eSIntradayMarginDollars, eSPositionMaxVolume, mYMCommissionPerSide, mYMIntradayMarginDollars, mYMPositionMaxVolume, yMCommissionPerSide, yMIntradayMarginDollars, yMPositionMaxVolume, m2KCommissionPerSide, m2KIntradayMarginDollars, m2KPositionMaxVolume, rTYCommissionPerSide, rTYIntradayMarginDollars, rTYPositionMaxVolume, ignoreInstrumentServerSupport, snapOffsetTicks, snapPowerBoxPeriod, snapPowerBoxAutoAdjustPeriodsOnM1, aTRPeriod, refreshTPSLOffsetTicks, refreshTPSLOrderDelaySeconds, singleOrderChunkMaxQuantity, singleOrderChunkMinQuantity, singleOrderChunkDelayMilliseconds, realTimePipeLineThrottleMilliseconds, usePositionProfitLogging, debugLogLevel, orderWaitOutputThrottleSeconds, useAccountInfoLogging, accountInfoLoggingPath);
		}

		public TickHunterTA.TickHunter TickHunter(ISeries<double> input, string indicatorName, string indicatorTermsOfUse, bool showIndicatorName, string indicatorInfoLink, bool useAutoPositionStopLoss, int stopLossInitialTicks, double stopLossInitialATRMultiplier, TickHunterStopLossSnapTypes stopLossInitialSnapType, int stopLossInitialMaxTicks, double stopLossInitialDollars, bool stopLossInitialDollarsCombined, int stopLossJumpTicks, bool stopLossCTRLJumpTicks, bool stopLossRefreshOnVolumeChange, bool stopLossRefreshManagementEnabled, bool useAutoPositionTakeProfit, int takeProfitInitialTicks, double takeProfitInitialATRMultiplier, bool takeProfitSyncBogeyTargetPrice, bool takeProfitSyncECATargetPrice, int takeProfitJumpTicks, double takeProfitCtrlSLMultiplier, bool takeProfitRefreshManagementEnabled, TickHunterBreakEvenAutoTypes autoPositionBreakEvenType, int breakEvenInitialTicks, int breakEvenJumpTicks, int breakEvenTurboJumpTicks, TickHunterBreakEvenAutoTrailNowTypes breakEvenAutoTrailNow, int breakEvenAutoTriggerTicks, double breakEvenAutoTriggerATRMultiplier, TickHunterStopLossSnapTypes breakEvenAutoZombieFlipResumeSnapType, TickHunterStopLossSnapTypes breakEvenAutoCreeperFlipSnapType, bool useIntradayMarginCheck, bool limitTrancheVolumeToInProfit, bool limitToVolumeMaxOption, int entryVolumeMaxOption1, int entryVolumeMaxOption2, int entryVolumeMaxOption3, int entryVolumeMaxOption4, int entryVolumeMaxOption5, int maxInitialTrancheVolumeSize, bool limitTrancheVolumePerBar, int minTrancheVolumeDelaySeconds, bool usePopCTRLDelayedEntry, bool usePopLimitToPullback, int popDelayedEntryMaxCount, int popInitialTicks, double popInitialATRMultiplier, int popJumpTicks, bool usePopAutoJumpToSnap, int dropInitialTicks, double dropInitialATRMultiplier, int dropJumpTicks, bool useDropAutoJumpToSnap, bool usePopDropOnBarUpdateDelay, long popDropThrottleMilliseconds, TickHunterEntryVolumeAutoTypes autoEntryVolumeType, int autoEntryVolumeOption1, int autoEntryVolumeOption2, int autoEntryVolumeOption3, int autoEntryVolumeOption4, int autoEntryVolumeOption5, TickHunterAutoPilotOrderTypes autoPilotOrderType, TickHunterTradeSignalTypes autoPilotTradeSignalType, TickHunterAutoPilotSetupTypes autoPilotSetupType, bool useAutoPilotLite, bool useAutoPilotAddOn, int autoPilotMaxVolume, bool useAutoPilotSpeedLineFilter, int autoPilotSpeedLineFilterPeriod, int autoPilotSetupFilterPeriod, int autoPilotSetupZombiePeriod, double autoPilotSetupZombieMultiplier, int autoPilotSetupCreeperPeriod1, int autoPilotSetupCreeperPeriod2, int autoPilotSetupCreeperPeriod3, int autoPilotSetupWalkerPeriod, bool autoPilotSetupWalkerFreshCrossOnly, TickHunterAutoPilotProfileSetupTypes autoPilotProfileSetupType, bool usePeppyLimitPopDelayedEntry, bool usePeppyLimitPopToPullback, bool usePeppyLimitPopAlignedCreeper, bool usePeppyLimitPopAlignedRushLine, bool useSleepyLimitPopDelayedEntry, bool useSleepyLimitPopToPullback, bool useSleepyLimitPopCounterCreeper, bool useSleepyLimitPopCounterRushLine, TickHunterCloseAutoTypes autoPositionCloseType, bool useAutoCloseMinProfit, double autoCloseMinProfitDollarsPerVolume, bool useAutoCloseAlert, int autoCloseAndTrailOffsetTicks, int autoCloseAndTrailMA1Period, int autoCloseAndTrailMA2Period, int autoCloseAndTrailMA3Period, int autoCloseAndTrailMA4Period, int autoCloseAndTrailZL1Period, int autoCloseAndTrailZL2Period, int autoCloseAndTrailRLPeriod, int autoCloseAndTrailDL1Period, int autoCloseAndTrailDL2Period, int autoCloseAndTrailDL3Period, int autoCloseAndTrailDL4Period, int autoCloseAndTrailR1Period, int autoCloseAndTrailR5Period, int autoCloseAndTrailKLine1Period, double autoCloseAndTrailKLine1Multiplier, int autoCloseAndTrailKLine2Period, double autoCloseAndTrailKLine2Multiplier, bool bogeyTargetStartWithFullPnL, double bogeyTargetBaseDollars, double bogeyTargetDailyBaseDollars, bool showBogeyTargetDailyBreakEvenLine, bool showBogeyTargetDaily1Line, bool showBogeyTargetDaily2Line, bool showBogeyTargetDaily3Line, bool showBogeyTargetDaily4Line, bool showBogeyTargetDaily5Line, double eCATargetDollars, double eCATargetDollarsPerOtherVolume, double eCATargetDollarsPerMNQVolume, double eCATargetDollarsPerNQVolume, double eCATargetDollarsPerM2KVolume, double eCATargetDollarsPerRTYVolume, double eCATargetDollarsPerMESVolume, double eCATargetDollarsPerESVolume, double eCATargetDollarsPerMYMVolume, double eCATargetDollarsPerYMVolume, double eCATargetATRMultiplierPerVolume, double autoAddOnMaxDollars, bool useDayOverMaxLossTrailing, double dayOverMaxLossDollars, double dayOverMaxLossBTBaseRatio, double dayOverMaxAccountPnLPeakDollars, double dayOverAccountBalanceFloorDollars, double eCAMaxDDInDollars, double excessIntradayMarginMinDollars, bool showButtonAutoBreakEven, bool showButtonReverse, bool showButtonClose, bool showButtonAutoClose, bool showButtonProfitTarget, bool showButtonTPPlus, bool showButtonBEPlus, bool showButtonSLPlus, bool showButtonBuyMarket, bool showButtonSellMarket, bool showButtonPopPlus, bool showButtonPopMinus, bool showButtonDropMinus, bool showButtonDropPlus, bool showButtonAutoAddOn, bool showButtonTradeSignal, bool showButtonAutoPilotProfile, bool showButtonAutoPilot, bool showButtonVolumeMax, bool showButtonVolume, bool useBlendedInstruments, bool showAveragePriceLine, bool showAveragePriceLineQuantity, bool showAveragePriceLineQuantityInMicros, double otherCommissionPerSide, double otherIntradayMarginDollars, int otherPositionMaxVolume, double mNQCommissionPerSide, double mNQIntradayMarginDollars, int mNQPositionMaxVolume, double nQCommissionPerSide, double nQIntradayMarginDollars, int nQPositionMaxVolume, double mESCommissionPerSide, double mESIntradayMarginDollars, int mESPositionMaxVolume, double eSCommissionPerSide, double eSIntradayMarginDollars, int eSPositionMaxVolume, double mYMCommissionPerSide, double mYMIntradayMarginDollars, int mYMPositionMaxVolume, double yMCommissionPerSide, double yMIntradayMarginDollars, int yMPositionMaxVolume, double m2KCommissionPerSide, double m2KIntradayMarginDollars, int m2KPositionMaxVolume, double rTYCommissionPerSide, double rTYIntradayMarginDollars, int rTYPositionMaxVolume, bool ignoreInstrumentServerSupport, int snapOffsetTicks, int snapPowerBoxPeriod, bool snapPowerBoxAutoAdjustPeriodsOnM1, int aTRPeriod, int refreshTPSLOffsetTicks, int refreshTPSLOrderDelaySeconds, int singleOrderChunkMaxQuantity, int singleOrderChunkMinQuantity, int singleOrderChunkDelayMilliseconds, long realTimePipeLineThrottleMilliseconds, bool usePositionProfitLogging, int debugLogLevel, int orderWaitOutputThrottleSeconds, bool useAccountInfoLogging, string accountInfoLoggingPath)
		{
			if (cacheTickHunter != null)
				for (int idx = 0; idx < cacheTickHunter.Length; idx++)
					if (cacheTickHunter[idx] != null && cacheTickHunter[idx].IndicatorName == indicatorName && cacheTickHunter[idx].IndicatorTermsOfUse == indicatorTermsOfUse && cacheTickHunter[idx].ShowIndicatorName == showIndicatorName && cacheTickHunter[idx].IndicatorInfoLink == indicatorInfoLink && cacheTickHunter[idx].UseAutoPositionStopLoss == useAutoPositionStopLoss && cacheTickHunter[idx].StopLossInitialTicks == stopLossInitialTicks && cacheTickHunter[idx].StopLossInitialATRMultiplier == stopLossInitialATRMultiplier && cacheTickHunter[idx].StopLossInitialSnapType == stopLossInitialSnapType && cacheTickHunter[idx].StopLossInitialMaxTicks == stopLossInitialMaxTicks && cacheTickHunter[idx].StopLossInitialDollars == stopLossInitialDollars && cacheTickHunter[idx].StopLossInitialDollarsCombined == stopLossInitialDollarsCombined && cacheTickHunter[idx].StopLossJumpTicks == stopLossJumpTicks && cacheTickHunter[idx].StopLossCTRLJumpTicks == stopLossCTRLJumpTicks && cacheTickHunter[idx].StopLossRefreshOnVolumeChange == stopLossRefreshOnVolumeChange && cacheTickHunter[idx].StopLossRefreshManagementEnabled == stopLossRefreshManagementEnabled && cacheTickHunter[idx].UseAutoPositionTakeProfit == useAutoPositionTakeProfit && cacheTickHunter[idx].TakeProfitInitialTicks == takeProfitInitialTicks && cacheTickHunter[idx].TakeProfitInitialATRMultiplier == takeProfitInitialATRMultiplier && cacheTickHunter[idx].TakeProfitSyncBogeyTargetPrice == takeProfitSyncBogeyTargetPrice && cacheTickHunter[idx].TakeProfitSyncECATargetPrice == takeProfitSyncECATargetPrice && cacheTickHunter[idx].TakeProfitJumpTicks == takeProfitJumpTicks && cacheTickHunter[idx].TakeProfitCtrlSLMultiplier == takeProfitCtrlSLMultiplier && cacheTickHunter[idx].TakeProfitRefreshManagementEnabled == takeProfitRefreshManagementEnabled && cacheTickHunter[idx].AutoPositionBreakEvenType == autoPositionBreakEvenType && cacheTickHunter[idx].BreakEvenInitialTicks == breakEvenInitialTicks && cacheTickHunter[idx].BreakEvenJumpTicks == breakEvenJumpTicks && cacheTickHunter[idx].BreakEvenTurboJumpTicks == breakEvenTurboJumpTicks && cacheTickHunter[idx].BreakEvenAutoTrailNow == breakEvenAutoTrailNow && cacheTickHunter[idx].BreakEvenAutoTriggerTicks == breakEvenAutoTriggerTicks && cacheTickHunter[idx].BreakEvenAutoTriggerATRMultiplier == breakEvenAutoTriggerATRMultiplier && cacheTickHunter[idx].BreakEvenAutoZombieFlipResumeSnapType == breakEvenAutoZombieFlipResumeSnapType && cacheTickHunter[idx].BreakEvenAutoCreeperFlipSnapType == breakEvenAutoCreeperFlipSnapType && cacheTickHunter[idx].UseIntradayMarginCheck == useIntradayMarginCheck && cacheTickHunter[idx].LimitTrancheVolumeToInProfit == limitTrancheVolumeToInProfit && cacheTickHunter[idx].LimitToVolumeMaxOption == limitToVolumeMaxOption && cacheTickHunter[idx].EntryVolumeMaxOption1 == entryVolumeMaxOption1 && cacheTickHunter[idx].EntryVolumeMaxOption2 == entryVolumeMaxOption2 && cacheTickHunter[idx].EntryVolumeMaxOption3 == entryVolumeMaxOption3 && cacheTickHunter[idx].EntryVolumeMaxOption4 == entryVolumeMaxOption4 && cacheTickHunter[idx].EntryVolumeMaxOption5 == entryVolumeMaxOption5 && cacheTickHunter[idx].MaxInitialTrancheVolumeSize == maxInitialTrancheVolumeSize && cacheTickHunter[idx].LimitTrancheVolumePerBar == limitTrancheVolumePerBar && cacheTickHunter[idx].MinTrancheVolumeDelaySeconds == minTrancheVolumeDelaySeconds && cacheTickHunter[idx].UsePopCTRLDelayedEntry == usePopCTRLDelayedEntry && cacheTickHunter[idx].UsePopLimitToPullback == usePopLimitToPullback && cacheTickHunter[idx].PopDelayedEntryMaxCount == popDelayedEntryMaxCount && cacheTickHunter[idx].PopInitialTicks == popInitialTicks && cacheTickHunter[idx].PopInitialATRMultiplier == popInitialATRMultiplier && cacheTickHunter[idx].PopJumpTicks == popJumpTicks && cacheTickHunter[idx].UsePopAutoJumpToSnap == usePopAutoJumpToSnap && cacheTickHunter[idx].DropInitialTicks == dropInitialTicks && cacheTickHunter[idx].DropInitialATRMultiplier == dropInitialATRMultiplier && cacheTickHunter[idx].DropJumpTicks == dropJumpTicks && cacheTickHunter[idx].UseDropAutoJumpToSnap == useDropAutoJumpToSnap && cacheTickHunter[idx].UsePopDropOnBarUpdateDelay == usePopDropOnBarUpdateDelay && cacheTickHunter[idx].PopDropThrottleMilliseconds == popDropThrottleMilliseconds && cacheTickHunter[idx].AutoEntryVolumeType == autoEntryVolumeType && cacheTickHunter[idx].AutoEntryVolumeOption1 == autoEntryVolumeOption1 && cacheTickHunter[idx].AutoEntryVolumeOption2 == autoEntryVolumeOption2 && cacheTickHunter[idx].AutoEntryVolumeOption3 == autoEntryVolumeOption3 && cacheTickHunter[idx].AutoEntryVolumeOption4 == autoEntryVolumeOption4 && cacheTickHunter[idx].AutoEntryVolumeOption5 == autoEntryVolumeOption5 && cacheTickHunter[idx].AutoPilotOrderType == autoPilotOrderType && cacheTickHunter[idx].AutoPilotTradeSignalType == autoPilotTradeSignalType && cacheTickHunter[idx].AutoPilotSetupType == autoPilotSetupType && cacheTickHunter[idx].UseAutoPilotLite == useAutoPilotLite && cacheTickHunter[idx].UseAutoPilotAddOn == useAutoPilotAddOn && cacheTickHunter[idx].AutoPilotMaxVolume == autoPilotMaxVolume && cacheTickHunter[idx].UseAutoPilotSpeedLineFilter == useAutoPilotSpeedLineFilter && cacheTickHunter[idx].AutoPilotSpeedLineFilterPeriod == autoPilotSpeedLineFilterPeriod && cacheTickHunter[idx].AutoPilotSetupFilterPeriod == autoPilotSetupFilterPeriod && cacheTickHunter[idx].AutoPilotSetupZombiePeriod == autoPilotSetupZombiePeriod && cacheTickHunter[idx].AutoPilotSetupZombieMultiplier == autoPilotSetupZombieMultiplier && cacheTickHunter[idx].AutoPilotSetupCreeperPeriod1 == autoPilotSetupCreeperPeriod1 && cacheTickHunter[idx].AutoPilotSetupCreeperPeriod2 == autoPilotSetupCreeperPeriod2 && cacheTickHunter[idx].AutoPilotSetupCreeperPeriod3 == autoPilotSetupCreeperPeriod3 && cacheTickHunter[idx].AutoPilotSetupWalkerPeriod == autoPilotSetupWalkerPeriod && cacheTickHunter[idx].AutoPilotSetupWalkerFreshCrossOnly == autoPilotSetupWalkerFreshCrossOnly && cacheTickHunter[idx].AutoPilotProfileSetupType == autoPilotProfileSetupType && cacheTickHunter[idx].UsePeppyLimitPopDelayedEntry == usePeppyLimitPopDelayedEntry && cacheTickHunter[idx].UsePeppyLimitPopToPullback == usePeppyLimitPopToPullback && cacheTickHunter[idx].UsePeppyLimitPopAlignedCreeper == usePeppyLimitPopAlignedCreeper && cacheTickHunter[idx].UsePeppyLimitPopAlignedRushLine == usePeppyLimitPopAlignedRushLine && cacheTickHunter[idx].UseSleepyLimitPopDelayedEntry == useSleepyLimitPopDelayedEntry && cacheTickHunter[idx].UseSleepyLimitPopToPullback == useSleepyLimitPopToPullback && cacheTickHunter[idx].UseSleepyLimitPopCounterCreeper == useSleepyLimitPopCounterCreeper && cacheTickHunter[idx].UseSleepyLimitPopCounterRushLine == useSleepyLimitPopCounterRushLine && cacheTickHunter[idx].AutoPositionCloseType == autoPositionCloseType && cacheTickHunter[idx].UseAutoCloseMinProfit == useAutoCloseMinProfit && cacheTickHunter[idx].AutoCloseMinProfitDollarsPerVolume == autoCloseMinProfitDollarsPerVolume && cacheTickHunter[idx].UseAutoCloseAlert == useAutoCloseAlert && cacheTickHunter[idx].AutoCloseAndTrailOffsetTicks == autoCloseAndTrailOffsetTicks && cacheTickHunter[idx].AutoCloseAndTrailMA1Period == autoCloseAndTrailMA1Period && cacheTickHunter[idx].AutoCloseAndTrailMA2Period == autoCloseAndTrailMA2Period && cacheTickHunter[idx].AutoCloseAndTrailMA3Period == autoCloseAndTrailMA3Period && cacheTickHunter[idx].AutoCloseAndTrailMA4Period == autoCloseAndTrailMA4Period && cacheTickHunter[idx].AutoCloseAndTrailZL1Period == autoCloseAndTrailZL1Period && cacheTickHunter[idx].AutoCloseAndTrailZL2Period == autoCloseAndTrailZL2Period && cacheTickHunter[idx].AutoCloseAndTrailRLPeriod == autoCloseAndTrailRLPeriod && cacheTickHunter[idx].AutoCloseAndTrailDL1Period == autoCloseAndTrailDL1Period && cacheTickHunter[idx].AutoCloseAndTrailDL2Period == autoCloseAndTrailDL2Period && cacheTickHunter[idx].AutoCloseAndTrailDL3Period == autoCloseAndTrailDL3Period && cacheTickHunter[idx].AutoCloseAndTrailDL4Period == autoCloseAndTrailDL4Period && cacheTickHunter[idx].AutoCloseAndTrailR1Period == autoCloseAndTrailR1Period && cacheTickHunter[idx].AutoCloseAndTrailR5Period == autoCloseAndTrailR5Period && cacheTickHunter[idx].AutoCloseAndTrailKLine1Period == autoCloseAndTrailKLine1Period && cacheTickHunter[idx].AutoCloseAndTrailKLine1Multiplier == autoCloseAndTrailKLine1Multiplier && cacheTickHunter[idx].AutoCloseAndTrailKLine2Period == autoCloseAndTrailKLine2Period && cacheTickHunter[idx].AutoCloseAndTrailKLine2Multiplier == autoCloseAndTrailKLine2Multiplier && cacheTickHunter[idx].BogeyTargetStartWithFullPnL == bogeyTargetStartWithFullPnL && cacheTickHunter[idx].BogeyTargetBaseDollars == bogeyTargetBaseDollars && cacheTickHunter[idx].BogeyTargetDailyBaseDollars == bogeyTargetDailyBaseDollars && cacheTickHunter[idx].ShowBogeyTargetDailyBreakEvenLine == showBogeyTargetDailyBreakEvenLine && cacheTickHunter[idx].ShowBogeyTargetDaily1Line == showBogeyTargetDaily1Line && cacheTickHunter[idx].ShowBogeyTargetDaily2Line == showBogeyTargetDaily2Line && cacheTickHunter[idx].ShowBogeyTargetDaily3Line == showBogeyTargetDaily3Line && cacheTickHunter[idx].ShowBogeyTargetDaily4Line == showBogeyTargetDaily4Line && cacheTickHunter[idx].ShowBogeyTargetDaily5Line == showBogeyTargetDaily5Line && cacheTickHunter[idx].ECATargetDollars == eCATargetDollars && cacheTickHunter[idx].ECATargetDollarsPerOtherVolume == eCATargetDollarsPerOtherVolume && cacheTickHunter[idx].ECATargetDollarsPerMNQVolume == eCATargetDollarsPerMNQVolume && cacheTickHunter[idx].ECATargetDollarsPerNQVolume == eCATargetDollarsPerNQVolume && cacheTickHunter[idx].ECATargetDollarsPerM2KVolume == eCATargetDollarsPerM2KVolume && cacheTickHunter[idx].ECATargetDollarsPerRTYVolume == eCATargetDollarsPerRTYVolume && cacheTickHunter[idx].ECATargetDollarsPerMESVolume == eCATargetDollarsPerMESVolume && cacheTickHunter[idx].ECATargetDollarsPerESVolume == eCATargetDollarsPerESVolume && cacheTickHunter[idx].ECATargetDollarsPerMYMVolume == eCATargetDollarsPerMYMVolume && cacheTickHunter[idx].ECATargetDollarsPerYMVolume == eCATargetDollarsPerYMVolume && cacheTickHunter[idx].ECATargetATRMultiplierPerVolume == eCATargetATRMultiplierPerVolume && cacheTickHunter[idx].AutoAddOnMaxDollars == autoAddOnMaxDollars && cacheTickHunter[idx].UseDayOverMaxLossTrailing == useDayOverMaxLossTrailing && cacheTickHunter[idx].DayOverMaxLossDollars == dayOverMaxLossDollars && cacheTickHunter[idx].DayOverMaxLossBTBaseRatio == dayOverMaxLossBTBaseRatio && cacheTickHunter[idx].DayOverMaxAccountPnLPeakDollars == dayOverMaxAccountPnLPeakDollars && cacheTickHunter[idx].DayOverAccountBalanceFloorDollars == dayOverAccountBalanceFloorDollars && cacheTickHunter[idx].ECAMaxDDInDollars == eCAMaxDDInDollars && cacheTickHunter[idx].ExcessIntradayMarginMinDollars == excessIntradayMarginMinDollars && cacheTickHunter[idx].ShowButtonAutoBreakEven == showButtonAutoBreakEven && cacheTickHunter[idx].ShowButtonReverse == showButtonReverse && cacheTickHunter[idx].ShowButtonClose == showButtonClose && cacheTickHunter[idx].ShowButtonAutoClose == showButtonAutoClose && cacheTickHunter[idx].ShowButtonProfitTarget == showButtonProfitTarget && cacheTickHunter[idx].ShowButtonTPPlus == showButtonTPPlus && cacheTickHunter[idx].ShowButtonBEPlus == showButtonBEPlus && cacheTickHunter[idx].ShowButtonSLPlus == showButtonSLPlus && cacheTickHunter[idx].ShowButtonBuyMarket == showButtonBuyMarket && cacheTickHunter[idx].ShowButtonSellMarket == showButtonSellMarket && cacheTickHunter[idx].ShowButtonPopPlus == showButtonPopPlus && cacheTickHunter[idx].ShowButtonPopMinus == showButtonPopMinus && cacheTickHunter[idx].ShowButtonDropMinus == showButtonDropMinus && cacheTickHunter[idx].ShowButtonDropPlus == showButtonDropPlus && cacheTickHunter[idx].ShowButtonAutoAddOn == showButtonAutoAddOn && cacheTickHunter[idx].ShowButtonTradeSignal == showButtonTradeSignal && cacheTickHunter[idx].ShowButtonAutoPilotProfile == showButtonAutoPilotProfile && cacheTickHunter[idx].ShowButtonAutoPilot == showButtonAutoPilot && cacheTickHunter[idx].ShowButtonVolumeMax == showButtonVolumeMax && cacheTickHunter[idx].ShowButtonVolume == showButtonVolume && cacheTickHunter[idx].UseBlendedInstruments == useBlendedInstruments && cacheTickHunter[idx].ShowAveragePriceLine == showAveragePriceLine && cacheTickHunter[idx].ShowAveragePriceLineQuantity == showAveragePriceLineQuantity && cacheTickHunter[idx].ShowAveragePriceLineQuantityInMicros == showAveragePriceLineQuantityInMicros && cacheTickHunter[idx].OtherCommissionPerSide == otherCommissionPerSide && cacheTickHunter[idx].OtherIntradayMarginDollars == otherIntradayMarginDollars && cacheTickHunter[idx].OtherPositionMaxVolume == otherPositionMaxVolume && cacheTickHunter[idx].MNQCommissionPerSide == mNQCommissionPerSide && cacheTickHunter[idx].MNQIntradayMarginDollars == mNQIntradayMarginDollars && cacheTickHunter[idx].MNQPositionMaxVolume == mNQPositionMaxVolume && cacheTickHunter[idx].NQCommissionPerSide == nQCommissionPerSide && cacheTickHunter[idx].NQIntradayMarginDollars == nQIntradayMarginDollars && cacheTickHunter[idx].NQPositionMaxVolume == nQPositionMaxVolume && cacheTickHunter[idx].MESCommissionPerSide == mESCommissionPerSide && cacheTickHunter[idx].MESIntradayMarginDollars == mESIntradayMarginDollars && cacheTickHunter[idx].MESPositionMaxVolume == mESPositionMaxVolume && cacheTickHunter[idx].ESCommissionPerSide == eSCommissionPerSide && cacheTickHunter[idx].ESIntradayMarginDollars == eSIntradayMarginDollars && cacheTickHunter[idx].ESPositionMaxVolume == eSPositionMaxVolume && cacheTickHunter[idx].MYMCommissionPerSide == mYMCommissionPerSide && cacheTickHunter[idx].MYMIntradayMarginDollars == mYMIntradayMarginDollars && cacheTickHunter[idx].MYMPositionMaxVolume == mYMPositionMaxVolume && cacheTickHunter[idx].YMCommissionPerSide == yMCommissionPerSide && cacheTickHunter[idx].YMIntradayMarginDollars == yMIntradayMarginDollars && cacheTickHunter[idx].YMPositionMaxVolume == yMPositionMaxVolume && cacheTickHunter[idx].M2KCommissionPerSide == m2KCommissionPerSide && cacheTickHunter[idx].M2KIntradayMarginDollars == m2KIntradayMarginDollars && cacheTickHunter[idx].M2KPositionMaxVolume == m2KPositionMaxVolume && cacheTickHunter[idx].RTYCommissionPerSide == rTYCommissionPerSide && cacheTickHunter[idx].RTYIntradayMarginDollars == rTYIntradayMarginDollars && cacheTickHunter[idx].RTYPositionMaxVolume == rTYPositionMaxVolume && cacheTickHunter[idx].IgnoreInstrumentServerSupport == ignoreInstrumentServerSupport && cacheTickHunter[idx].SnapOffsetTicks == snapOffsetTicks && cacheTickHunter[idx].SnapPowerBoxPeriod == snapPowerBoxPeriod && cacheTickHunter[idx].SnapPowerBoxAutoAdjustPeriodsOnM1 == snapPowerBoxAutoAdjustPeriodsOnM1 && cacheTickHunter[idx].ATRPeriod == aTRPeriod && cacheTickHunter[idx].RefreshTPSLOffsetTicks == refreshTPSLOffsetTicks && cacheTickHunter[idx].RefreshTPSLOrderDelaySeconds == refreshTPSLOrderDelaySeconds && cacheTickHunter[idx].SingleOrderChunkMaxQuantity == singleOrderChunkMaxQuantity && cacheTickHunter[idx].SingleOrderChunkMinQuantity == singleOrderChunkMinQuantity && cacheTickHunter[idx].SingleOrderChunkDelayMilliseconds == singleOrderChunkDelayMilliseconds && cacheTickHunter[idx].RealTimePipeLineThrottleMilliseconds == realTimePipeLineThrottleMilliseconds && cacheTickHunter[idx].UsePositionProfitLogging == usePositionProfitLogging && cacheTickHunter[idx].DebugLogLevel == debugLogLevel && cacheTickHunter[idx].OrderWaitOutputThrottleSeconds == orderWaitOutputThrottleSeconds && cacheTickHunter[idx].UseAccountInfoLogging == useAccountInfoLogging && cacheTickHunter[idx].AccountInfoLoggingPath == accountInfoLoggingPath && cacheTickHunter[idx].EqualsInput(input))
						return cacheTickHunter[idx];
			return CacheIndicator<TickHunterTA.TickHunter>(new TickHunterTA.TickHunter(){ IndicatorName = indicatorName, IndicatorTermsOfUse = indicatorTermsOfUse, ShowIndicatorName = showIndicatorName, IndicatorInfoLink = indicatorInfoLink, UseAutoPositionStopLoss = useAutoPositionStopLoss, StopLossInitialTicks = stopLossInitialTicks, StopLossInitialATRMultiplier = stopLossInitialATRMultiplier, StopLossInitialSnapType = stopLossInitialSnapType, StopLossInitialMaxTicks = stopLossInitialMaxTicks, StopLossInitialDollars = stopLossInitialDollars, StopLossInitialDollarsCombined = stopLossInitialDollarsCombined, StopLossJumpTicks = stopLossJumpTicks, StopLossCTRLJumpTicks = stopLossCTRLJumpTicks, StopLossRefreshOnVolumeChange = stopLossRefreshOnVolumeChange, StopLossRefreshManagementEnabled = stopLossRefreshManagementEnabled, UseAutoPositionTakeProfit = useAutoPositionTakeProfit, TakeProfitInitialTicks = takeProfitInitialTicks, TakeProfitInitialATRMultiplier = takeProfitInitialATRMultiplier, TakeProfitSyncBogeyTargetPrice = takeProfitSyncBogeyTargetPrice, TakeProfitSyncECATargetPrice = takeProfitSyncECATargetPrice, TakeProfitJumpTicks = takeProfitJumpTicks, TakeProfitCtrlSLMultiplier = takeProfitCtrlSLMultiplier, TakeProfitRefreshManagementEnabled = takeProfitRefreshManagementEnabled, AutoPositionBreakEvenType = autoPositionBreakEvenType, BreakEvenInitialTicks = breakEvenInitialTicks, BreakEvenJumpTicks = breakEvenJumpTicks, BreakEvenTurboJumpTicks = breakEvenTurboJumpTicks, BreakEvenAutoTrailNow = breakEvenAutoTrailNow, BreakEvenAutoTriggerTicks = breakEvenAutoTriggerTicks, BreakEvenAutoTriggerATRMultiplier = breakEvenAutoTriggerATRMultiplier, BreakEvenAutoZombieFlipResumeSnapType = breakEvenAutoZombieFlipResumeSnapType, BreakEvenAutoCreeperFlipSnapType = breakEvenAutoCreeperFlipSnapType, UseIntradayMarginCheck = useIntradayMarginCheck, LimitTrancheVolumeToInProfit = limitTrancheVolumeToInProfit, LimitToVolumeMaxOption = limitToVolumeMaxOption, EntryVolumeMaxOption1 = entryVolumeMaxOption1, EntryVolumeMaxOption2 = entryVolumeMaxOption2, EntryVolumeMaxOption3 = entryVolumeMaxOption3, EntryVolumeMaxOption4 = entryVolumeMaxOption4, EntryVolumeMaxOption5 = entryVolumeMaxOption5, MaxInitialTrancheVolumeSize = maxInitialTrancheVolumeSize, LimitTrancheVolumePerBar = limitTrancheVolumePerBar, MinTrancheVolumeDelaySeconds = minTrancheVolumeDelaySeconds, UsePopCTRLDelayedEntry = usePopCTRLDelayedEntry, UsePopLimitToPullback = usePopLimitToPullback, PopDelayedEntryMaxCount = popDelayedEntryMaxCount, PopInitialTicks = popInitialTicks, PopInitialATRMultiplier = popInitialATRMultiplier, PopJumpTicks = popJumpTicks, UsePopAutoJumpToSnap = usePopAutoJumpToSnap, DropInitialTicks = dropInitialTicks, DropInitialATRMultiplier = dropInitialATRMultiplier, DropJumpTicks = dropJumpTicks, UseDropAutoJumpToSnap = useDropAutoJumpToSnap, UsePopDropOnBarUpdateDelay = usePopDropOnBarUpdateDelay, PopDropThrottleMilliseconds = popDropThrottleMilliseconds, AutoEntryVolumeType = autoEntryVolumeType, AutoEntryVolumeOption1 = autoEntryVolumeOption1, AutoEntryVolumeOption2 = autoEntryVolumeOption2, AutoEntryVolumeOption3 = autoEntryVolumeOption3, AutoEntryVolumeOption4 = autoEntryVolumeOption4, AutoEntryVolumeOption5 = autoEntryVolumeOption5, AutoPilotOrderType = autoPilotOrderType, AutoPilotTradeSignalType = autoPilotTradeSignalType, AutoPilotSetupType = autoPilotSetupType, UseAutoPilotLite = useAutoPilotLite, UseAutoPilotAddOn = useAutoPilotAddOn, AutoPilotMaxVolume = autoPilotMaxVolume, UseAutoPilotSpeedLineFilter = useAutoPilotSpeedLineFilter, AutoPilotSpeedLineFilterPeriod = autoPilotSpeedLineFilterPeriod, AutoPilotSetupFilterPeriod = autoPilotSetupFilterPeriod, AutoPilotSetupZombiePeriod = autoPilotSetupZombiePeriod, AutoPilotSetupZombieMultiplier = autoPilotSetupZombieMultiplier, AutoPilotSetupCreeperPeriod1 = autoPilotSetupCreeperPeriod1, AutoPilotSetupCreeperPeriod2 = autoPilotSetupCreeperPeriod2, AutoPilotSetupCreeperPeriod3 = autoPilotSetupCreeperPeriod3, AutoPilotSetupWalkerPeriod = autoPilotSetupWalkerPeriod, AutoPilotSetupWalkerFreshCrossOnly = autoPilotSetupWalkerFreshCrossOnly, AutoPilotProfileSetupType = autoPilotProfileSetupType, UsePeppyLimitPopDelayedEntry = usePeppyLimitPopDelayedEntry, UsePeppyLimitPopToPullback = usePeppyLimitPopToPullback, UsePeppyLimitPopAlignedCreeper = usePeppyLimitPopAlignedCreeper, UsePeppyLimitPopAlignedRushLine = usePeppyLimitPopAlignedRushLine, UseSleepyLimitPopDelayedEntry = useSleepyLimitPopDelayedEntry, UseSleepyLimitPopToPullback = useSleepyLimitPopToPullback, UseSleepyLimitPopCounterCreeper = useSleepyLimitPopCounterCreeper, UseSleepyLimitPopCounterRushLine = useSleepyLimitPopCounterRushLine, AutoPositionCloseType = autoPositionCloseType, UseAutoCloseMinProfit = useAutoCloseMinProfit, AutoCloseMinProfitDollarsPerVolume = autoCloseMinProfitDollarsPerVolume, UseAutoCloseAlert = useAutoCloseAlert, AutoCloseAndTrailOffsetTicks = autoCloseAndTrailOffsetTicks, AutoCloseAndTrailMA1Period = autoCloseAndTrailMA1Period, AutoCloseAndTrailMA2Period = autoCloseAndTrailMA2Period, AutoCloseAndTrailMA3Period = autoCloseAndTrailMA3Period, AutoCloseAndTrailMA4Period = autoCloseAndTrailMA4Period, AutoCloseAndTrailZL1Period = autoCloseAndTrailZL1Period, AutoCloseAndTrailZL2Period = autoCloseAndTrailZL2Period, AutoCloseAndTrailRLPeriod = autoCloseAndTrailRLPeriod, AutoCloseAndTrailDL1Period = autoCloseAndTrailDL1Period, AutoCloseAndTrailDL2Period = autoCloseAndTrailDL2Period, AutoCloseAndTrailDL3Period = autoCloseAndTrailDL3Period, AutoCloseAndTrailDL4Period = autoCloseAndTrailDL4Period, AutoCloseAndTrailR1Period = autoCloseAndTrailR1Period, AutoCloseAndTrailR5Period = autoCloseAndTrailR5Period, AutoCloseAndTrailKLine1Period = autoCloseAndTrailKLine1Period, AutoCloseAndTrailKLine1Multiplier = autoCloseAndTrailKLine1Multiplier, AutoCloseAndTrailKLine2Period = autoCloseAndTrailKLine2Period, AutoCloseAndTrailKLine2Multiplier = autoCloseAndTrailKLine2Multiplier, BogeyTargetStartWithFullPnL = bogeyTargetStartWithFullPnL, BogeyTargetBaseDollars = bogeyTargetBaseDollars, BogeyTargetDailyBaseDollars = bogeyTargetDailyBaseDollars, ShowBogeyTargetDailyBreakEvenLine = showBogeyTargetDailyBreakEvenLine, ShowBogeyTargetDaily1Line = showBogeyTargetDaily1Line, ShowBogeyTargetDaily2Line = showBogeyTargetDaily2Line, ShowBogeyTargetDaily3Line = showBogeyTargetDaily3Line, ShowBogeyTargetDaily4Line = showBogeyTargetDaily4Line, ShowBogeyTargetDaily5Line = showBogeyTargetDaily5Line, ECATargetDollars = eCATargetDollars, ECATargetDollarsPerOtherVolume = eCATargetDollarsPerOtherVolume, ECATargetDollarsPerMNQVolume = eCATargetDollarsPerMNQVolume, ECATargetDollarsPerNQVolume = eCATargetDollarsPerNQVolume, ECATargetDollarsPerM2KVolume = eCATargetDollarsPerM2KVolume, ECATargetDollarsPerRTYVolume = eCATargetDollarsPerRTYVolume, ECATargetDollarsPerMESVolume = eCATargetDollarsPerMESVolume, ECATargetDollarsPerESVolume = eCATargetDollarsPerESVolume, ECATargetDollarsPerMYMVolume = eCATargetDollarsPerMYMVolume, ECATargetDollarsPerYMVolume = eCATargetDollarsPerYMVolume, ECATargetATRMultiplierPerVolume = eCATargetATRMultiplierPerVolume, AutoAddOnMaxDollars = autoAddOnMaxDollars, UseDayOverMaxLossTrailing = useDayOverMaxLossTrailing, DayOverMaxLossDollars = dayOverMaxLossDollars, DayOverMaxLossBTBaseRatio = dayOverMaxLossBTBaseRatio, DayOverMaxAccountPnLPeakDollars = dayOverMaxAccountPnLPeakDollars, DayOverAccountBalanceFloorDollars = dayOverAccountBalanceFloorDollars, ECAMaxDDInDollars = eCAMaxDDInDollars, ExcessIntradayMarginMinDollars = excessIntradayMarginMinDollars, ShowButtonAutoBreakEven = showButtonAutoBreakEven, ShowButtonReverse = showButtonReverse, ShowButtonClose = showButtonClose, ShowButtonAutoClose = showButtonAutoClose, ShowButtonProfitTarget = showButtonProfitTarget, ShowButtonTPPlus = showButtonTPPlus, ShowButtonBEPlus = showButtonBEPlus, ShowButtonSLPlus = showButtonSLPlus, ShowButtonBuyMarket = showButtonBuyMarket, ShowButtonSellMarket = showButtonSellMarket, ShowButtonPopPlus = showButtonPopPlus, ShowButtonPopMinus = showButtonPopMinus, ShowButtonDropMinus = showButtonDropMinus, ShowButtonDropPlus = showButtonDropPlus, ShowButtonAutoAddOn = showButtonAutoAddOn, ShowButtonTradeSignal = showButtonTradeSignal, ShowButtonAutoPilotProfile = showButtonAutoPilotProfile, ShowButtonAutoPilot = showButtonAutoPilot, ShowButtonVolumeMax = showButtonVolumeMax, ShowButtonVolume = showButtonVolume, UseBlendedInstruments = useBlendedInstruments, ShowAveragePriceLine = showAveragePriceLine, ShowAveragePriceLineQuantity = showAveragePriceLineQuantity, ShowAveragePriceLineQuantityInMicros = showAveragePriceLineQuantityInMicros, OtherCommissionPerSide = otherCommissionPerSide, OtherIntradayMarginDollars = otherIntradayMarginDollars, OtherPositionMaxVolume = otherPositionMaxVolume, MNQCommissionPerSide = mNQCommissionPerSide, MNQIntradayMarginDollars = mNQIntradayMarginDollars, MNQPositionMaxVolume = mNQPositionMaxVolume, NQCommissionPerSide = nQCommissionPerSide, NQIntradayMarginDollars = nQIntradayMarginDollars, NQPositionMaxVolume = nQPositionMaxVolume, MESCommissionPerSide = mESCommissionPerSide, MESIntradayMarginDollars = mESIntradayMarginDollars, MESPositionMaxVolume = mESPositionMaxVolume, ESCommissionPerSide = eSCommissionPerSide, ESIntradayMarginDollars = eSIntradayMarginDollars, ESPositionMaxVolume = eSPositionMaxVolume, MYMCommissionPerSide = mYMCommissionPerSide, MYMIntradayMarginDollars = mYMIntradayMarginDollars, MYMPositionMaxVolume = mYMPositionMaxVolume, YMCommissionPerSide = yMCommissionPerSide, YMIntradayMarginDollars = yMIntradayMarginDollars, YMPositionMaxVolume = yMPositionMaxVolume, M2KCommissionPerSide = m2KCommissionPerSide, M2KIntradayMarginDollars = m2KIntradayMarginDollars, M2KPositionMaxVolume = m2KPositionMaxVolume, RTYCommissionPerSide = rTYCommissionPerSide, RTYIntradayMarginDollars = rTYIntradayMarginDollars, RTYPositionMaxVolume = rTYPositionMaxVolume, IgnoreInstrumentServerSupport = ignoreInstrumentServerSupport, SnapOffsetTicks = snapOffsetTicks, SnapPowerBoxPeriod = snapPowerBoxPeriod, SnapPowerBoxAutoAdjustPeriodsOnM1 = snapPowerBoxAutoAdjustPeriodsOnM1, ATRPeriod = aTRPeriod, RefreshTPSLOffsetTicks = refreshTPSLOffsetTicks, RefreshTPSLOrderDelaySeconds = refreshTPSLOrderDelaySeconds, SingleOrderChunkMaxQuantity = singleOrderChunkMaxQuantity, SingleOrderChunkMinQuantity = singleOrderChunkMinQuantity, SingleOrderChunkDelayMilliseconds = singleOrderChunkDelayMilliseconds, RealTimePipeLineThrottleMilliseconds = realTimePipeLineThrottleMilliseconds, UsePositionProfitLogging = usePositionProfitLogging, DebugLogLevel = debugLogLevel, OrderWaitOutputThrottleSeconds = orderWaitOutputThrottleSeconds, UseAccountInfoLogging = useAccountInfoLogging, AccountInfoLoggingPath = accountInfoLoggingPath }, input, ref cacheTickHunter);
		}
	}
}

namespace NinjaTrader.NinjaScript.MarketAnalyzerColumns
{
	public partial class MarketAnalyzerColumn : MarketAnalyzerColumnBase
	{
		public Indicators.TickHunterTA.TickHunter TickHunter(string indicatorName, string indicatorTermsOfUse, bool showIndicatorName, string indicatorInfoLink, bool useAutoPositionStopLoss, int stopLossInitialTicks, double stopLossInitialATRMultiplier, TickHunterStopLossSnapTypes stopLossInitialSnapType, int stopLossInitialMaxTicks, double stopLossInitialDollars, bool stopLossInitialDollarsCombined, int stopLossJumpTicks, bool stopLossCTRLJumpTicks, bool stopLossRefreshOnVolumeChange, bool stopLossRefreshManagementEnabled, bool useAutoPositionTakeProfit, int takeProfitInitialTicks, double takeProfitInitialATRMultiplier, bool takeProfitSyncBogeyTargetPrice, bool takeProfitSyncECATargetPrice, int takeProfitJumpTicks, double takeProfitCtrlSLMultiplier, bool takeProfitRefreshManagementEnabled, TickHunterBreakEvenAutoTypes autoPositionBreakEvenType, int breakEvenInitialTicks, int breakEvenJumpTicks, int breakEvenTurboJumpTicks, TickHunterBreakEvenAutoTrailNowTypes breakEvenAutoTrailNow, int breakEvenAutoTriggerTicks, double breakEvenAutoTriggerATRMultiplier, TickHunterStopLossSnapTypes breakEvenAutoZombieFlipResumeSnapType, TickHunterStopLossSnapTypes breakEvenAutoCreeperFlipSnapType, bool useIntradayMarginCheck, bool limitTrancheVolumeToInProfit, bool limitToVolumeMaxOption, int entryVolumeMaxOption1, int entryVolumeMaxOption2, int entryVolumeMaxOption3, int entryVolumeMaxOption4, int entryVolumeMaxOption5, int maxInitialTrancheVolumeSize, bool limitTrancheVolumePerBar, int minTrancheVolumeDelaySeconds, bool usePopCTRLDelayedEntry, bool usePopLimitToPullback, int popDelayedEntryMaxCount, int popInitialTicks, double popInitialATRMultiplier, int popJumpTicks, bool usePopAutoJumpToSnap, int dropInitialTicks, double dropInitialATRMultiplier, int dropJumpTicks, bool useDropAutoJumpToSnap, bool usePopDropOnBarUpdateDelay, long popDropThrottleMilliseconds, TickHunterEntryVolumeAutoTypes autoEntryVolumeType, int autoEntryVolumeOption1, int autoEntryVolumeOption2, int autoEntryVolumeOption3, int autoEntryVolumeOption4, int autoEntryVolumeOption5, TickHunterAutoPilotOrderTypes autoPilotOrderType, TickHunterTradeSignalTypes autoPilotTradeSignalType, TickHunterAutoPilotSetupTypes autoPilotSetupType, bool useAutoPilotLite, bool useAutoPilotAddOn, int autoPilotMaxVolume, bool useAutoPilotSpeedLineFilter, int autoPilotSpeedLineFilterPeriod, int autoPilotSetupFilterPeriod, int autoPilotSetupZombiePeriod, double autoPilotSetupZombieMultiplier, int autoPilotSetupCreeperPeriod1, int autoPilotSetupCreeperPeriod2, int autoPilotSetupCreeperPeriod3, int autoPilotSetupWalkerPeriod, bool autoPilotSetupWalkerFreshCrossOnly, TickHunterAutoPilotProfileSetupTypes autoPilotProfileSetupType, bool usePeppyLimitPopDelayedEntry, bool usePeppyLimitPopToPullback, bool usePeppyLimitPopAlignedCreeper, bool usePeppyLimitPopAlignedRushLine, bool useSleepyLimitPopDelayedEntry, bool useSleepyLimitPopToPullback, bool useSleepyLimitPopCounterCreeper, bool useSleepyLimitPopCounterRushLine, TickHunterCloseAutoTypes autoPositionCloseType, bool useAutoCloseMinProfit, double autoCloseMinProfitDollarsPerVolume, bool useAutoCloseAlert, int autoCloseAndTrailOffsetTicks, int autoCloseAndTrailMA1Period, int autoCloseAndTrailMA2Period, int autoCloseAndTrailMA3Period, int autoCloseAndTrailMA4Period, int autoCloseAndTrailZL1Period, int autoCloseAndTrailZL2Period, int autoCloseAndTrailRLPeriod, int autoCloseAndTrailDL1Period, int autoCloseAndTrailDL2Period, int autoCloseAndTrailDL3Period, int autoCloseAndTrailDL4Period, int autoCloseAndTrailR1Period, int autoCloseAndTrailR5Period, int autoCloseAndTrailKLine1Period, double autoCloseAndTrailKLine1Multiplier, int autoCloseAndTrailKLine2Period, double autoCloseAndTrailKLine2Multiplier, bool bogeyTargetStartWithFullPnL, double bogeyTargetBaseDollars, double bogeyTargetDailyBaseDollars, bool showBogeyTargetDailyBreakEvenLine, bool showBogeyTargetDaily1Line, bool showBogeyTargetDaily2Line, bool showBogeyTargetDaily3Line, bool showBogeyTargetDaily4Line, bool showBogeyTargetDaily5Line, double eCATargetDollars, double eCATargetDollarsPerOtherVolume, double eCATargetDollarsPerMNQVolume, double eCATargetDollarsPerNQVolume, double eCATargetDollarsPerM2KVolume, double eCATargetDollarsPerRTYVolume, double eCATargetDollarsPerMESVolume, double eCATargetDollarsPerESVolume, double eCATargetDollarsPerMYMVolume, double eCATargetDollarsPerYMVolume, double eCATargetATRMultiplierPerVolume, double autoAddOnMaxDollars, bool useDayOverMaxLossTrailing, double dayOverMaxLossDollars, double dayOverMaxLossBTBaseRatio, double dayOverMaxAccountPnLPeakDollars, double dayOverAccountBalanceFloorDollars, double eCAMaxDDInDollars, double excessIntradayMarginMinDollars, bool showButtonAutoBreakEven, bool showButtonReverse, bool showButtonClose, bool showButtonAutoClose, bool showButtonProfitTarget, bool showButtonTPPlus, bool showButtonBEPlus, bool showButtonSLPlus, bool showButtonBuyMarket, bool showButtonSellMarket, bool showButtonPopPlus, bool showButtonPopMinus, bool showButtonDropMinus, bool showButtonDropPlus, bool showButtonAutoAddOn, bool showButtonTradeSignal, bool showButtonAutoPilotProfile, bool showButtonAutoPilot, bool showButtonVolumeMax, bool showButtonVolume, bool useBlendedInstruments, bool showAveragePriceLine, bool showAveragePriceLineQuantity, bool showAveragePriceLineQuantityInMicros, double otherCommissionPerSide, double otherIntradayMarginDollars, int otherPositionMaxVolume, double mNQCommissionPerSide, double mNQIntradayMarginDollars, int mNQPositionMaxVolume, double nQCommissionPerSide, double nQIntradayMarginDollars, int nQPositionMaxVolume, double mESCommissionPerSide, double mESIntradayMarginDollars, int mESPositionMaxVolume, double eSCommissionPerSide, double eSIntradayMarginDollars, int eSPositionMaxVolume, double mYMCommissionPerSide, double mYMIntradayMarginDollars, int mYMPositionMaxVolume, double yMCommissionPerSide, double yMIntradayMarginDollars, int yMPositionMaxVolume, double m2KCommissionPerSide, double m2KIntradayMarginDollars, int m2KPositionMaxVolume, double rTYCommissionPerSide, double rTYIntradayMarginDollars, int rTYPositionMaxVolume, bool ignoreInstrumentServerSupport, int snapOffsetTicks, int snapPowerBoxPeriod, bool snapPowerBoxAutoAdjustPeriodsOnM1, int aTRPeriod, int refreshTPSLOffsetTicks, int refreshTPSLOrderDelaySeconds, int singleOrderChunkMaxQuantity, int singleOrderChunkMinQuantity, int singleOrderChunkDelayMilliseconds, long realTimePipeLineThrottleMilliseconds, bool usePositionProfitLogging, int debugLogLevel, int orderWaitOutputThrottleSeconds, bool useAccountInfoLogging, string accountInfoLoggingPath)
		{
			return indicator.TickHunter(Input, indicatorName, indicatorTermsOfUse, showIndicatorName, indicatorInfoLink, useAutoPositionStopLoss, stopLossInitialTicks, stopLossInitialATRMultiplier, stopLossInitialSnapType, stopLossInitialMaxTicks, stopLossInitialDollars, stopLossInitialDollarsCombined, stopLossJumpTicks, stopLossCTRLJumpTicks, stopLossRefreshOnVolumeChange, stopLossRefreshManagementEnabled, useAutoPositionTakeProfit, takeProfitInitialTicks, takeProfitInitialATRMultiplier, takeProfitSyncBogeyTargetPrice, takeProfitSyncECATargetPrice, takeProfitJumpTicks, takeProfitCtrlSLMultiplier, takeProfitRefreshManagementEnabled, autoPositionBreakEvenType, breakEvenInitialTicks, breakEvenJumpTicks, breakEvenTurboJumpTicks, breakEvenAutoTrailNow, breakEvenAutoTriggerTicks, breakEvenAutoTriggerATRMultiplier, breakEvenAutoZombieFlipResumeSnapType, breakEvenAutoCreeperFlipSnapType, useIntradayMarginCheck, limitTrancheVolumeToInProfit, limitToVolumeMaxOption, entryVolumeMaxOption1, entryVolumeMaxOption2, entryVolumeMaxOption3, entryVolumeMaxOption4, entryVolumeMaxOption5, maxInitialTrancheVolumeSize, limitTrancheVolumePerBar, minTrancheVolumeDelaySeconds, usePopCTRLDelayedEntry, usePopLimitToPullback, popDelayedEntryMaxCount, popInitialTicks, popInitialATRMultiplier, popJumpTicks, usePopAutoJumpToSnap, dropInitialTicks, dropInitialATRMultiplier, dropJumpTicks, useDropAutoJumpToSnap, usePopDropOnBarUpdateDelay, popDropThrottleMilliseconds, autoEntryVolumeType, autoEntryVolumeOption1, autoEntryVolumeOption2, autoEntryVolumeOption3, autoEntryVolumeOption4, autoEntryVolumeOption5, autoPilotOrderType, autoPilotTradeSignalType, autoPilotSetupType, useAutoPilotLite, useAutoPilotAddOn, autoPilotMaxVolume, useAutoPilotSpeedLineFilter, autoPilotSpeedLineFilterPeriod, autoPilotSetupFilterPeriod, autoPilotSetupZombiePeriod, autoPilotSetupZombieMultiplier, autoPilotSetupCreeperPeriod1, autoPilotSetupCreeperPeriod2, autoPilotSetupCreeperPeriod3, autoPilotSetupWalkerPeriod, autoPilotSetupWalkerFreshCrossOnly, autoPilotProfileSetupType, usePeppyLimitPopDelayedEntry, usePeppyLimitPopToPullback, usePeppyLimitPopAlignedCreeper, usePeppyLimitPopAlignedRushLine, useSleepyLimitPopDelayedEntry, useSleepyLimitPopToPullback, useSleepyLimitPopCounterCreeper, useSleepyLimitPopCounterRushLine, autoPositionCloseType, useAutoCloseMinProfit, autoCloseMinProfitDollarsPerVolume, useAutoCloseAlert, autoCloseAndTrailOffsetTicks, autoCloseAndTrailMA1Period, autoCloseAndTrailMA2Period, autoCloseAndTrailMA3Period, autoCloseAndTrailMA4Period, autoCloseAndTrailZL1Period, autoCloseAndTrailZL2Period, autoCloseAndTrailRLPeriod, autoCloseAndTrailDL1Period, autoCloseAndTrailDL2Period, autoCloseAndTrailDL3Period, autoCloseAndTrailDL4Period, autoCloseAndTrailR1Period, autoCloseAndTrailR5Period, autoCloseAndTrailKLine1Period, autoCloseAndTrailKLine1Multiplier, autoCloseAndTrailKLine2Period, autoCloseAndTrailKLine2Multiplier, bogeyTargetStartWithFullPnL, bogeyTargetBaseDollars, bogeyTargetDailyBaseDollars, showBogeyTargetDailyBreakEvenLine, showBogeyTargetDaily1Line, showBogeyTargetDaily2Line, showBogeyTargetDaily3Line, showBogeyTargetDaily4Line, showBogeyTargetDaily5Line, eCATargetDollars, eCATargetDollarsPerOtherVolume, eCATargetDollarsPerMNQVolume, eCATargetDollarsPerNQVolume, eCATargetDollarsPerM2KVolume, eCATargetDollarsPerRTYVolume, eCATargetDollarsPerMESVolume, eCATargetDollarsPerESVolume, eCATargetDollarsPerMYMVolume, eCATargetDollarsPerYMVolume, eCATargetATRMultiplierPerVolume, autoAddOnMaxDollars, useDayOverMaxLossTrailing, dayOverMaxLossDollars, dayOverMaxLossBTBaseRatio, dayOverMaxAccountPnLPeakDollars, dayOverAccountBalanceFloorDollars, eCAMaxDDInDollars, excessIntradayMarginMinDollars, showButtonAutoBreakEven, showButtonReverse, showButtonClose, showButtonAutoClose, showButtonProfitTarget, showButtonTPPlus, showButtonBEPlus, showButtonSLPlus, showButtonBuyMarket, showButtonSellMarket, showButtonPopPlus, showButtonPopMinus, showButtonDropMinus, showButtonDropPlus, showButtonAutoAddOn, showButtonTradeSignal, showButtonAutoPilotProfile, showButtonAutoPilot, showButtonVolumeMax, showButtonVolume, useBlendedInstruments, showAveragePriceLine, showAveragePriceLineQuantity, showAveragePriceLineQuantityInMicros, otherCommissionPerSide, otherIntradayMarginDollars, otherPositionMaxVolume, mNQCommissionPerSide, mNQIntradayMarginDollars, mNQPositionMaxVolume, nQCommissionPerSide, nQIntradayMarginDollars, nQPositionMaxVolume, mESCommissionPerSide, mESIntradayMarginDollars, mESPositionMaxVolume, eSCommissionPerSide, eSIntradayMarginDollars, eSPositionMaxVolume, mYMCommissionPerSide, mYMIntradayMarginDollars, mYMPositionMaxVolume, yMCommissionPerSide, yMIntradayMarginDollars, yMPositionMaxVolume, m2KCommissionPerSide, m2KIntradayMarginDollars, m2KPositionMaxVolume, rTYCommissionPerSide, rTYIntradayMarginDollars, rTYPositionMaxVolume, ignoreInstrumentServerSupport, snapOffsetTicks, snapPowerBoxPeriod, snapPowerBoxAutoAdjustPeriodsOnM1, aTRPeriod, refreshTPSLOffsetTicks, refreshTPSLOrderDelaySeconds, singleOrderChunkMaxQuantity, singleOrderChunkMinQuantity, singleOrderChunkDelayMilliseconds, realTimePipeLineThrottleMilliseconds, usePositionProfitLogging, debugLogLevel, orderWaitOutputThrottleSeconds, useAccountInfoLogging, accountInfoLoggingPath);
		}

		public Indicators.TickHunterTA.TickHunter TickHunter(ISeries<double> input , string indicatorName, string indicatorTermsOfUse, bool showIndicatorName, string indicatorInfoLink, bool useAutoPositionStopLoss, int stopLossInitialTicks, double stopLossInitialATRMultiplier, TickHunterStopLossSnapTypes stopLossInitialSnapType, int stopLossInitialMaxTicks, double stopLossInitialDollars, bool stopLossInitialDollarsCombined, int stopLossJumpTicks, bool stopLossCTRLJumpTicks, bool stopLossRefreshOnVolumeChange, bool stopLossRefreshManagementEnabled, bool useAutoPositionTakeProfit, int takeProfitInitialTicks, double takeProfitInitialATRMultiplier, bool takeProfitSyncBogeyTargetPrice, bool takeProfitSyncECATargetPrice, int takeProfitJumpTicks, double takeProfitCtrlSLMultiplier, bool takeProfitRefreshManagementEnabled, TickHunterBreakEvenAutoTypes autoPositionBreakEvenType, int breakEvenInitialTicks, int breakEvenJumpTicks, int breakEvenTurboJumpTicks, TickHunterBreakEvenAutoTrailNowTypes breakEvenAutoTrailNow, int breakEvenAutoTriggerTicks, double breakEvenAutoTriggerATRMultiplier, TickHunterStopLossSnapTypes breakEvenAutoZombieFlipResumeSnapType, TickHunterStopLossSnapTypes breakEvenAutoCreeperFlipSnapType, bool useIntradayMarginCheck, bool limitTrancheVolumeToInProfit, bool limitToVolumeMaxOption, int entryVolumeMaxOption1, int entryVolumeMaxOption2, int entryVolumeMaxOption3, int entryVolumeMaxOption4, int entryVolumeMaxOption5, int maxInitialTrancheVolumeSize, bool limitTrancheVolumePerBar, int minTrancheVolumeDelaySeconds, bool usePopCTRLDelayedEntry, bool usePopLimitToPullback, int popDelayedEntryMaxCount, int popInitialTicks, double popInitialATRMultiplier, int popJumpTicks, bool usePopAutoJumpToSnap, int dropInitialTicks, double dropInitialATRMultiplier, int dropJumpTicks, bool useDropAutoJumpToSnap, bool usePopDropOnBarUpdateDelay, long popDropThrottleMilliseconds, TickHunterEntryVolumeAutoTypes autoEntryVolumeType, int autoEntryVolumeOption1, int autoEntryVolumeOption2, int autoEntryVolumeOption3, int autoEntryVolumeOption4, int autoEntryVolumeOption5, TickHunterAutoPilotOrderTypes autoPilotOrderType, TickHunterTradeSignalTypes autoPilotTradeSignalType, TickHunterAutoPilotSetupTypes autoPilotSetupType, bool useAutoPilotLite, bool useAutoPilotAddOn, int autoPilotMaxVolume, bool useAutoPilotSpeedLineFilter, int autoPilotSpeedLineFilterPeriod, int autoPilotSetupFilterPeriod, int autoPilotSetupZombiePeriod, double autoPilotSetupZombieMultiplier, int autoPilotSetupCreeperPeriod1, int autoPilotSetupCreeperPeriod2, int autoPilotSetupCreeperPeriod3, int autoPilotSetupWalkerPeriod, bool autoPilotSetupWalkerFreshCrossOnly, TickHunterAutoPilotProfileSetupTypes autoPilotProfileSetupType, bool usePeppyLimitPopDelayedEntry, bool usePeppyLimitPopToPullback, bool usePeppyLimitPopAlignedCreeper, bool usePeppyLimitPopAlignedRushLine, bool useSleepyLimitPopDelayedEntry, bool useSleepyLimitPopToPullback, bool useSleepyLimitPopCounterCreeper, bool useSleepyLimitPopCounterRushLine, TickHunterCloseAutoTypes autoPositionCloseType, bool useAutoCloseMinProfit, double autoCloseMinProfitDollarsPerVolume, bool useAutoCloseAlert, int autoCloseAndTrailOffsetTicks, int autoCloseAndTrailMA1Period, int autoCloseAndTrailMA2Period, int autoCloseAndTrailMA3Period, int autoCloseAndTrailMA4Period, int autoCloseAndTrailZL1Period, int autoCloseAndTrailZL2Period, int autoCloseAndTrailRLPeriod, int autoCloseAndTrailDL1Period, int autoCloseAndTrailDL2Period, int autoCloseAndTrailDL3Period, int autoCloseAndTrailDL4Period, int autoCloseAndTrailR1Period, int autoCloseAndTrailR5Period, int autoCloseAndTrailKLine1Period, double autoCloseAndTrailKLine1Multiplier, int autoCloseAndTrailKLine2Period, double autoCloseAndTrailKLine2Multiplier, bool bogeyTargetStartWithFullPnL, double bogeyTargetBaseDollars, double bogeyTargetDailyBaseDollars, bool showBogeyTargetDailyBreakEvenLine, bool showBogeyTargetDaily1Line, bool showBogeyTargetDaily2Line, bool showBogeyTargetDaily3Line, bool showBogeyTargetDaily4Line, bool showBogeyTargetDaily5Line, double eCATargetDollars, double eCATargetDollarsPerOtherVolume, double eCATargetDollarsPerMNQVolume, double eCATargetDollarsPerNQVolume, double eCATargetDollarsPerM2KVolume, double eCATargetDollarsPerRTYVolume, double eCATargetDollarsPerMESVolume, double eCATargetDollarsPerESVolume, double eCATargetDollarsPerMYMVolume, double eCATargetDollarsPerYMVolume, double eCATargetATRMultiplierPerVolume, double autoAddOnMaxDollars, bool useDayOverMaxLossTrailing, double dayOverMaxLossDollars, double dayOverMaxLossBTBaseRatio, double dayOverMaxAccountPnLPeakDollars, double dayOverAccountBalanceFloorDollars, double eCAMaxDDInDollars, double excessIntradayMarginMinDollars, bool showButtonAutoBreakEven, bool showButtonReverse, bool showButtonClose, bool showButtonAutoClose, bool showButtonProfitTarget, bool showButtonTPPlus, bool showButtonBEPlus, bool showButtonSLPlus, bool showButtonBuyMarket, bool showButtonSellMarket, bool showButtonPopPlus, bool showButtonPopMinus, bool showButtonDropMinus, bool showButtonDropPlus, bool showButtonAutoAddOn, bool showButtonTradeSignal, bool showButtonAutoPilotProfile, bool showButtonAutoPilot, bool showButtonVolumeMax, bool showButtonVolume, bool useBlendedInstruments, bool showAveragePriceLine, bool showAveragePriceLineQuantity, bool showAveragePriceLineQuantityInMicros, double otherCommissionPerSide, double otherIntradayMarginDollars, int otherPositionMaxVolume, double mNQCommissionPerSide, double mNQIntradayMarginDollars, int mNQPositionMaxVolume, double nQCommissionPerSide, double nQIntradayMarginDollars, int nQPositionMaxVolume, double mESCommissionPerSide, double mESIntradayMarginDollars, int mESPositionMaxVolume, double eSCommissionPerSide, double eSIntradayMarginDollars, int eSPositionMaxVolume, double mYMCommissionPerSide, double mYMIntradayMarginDollars, int mYMPositionMaxVolume, double yMCommissionPerSide, double yMIntradayMarginDollars, int yMPositionMaxVolume, double m2KCommissionPerSide, double m2KIntradayMarginDollars, int m2KPositionMaxVolume, double rTYCommissionPerSide, double rTYIntradayMarginDollars, int rTYPositionMaxVolume, bool ignoreInstrumentServerSupport, int snapOffsetTicks, int snapPowerBoxPeriod, bool snapPowerBoxAutoAdjustPeriodsOnM1, int aTRPeriod, int refreshTPSLOffsetTicks, int refreshTPSLOrderDelaySeconds, int singleOrderChunkMaxQuantity, int singleOrderChunkMinQuantity, int singleOrderChunkDelayMilliseconds, long realTimePipeLineThrottleMilliseconds, bool usePositionProfitLogging, int debugLogLevel, int orderWaitOutputThrottleSeconds, bool useAccountInfoLogging, string accountInfoLoggingPath)
		{
			return indicator.TickHunter(input, indicatorName, indicatorTermsOfUse, showIndicatorName, indicatorInfoLink, useAutoPositionStopLoss, stopLossInitialTicks, stopLossInitialATRMultiplier, stopLossInitialSnapType, stopLossInitialMaxTicks, stopLossInitialDollars, stopLossInitialDollarsCombined, stopLossJumpTicks, stopLossCTRLJumpTicks, stopLossRefreshOnVolumeChange, stopLossRefreshManagementEnabled, useAutoPositionTakeProfit, takeProfitInitialTicks, takeProfitInitialATRMultiplier, takeProfitSyncBogeyTargetPrice, takeProfitSyncECATargetPrice, takeProfitJumpTicks, takeProfitCtrlSLMultiplier, takeProfitRefreshManagementEnabled, autoPositionBreakEvenType, breakEvenInitialTicks, breakEvenJumpTicks, breakEvenTurboJumpTicks, breakEvenAutoTrailNow, breakEvenAutoTriggerTicks, breakEvenAutoTriggerATRMultiplier, breakEvenAutoZombieFlipResumeSnapType, breakEvenAutoCreeperFlipSnapType, useIntradayMarginCheck, limitTrancheVolumeToInProfit, limitToVolumeMaxOption, entryVolumeMaxOption1, entryVolumeMaxOption2, entryVolumeMaxOption3, entryVolumeMaxOption4, entryVolumeMaxOption5, maxInitialTrancheVolumeSize, limitTrancheVolumePerBar, minTrancheVolumeDelaySeconds, usePopCTRLDelayedEntry, usePopLimitToPullback, popDelayedEntryMaxCount, popInitialTicks, popInitialATRMultiplier, popJumpTicks, usePopAutoJumpToSnap, dropInitialTicks, dropInitialATRMultiplier, dropJumpTicks, useDropAutoJumpToSnap, usePopDropOnBarUpdateDelay, popDropThrottleMilliseconds, autoEntryVolumeType, autoEntryVolumeOption1, autoEntryVolumeOption2, autoEntryVolumeOption3, autoEntryVolumeOption4, autoEntryVolumeOption5, autoPilotOrderType, autoPilotTradeSignalType, autoPilotSetupType, useAutoPilotLite, useAutoPilotAddOn, autoPilotMaxVolume, useAutoPilotSpeedLineFilter, autoPilotSpeedLineFilterPeriod, autoPilotSetupFilterPeriod, autoPilotSetupZombiePeriod, autoPilotSetupZombieMultiplier, autoPilotSetupCreeperPeriod1, autoPilotSetupCreeperPeriod2, autoPilotSetupCreeperPeriod3, autoPilotSetupWalkerPeriod, autoPilotSetupWalkerFreshCrossOnly, autoPilotProfileSetupType, usePeppyLimitPopDelayedEntry, usePeppyLimitPopToPullback, usePeppyLimitPopAlignedCreeper, usePeppyLimitPopAlignedRushLine, useSleepyLimitPopDelayedEntry, useSleepyLimitPopToPullback, useSleepyLimitPopCounterCreeper, useSleepyLimitPopCounterRushLine, autoPositionCloseType, useAutoCloseMinProfit, autoCloseMinProfitDollarsPerVolume, useAutoCloseAlert, autoCloseAndTrailOffsetTicks, autoCloseAndTrailMA1Period, autoCloseAndTrailMA2Period, autoCloseAndTrailMA3Period, autoCloseAndTrailMA4Period, autoCloseAndTrailZL1Period, autoCloseAndTrailZL2Period, autoCloseAndTrailRLPeriod, autoCloseAndTrailDL1Period, autoCloseAndTrailDL2Period, autoCloseAndTrailDL3Period, autoCloseAndTrailDL4Period, autoCloseAndTrailR1Period, autoCloseAndTrailR5Period, autoCloseAndTrailKLine1Period, autoCloseAndTrailKLine1Multiplier, autoCloseAndTrailKLine2Period, autoCloseAndTrailKLine2Multiplier, bogeyTargetStartWithFullPnL, bogeyTargetBaseDollars, bogeyTargetDailyBaseDollars, showBogeyTargetDailyBreakEvenLine, showBogeyTargetDaily1Line, showBogeyTargetDaily2Line, showBogeyTargetDaily3Line, showBogeyTargetDaily4Line, showBogeyTargetDaily5Line, eCATargetDollars, eCATargetDollarsPerOtherVolume, eCATargetDollarsPerMNQVolume, eCATargetDollarsPerNQVolume, eCATargetDollarsPerM2KVolume, eCATargetDollarsPerRTYVolume, eCATargetDollarsPerMESVolume, eCATargetDollarsPerESVolume, eCATargetDollarsPerMYMVolume, eCATargetDollarsPerYMVolume, eCATargetATRMultiplierPerVolume, autoAddOnMaxDollars, useDayOverMaxLossTrailing, dayOverMaxLossDollars, dayOverMaxLossBTBaseRatio, dayOverMaxAccountPnLPeakDollars, dayOverAccountBalanceFloorDollars, eCAMaxDDInDollars, excessIntradayMarginMinDollars, showButtonAutoBreakEven, showButtonReverse, showButtonClose, showButtonAutoClose, showButtonProfitTarget, showButtonTPPlus, showButtonBEPlus, showButtonSLPlus, showButtonBuyMarket, showButtonSellMarket, showButtonPopPlus, showButtonPopMinus, showButtonDropMinus, showButtonDropPlus, showButtonAutoAddOn, showButtonTradeSignal, showButtonAutoPilotProfile, showButtonAutoPilot, showButtonVolumeMax, showButtonVolume, useBlendedInstruments, showAveragePriceLine, showAveragePriceLineQuantity, showAveragePriceLineQuantityInMicros, otherCommissionPerSide, otherIntradayMarginDollars, otherPositionMaxVolume, mNQCommissionPerSide, mNQIntradayMarginDollars, mNQPositionMaxVolume, nQCommissionPerSide, nQIntradayMarginDollars, nQPositionMaxVolume, mESCommissionPerSide, mESIntradayMarginDollars, mESPositionMaxVolume, eSCommissionPerSide, eSIntradayMarginDollars, eSPositionMaxVolume, mYMCommissionPerSide, mYMIntradayMarginDollars, mYMPositionMaxVolume, yMCommissionPerSide, yMIntradayMarginDollars, yMPositionMaxVolume, m2KCommissionPerSide, m2KIntradayMarginDollars, m2KPositionMaxVolume, rTYCommissionPerSide, rTYIntradayMarginDollars, rTYPositionMaxVolume, ignoreInstrumentServerSupport, snapOffsetTicks, snapPowerBoxPeriod, snapPowerBoxAutoAdjustPeriodsOnM1, aTRPeriod, refreshTPSLOffsetTicks, refreshTPSLOrderDelaySeconds, singleOrderChunkMaxQuantity, singleOrderChunkMinQuantity, singleOrderChunkDelayMilliseconds, realTimePipeLineThrottleMilliseconds, usePositionProfitLogging, debugLogLevel, orderWaitOutputThrottleSeconds, useAccountInfoLogging, accountInfoLoggingPath);
		}
	}
}

namespace NinjaTrader.NinjaScript.Strategies
{
	public partial class Strategy : NinjaTrader.Gui.NinjaScript.StrategyRenderBase
	{
		public Indicators.TickHunterTA.TickHunter TickHunter(string indicatorName, string indicatorTermsOfUse, bool showIndicatorName, string indicatorInfoLink, bool useAutoPositionStopLoss, int stopLossInitialTicks, double stopLossInitialATRMultiplier, TickHunterStopLossSnapTypes stopLossInitialSnapType, int stopLossInitialMaxTicks, double stopLossInitialDollars, bool stopLossInitialDollarsCombined, int stopLossJumpTicks, bool stopLossCTRLJumpTicks, bool stopLossRefreshOnVolumeChange, bool stopLossRefreshManagementEnabled, bool useAutoPositionTakeProfit, int takeProfitInitialTicks, double takeProfitInitialATRMultiplier, bool takeProfitSyncBogeyTargetPrice, bool takeProfitSyncECATargetPrice, int takeProfitJumpTicks, double takeProfitCtrlSLMultiplier, bool takeProfitRefreshManagementEnabled, TickHunterBreakEvenAutoTypes autoPositionBreakEvenType, int breakEvenInitialTicks, int breakEvenJumpTicks, int breakEvenTurboJumpTicks, TickHunterBreakEvenAutoTrailNowTypes breakEvenAutoTrailNow, int breakEvenAutoTriggerTicks, double breakEvenAutoTriggerATRMultiplier, TickHunterStopLossSnapTypes breakEvenAutoZombieFlipResumeSnapType, TickHunterStopLossSnapTypes breakEvenAutoCreeperFlipSnapType, bool useIntradayMarginCheck, bool limitTrancheVolumeToInProfit, bool limitToVolumeMaxOption, int entryVolumeMaxOption1, int entryVolumeMaxOption2, int entryVolumeMaxOption3, int entryVolumeMaxOption4, int entryVolumeMaxOption5, int maxInitialTrancheVolumeSize, bool limitTrancheVolumePerBar, int minTrancheVolumeDelaySeconds, bool usePopCTRLDelayedEntry, bool usePopLimitToPullback, int popDelayedEntryMaxCount, int popInitialTicks, double popInitialATRMultiplier, int popJumpTicks, bool usePopAutoJumpToSnap, int dropInitialTicks, double dropInitialATRMultiplier, int dropJumpTicks, bool useDropAutoJumpToSnap, bool usePopDropOnBarUpdateDelay, long popDropThrottleMilliseconds, TickHunterEntryVolumeAutoTypes autoEntryVolumeType, int autoEntryVolumeOption1, int autoEntryVolumeOption2, int autoEntryVolumeOption3, int autoEntryVolumeOption4, int autoEntryVolumeOption5, TickHunterAutoPilotOrderTypes autoPilotOrderType, TickHunterTradeSignalTypes autoPilotTradeSignalType, TickHunterAutoPilotSetupTypes autoPilotSetupType, bool useAutoPilotLite, bool useAutoPilotAddOn, int autoPilotMaxVolume, bool useAutoPilotSpeedLineFilter, int autoPilotSpeedLineFilterPeriod, int autoPilotSetupFilterPeriod, int autoPilotSetupZombiePeriod, double autoPilotSetupZombieMultiplier, int autoPilotSetupCreeperPeriod1, int autoPilotSetupCreeperPeriod2, int autoPilotSetupCreeperPeriod3, int autoPilotSetupWalkerPeriod, bool autoPilotSetupWalkerFreshCrossOnly, TickHunterAutoPilotProfileSetupTypes autoPilotProfileSetupType, bool usePeppyLimitPopDelayedEntry, bool usePeppyLimitPopToPullback, bool usePeppyLimitPopAlignedCreeper, bool usePeppyLimitPopAlignedRushLine, bool useSleepyLimitPopDelayedEntry, bool useSleepyLimitPopToPullback, bool useSleepyLimitPopCounterCreeper, bool useSleepyLimitPopCounterRushLine, TickHunterCloseAutoTypes autoPositionCloseType, bool useAutoCloseMinProfit, double autoCloseMinProfitDollarsPerVolume, bool useAutoCloseAlert, int autoCloseAndTrailOffsetTicks, int autoCloseAndTrailMA1Period, int autoCloseAndTrailMA2Period, int autoCloseAndTrailMA3Period, int autoCloseAndTrailMA4Period, int autoCloseAndTrailZL1Period, int autoCloseAndTrailZL2Period, int autoCloseAndTrailRLPeriod, int autoCloseAndTrailDL1Period, int autoCloseAndTrailDL2Period, int autoCloseAndTrailDL3Period, int autoCloseAndTrailDL4Period, int autoCloseAndTrailR1Period, int autoCloseAndTrailR5Period, int autoCloseAndTrailKLine1Period, double autoCloseAndTrailKLine1Multiplier, int autoCloseAndTrailKLine2Period, double autoCloseAndTrailKLine2Multiplier, bool bogeyTargetStartWithFullPnL, double bogeyTargetBaseDollars, double bogeyTargetDailyBaseDollars, bool showBogeyTargetDailyBreakEvenLine, bool showBogeyTargetDaily1Line, bool showBogeyTargetDaily2Line, bool showBogeyTargetDaily3Line, bool showBogeyTargetDaily4Line, bool showBogeyTargetDaily5Line, double eCATargetDollars, double eCATargetDollarsPerOtherVolume, double eCATargetDollarsPerMNQVolume, double eCATargetDollarsPerNQVolume, double eCATargetDollarsPerM2KVolume, double eCATargetDollarsPerRTYVolume, double eCATargetDollarsPerMESVolume, double eCATargetDollarsPerESVolume, double eCATargetDollarsPerMYMVolume, double eCATargetDollarsPerYMVolume, double eCATargetATRMultiplierPerVolume, double autoAddOnMaxDollars, bool useDayOverMaxLossTrailing, double dayOverMaxLossDollars, double dayOverMaxLossBTBaseRatio, double dayOverMaxAccountPnLPeakDollars, double dayOverAccountBalanceFloorDollars, double eCAMaxDDInDollars, double excessIntradayMarginMinDollars, bool showButtonAutoBreakEven, bool showButtonReverse, bool showButtonClose, bool showButtonAutoClose, bool showButtonProfitTarget, bool showButtonTPPlus, bool showButtonBEPlus, bool showButtonSLPlus, bool showButtonBuyMarket, bool showButtonSellMarket, bool showButtonPopPlus, bool showButtonPopMinus, bool showButtonDropMinus, bool showButtonDropPlus, bool showButtonAutoAddOn, bool showButtonTradeSignal, bool showButtonAutoPilotProfile, bool showButtonAutoPilot, bool showButtonVolumeMax, bool showButtonVolume, bool useBlendedInstruments, bool showAveragePriceLine, bool showAveragePriceLineQuantity, bool showAveragePriceLineQuantityInMicros, double otherCommissionPerSide, double otherIntradayMarginDollars, int otherPositionMaxVolume, double mNQCommissionPerSide, double mNQIntradayMarginDollars, int mNQPositionMaxVolume, double nQCommissionPerSide, double nQIntradayMarginDollars, int nQPositionMaxVolume, double mESCommissionPerSide, double mESIntradayMarginDollars, int mESPositionMaxVolume, double eSCommissionPerSide, double eSIntradayMarginDollars, int eSPositionMaxVolume, double mYMCommissionPerSide, double mYMIntradayMarginDollars, int mYMPositionMaxVolume, double yMCommissionPerSide, double yMIntradayMarginDollars, int yMPositionMaxVolume, double m2KCommissionPerSide, double m2KIntradayMarginDollars, int m2KPositionMaxVolume, double rTYCommissionPerSide, double rTYIntradayMarginDollars, int rTYPositionMaxVolume, bool ignoreInstrumentServerSupport, int snapOffsetTicks, int snapPowerBoxPeriod, bool snapPowerBoxAutoAdjustPeriodsOnM1, int aTRPeriod, int refreshTPSLOffsetTicks, int refreshTPSLOrderDelaySeconds, int singleOrderChunkMaxQuantity, int singleOrderChunkMinQuantity, int singleOrderChunkDelayMilliseconds, long realTimePipeLineThrottleMilliseconds, bool usePositionProfitLogging, int debugLogLevel, int orderWaitOutputThrottleSeconds, bool useAccountInfoLogging, string accountInfoLoggingPath)
		{
			return indicator.TickHunter(Input, indicatorName, indicatorTermsOfUse, showIndicatorName, indicatorInfoLink, useAutoPositionStopLoss, stopLossInitialTicks, stopLossInitialATRMultiplier, stopLossInitialSnapType, stopLossInitialMaxTicks, stopLossInitialDollars, stopLossInitialDollarsCombined, stopLossJumpTicks, stopLossCTRLJumpTicks, stopLossRefreshOnVolumeChange, stopLossRefreshManagementEnabled, useAutoPositionTakeProfit, takeProfitInitialTicks, takeProfitInitialATRMultiplier, takeProfitSyncBogeyTargetPrice, takeProfitSyncECATargetPrice, takeProfitJumpTicks, takeProfitCtrlSLMultiplier, takeProfitRefreshManagementEnabled, autoPositionBreakEvenType, breakEvenInitialTicks, breakEvenJumpTicks, breakEvenTurboJumpTicks, breakEvenAutoTrailNow, breakEvenAutoTriggerTicks, breakEvenAutoTriggerATRMultiplier, breakEvenAutoZombieFlipResumeSnapType, breakEvenAutoCreeperFlipSnapType, useIntradayMarginCheck, limitTrancheVolumeToInProfit, limitToVolumeMaxOption, entryVolumeMaxOption1, entryVolumeMaxOption2, entryVolumeMaxOption3, entryVolumeMaxOption4, entryVolumeMaxOption5, maxInitialTrancheVolumeSize, limitTrancheVolumePerBar, minTrancheVolumeDelaySeconds, usePopCTRLDelayedEntry, usePopLimitToPullback, popDelayedEntryMaxCount, popInitialTicks, popInitialATRMultiplier, popJumpTicks, usePopAutoJumpToSnap, dropInitialTicks, dropInitialATRMultiplier, dropJumpTicks, useDropAutoJumpToSnap, usePopDropOnBarUpdateDelay, popDropThrottleMilliseconds, autoEntryVolumeType, autoEntryVolumeOption1, autoEntryVolumeOption2, autoEntryVolumeOption3, autoEntryVolumeOption4, autoEntryVolumeOption5, autoPilotOrderType, autoPilotTradeSignalType, autoPilotSetupType, useAutoPilotLite, useAutoPilotAddOn, autoPilotMaxVolume, useAutoPilotSpeedLineFilter, autoPilotSpeedLineFilterPeriod, autoPilotSetupFilterPeriod, autoPilotSetupZombiePeriod, autoPilotSetupZombieMultiplier, autoPilotSetupCreeperPeriod1, autoPilotSetupCreeperPeriod2, autoPilotSetupCreeperPeriod3, autoPilotSetupWalkerPeriod, autoPilotSetupWalkerFreshCrossOnly, autoPilotProfileSetupType, usePeppyLimitPopDelayedEntry, usePeppyLimitPopToPullback, usePeppyLimitPopAlignedCreeper, usePeppyLimitPopAlignedRushLine, useSleepyLimitPopDelayedEntry, useSleepyLimitPopToPullback, useSleepyLimitPopCounterCreeper, useSleepyLimitPopCounterRushLine, autoPositionCloseType, useAutoCloseMinProfit, autoCloseMinProfitDollarsPerVolume, useAutoCloseAlert, autoCloseAndTrailOffsetTicks, autoCloseAndTrailMA1Period, autoCloseAndTrailMA2Period, autoCloseAndTrailMA3Period, autoCloseAndTrailMA4Period, autoCloseAndTrailZL1Period, autoCloseAndTrailZL2Period, autoCloseAndTrailRLPeriod, autoCloseAndTrailDL1Period, autoCloseAndTrailDL2Period, autoCloseAndTrailDL3Period, autoCloseAndTrailDL4Period, autoCloseAndTrailR1Period, autoCloseAndTrailR5Period, autoCloseAndTrailKLine1Period, autoCloseAndTrailKLine1Multiplier, autoCloseAndTrailKLine2Period, autoCloseAndTrailKLine2Multiplier, bogeyTargetStartWithFullPnL, bogeyTargetBaseDollars, bogeyTargetDailyBaseDollars, showBogeyTargetDailyBreakEvenLine, showBogeyTargetDaily1Line, showBogeyTargetDaily2Line, showBogeyTargetDaily3Line, showBogeyTargetDaily4Line, showBogeyTargetDaily5Line, eCATargetDollars, eCATargetDollarsPerOtherVolume, eCATargetDollarsPerMNQVolume, eCATargetDollarsPerNQVolume, eCATargetDollarsPerM2KVolume, eCATargetDollarsPerRTYVolume, eCATargetDollarsPerMESVolume, eCATargetDollarsPerESVolume, eCATargetDollarsPerMYMVolume, eCATargetDollarsPerYMVolume, eCATargetATRMultiplierPerVolume, autoAddOnMaxDollars, useDayOverMaxLossTrailing, dayOverMaxLossDollars, dayOverMaxLossBTBaseRatio, dayOverMaxAccountPnLPeakDollars, dayOverAccountBalanceFloorDollars, eCAMaxDDInDollars, excessIntradayMarginMinDollars, showButtonAutoBreakEven, showButtonReverse, showButtonClose, showButtonAutoClose, showButtonProfitTarget, showButtonTPPlus, showButtonBEPlus, showButtonSLPlus, showButtonBuyMarket, showButtonSellMarket, showButtonPopPlus, showButtonPopMinus, showButtonDropMinus, showButtonDropPlus, showButtonAutoAddOn, showButtonTradeSignal, showButtonAutoPilotProfile, showButtonAutoPilot, showButtonVolumeMax, showButtonVolume, useBlendedInstruments, showAveragePriceLine, showAveragePriceLineQuantity, showAveragePriceLineQuantityInMicros, otherCommissionPerSide, otherIntradayMarginDollars, otherPositionMaxVolume, mNQCommissionPerSide, mNQIntradayMarginDollars, mNQPositionMaxVolume, nQCommissionPerSide, nQIntradayMarginDollars, nQPositionMaxVolume, mESCommissionPerSide, mESIntradayMarginDollars, mESPositionMaxVolume, eSCommissionPerSide, eSIntradayMarginDollars, eSPositionMaxVolume, mYMCommissionPerSide, mYMIntradayMarginDollars, mYMPositionMaxVolume, yMCommissionPerSide, yMIntradayMarginDollars, yMPositionMaxVolume, m2KCommissionPerSide, m2KIntradayMarginDollars, m2KPositionMaxVolume, rTYCommissionPerSide, rTYIntradayMarginDollars, rTYPositionMaxVolume, ignoreInstrumentServerSupport, snapOffsetTicks, snapPowerBoxPeriod, snapPowerBoxAutoAdjustPeriodsOnM1, aTRPeriod, refreshTPSLOffsetTicks, refreshTPSLOrderDelaySeconds, singleOrderChunkMaxQuantity, singleOrderChunkMinQuantity, singleOrderChunkDelayMilliseconds, realTimePipeLineThrottleMilliseconds, usePositionProfitLogging, debugLogLevel, orderWaitOutputThrottleSeconds, useAccountInfoLogging, accountInfoLoggingPath);
		}

		public Indicators.TickHunterTA.TickHunter TickHunter(ISeries<double> input , string indicatorName, string indicatorTermsOfUse, bool showIndicatorName, string indicatorInfoLink, bool useAutoPositionStopLoss, int stopLossInitialTicks, double stopLossInitialATRMultiplier, TickHunterStopLossSnapTypes stopLossInitialSnapType, int stopLossInitialMaxTicks, double stopLossInitialDollars, bool stopLossInitialDollarsCombined, int stopLossJumpTicks, bool stopLossCTRLJumpTicks, bool stopLossRefreshOnVolumeChange, bool stopLossRefreshManagementEnabled, bool useAutoPositionTakeProfit, int takeProfitInitialTicks, double takeProfitInitialATRMultiplier, bool takeProfitSyncBogeyTargetPrice, bool takeProfitSyncECATargetPrice, int takeProfitJumpTicks, double takeProfitCtrlSLMultiplier, bool takeProfitRefreshManagementEnabled, TickHunterBreakEvenAutoTypes autoPositionBreakEvenType, int breakEvenInitialTicks, int breakEvenJumpTicks, int breakEvenTurboJumpTicks, TickHunterBreakEvenAutoTrailNowTypes breakEvenAutoTrailNow, int breakEvenAutoTriggerTicks, double breakEvenAutoTriggerATRMultiplier, TickHunterStopLossSnapTypes breakEvenAutoZombieFlipResumeSnapType, TickHunterStopLossSnapTypes breakEvenAutoCreeperFlipSnapType, bool useIntradayMarginCheck, bool limitTrancheVolumeToInProfit, bool limitToVolumeMaxOption, int entryVolumeMaxOption1, int entryVolumeMaxOption2, int entryVolumeMaxOption3, int entryVolumeMaxOption4, int entryVolumeMaxOption5, int maxInitialTrancheVolumeSize, bool limitTrancheVolumePerBar, int minTrancheVolumeDelaySeconds, bool usePopCTRLDelayedEntry, bool usePopLimitToPullback, int popDelayedEntryMaxCount, int popInitialTicks, double popInitialATRMultiplier, int popJumpTicks, bool usePopAutoJumpToSnap, int dropInitialTicks, double dropInitialATRMultiplier, int dropJumpTicks, bool useDropAutoJumpToSnap, bool usePopDropOnBarUpdateDelay, long popDropThrottleMilliseconds, TickHunterEntryVolumeAutoTypes autoEntryVolumeType, int autoEntryVolumeOption1, int autoEntryVolumeOption2, int autoEntryVolumeOption3, int autoEntryVolumeOption4, int autoEntryVolumeOption5, TickHunterAutoPilotOrderTypes autoPilotOrderType, TickHunterTradeSignalTypes autoPilotTradeSignalType, TickHunterAutoPilotSetupTypes autoPilotSetupType, bool useAutoPilotLite, bool useAutoPilotAddOn, int autoPilotMaxVolume, bool useAutoPilotSpeedLineFilter, int autoPilotSpeedLineFilterPeriod, int autoPilotSetupFilterPeriod, int autoPilotSetupZombiePeriod, double autoPilotSetupZombieMultiplier, int autoPilotSetupCreeperPeriod1, int autoPilotSetupCreeperPeriod2, int autoPilotSetupCreeperPeriod3, int autoPilotSetupWalkerPeriod, bool autoPilotSetupWalkerFreshCrossOnly, TickHunterAutoPilotProfileSetupTypes autoPilotProfileSetupType, bool usePeppyLimitPopDelayedEntry, bool usePeppyLimitPopToPullback, bool usePeppyLimitPopAlignedCreeper, bool usePeppyLimitPopAlignedRushLine, bool useSleepyLimitPopDelayedEntry, bool useSleepyLimitPopToPullback, bool useSleepyLimitPopCounterCreeper, bool useSleepyLimitPopCounterRushLine, TickHunterCloseAutoTypes autoPositionCloseType, bool useAutoCloseMinProfit, double autoCloseMinProfitDollarsPerVolume, bool useAutoCloseAlert, int autoCloseAndTrailOffsetTicks, int autoCloseAndTrailMA1Period, int autoCloseAndTrailMA2Period, int autoCloseAndTrailMA3Period, int autoCloseAndTrailMA4Period, int autoCloseAndTrailZL1Period, int autoCloseAndTrailZL2Period, int autoCloseAndTrailRLPeriod, int autoCloseAndTrailDL1Period, int autoCloseAndTrailDL2Period, int autoCloseAndTrailDL3Period, int autoCloseAndTrailDL4Period, int autoCloseAndTrailR1Period, int autoCloseAndTrailR5Period, int autoCloseAndTrailKLine1Period, double autoCloseAndTrailKLine1Multiplier, int autoCloseAndTrailKLine2Period, double autoCloseAndTrailKLine2Multiplier, bool bogeyTargetStartWithFullPnL, double bogeyTargetBaseDollars, double bogeyTargetDailyBaseDollars, bool showBogeyTargetDailyBreakEvenLine, bool showBogeyTargetDaily1Line, bool showBogeyTargetDaily2Line, bool showBogeyTargetDaily3Line, bool showBogeyTargetDaily4Line, bool showBogeyTargetDaily5Line, double eCATargetDollars, double eCATargetDollarsPerOtherVolume, double eCATargetDollarsPerMNQVolume, double eCATargetDollarsPerNQVolume, double eCATargetDollarsPerM2KVolume, double eCATargetDollarsPerRTYVolume, double eCATargetDollarsPerMESVolume, double eCATargetDollarsPerESVolume, double eCATargetDollarsPerMYMVolume, double eCATargetDollarsPerYMVolume, double eCATargetATRMultiplierPerVolume, double autoAddOnMaxDollars, bool useDayOverMaxLossTrailing, double dayOverMaxLossDollars, double dayOverMaxLossBTBaseRatio, double dayOverMaxAccountPnLPeakDollars, double dayOverAccountBalanceFloorDollars, double eCAMaxDDInDollars, double excessIntradayMarginMinDollars, bool showButtonAutoBreakEven, bool showButtonReverse, bool showButtonClose, bool showButtonAutoClose, bool showButtonProfitTarget, bool showButtonTPPlus, bool showButtonBEPlus, bool showButtonSLPlus, bool showButtonBuyMarket, bool showButtonSellMarket, bool showButtonPopPlus, bool showButtonPopMinus, bool showButtonDropMinus, bool showButtonDropPlus, bool showButtonAutoAddOn, bool showButtonTradeSignal, bool showButtonAutoPilotProfile, bool showButtonAutoPilot, bool showButtonVolumeMax, bool showButtonVolume, bool useBlendedInstruments, bool showAveragePriceLine, bool showAveragePriceLineQuantity, bool showAveragePriceLineQuantityInMicros, double otherCommissionPerSide, double otherIntradayMarginDollars, int otherPositionMaxVolume, double mNQCommissionPerSide, double mNQIntradayMarginDollars, int mNQPositionMaxVolume, double nQCommissionPerSide, double nQIntradayMarginDollars, int nQPositionMaxVolume, double mESCommissionPerSide, double mESIntradayMarginDollars, int mESPositionMaxVolume, double eSCommissionPerSide, double eSIntradayMarginDollars, int eSPositionMaxVolume, double mYMCommissionPerSide, double mYMIntradayMarginDollars, int mYMPositionMaxVolume, double yMCommissionPerSide, double yMIntradayMarginDollars, int yMPositionMaxVolume, double m2KCommissionPerSide, double m2KIntradayMarginDollars, int m2KPositionMaxVolume, double rTYCommissionPerSide, double rTYIntradayMarginDollars, int rTYPositionMaxVolume, bool ignoreInstrumentServerSupport, int snapOffsetTicks, int snapPowerBoxPeriod, bool snapPowerBoxAutoAdjustPeriodsOnM1, int aTRPeriod, int refreshTPSLOffsetTicks, int refreshTPSLOrderDelaySeconds, int singleOrderChunkMaxQuantity, int singleOrderChunkMinQuantity, int singleOrderChunkDelayMilliseconds, long realTimePipeLineThrottleMilliseconds, bool usePositionProfitLogging, int debugLogLevel, int orderWaitOutputThrottleSeconds, bool useAccountInfoLogging, string accountInfoLoggingPath)
		{
			return indicator.TickHunter(input, indicatorName, indicatorTermsOfUse, showIndicatorName, indicatorInfoLink, useAutoPositionStopLoss, stopLossInitialTicks, stopLossInitialATRMultiplier, stopLossInitialSnapType, stopLossInitialMaxTicks, stopLossInitialDollars, stopLossInitialDollarsCombined, stopLossJumpTicks, stopLossCTRLJumpTicks, stopLossRefreshOnVolumeChange, stopLossRefreshManagementEnabled, useAutoPositionTakeProfit, takeProfitInitialTicks, takeProfitInitialATRMultiplier, takeProfitSyncBogeyTargetPrice, takeProfitSyncECATargetPrice, takeProfitJumpTicks, takeProfitCtrlSLMultiplier, takeProfitRefreshManagementEnabled, autoPositionBreakEvenType, breakEvenInitialTicks, breakEvenJumpTicks, breakEvenTurboJumpTicks, breakEvenAutoTrailNow, breakEvenAutoTriggerTicks, breakEvenAutoTriggerATRMultiplier, breakEvenAutoZombieFlipResumeSnapType, breakEvenAutoCreeperFlipSnapType, useIntradayMarginCheck, limitTrancheVolumeToInProfit, limitToVolumeMaxOption, entryVolumeMaxOption1, entryVolumeMaxOption2, entryVolumeMaxOption3, entryVolumeMaxOption4, entryVolumeMaxOption5, maxInitialTrancheVolumeSize, limitTrancheVolumePerBar, minTrancheVolumeDelaySeconds, usePopCTRLDelayedEntry, usePopLimitToPullback, popDelayedEntryMaxCount, popInitialTicks, popInitialATRMultiplier, popJumpTicks, usePopAutoJumpToSnap, dropInitialTicks, dropInitialATRMultiplier, dropJumpTicks, useDropAutoJumpToSnap, usePopDropOnBarUpdateDelay, popDropThrottleMilliseconds, autoEntryVolumeType, autoEntryVolumeOption1, autoEntryVolumeOption2, autoEntryVolumeOption3, autoEntryVolumeOption4, autoEntryVolumeOption5, autoPilotOrderType, autoPilotTradeSignalType, autoPilotSetupType, useAutoPilotLite, useAutoPilotAddOn, autoPilotMaxVolume, useAutoPilotSpeedLineFilter, autoPilotSpeedLineFilterPeriod, autoPilotSetupFilterPeriod, autoPilotSetupZombiePeriod, autoPilotSetupZombieMultiplier, autoPilotSetupCreeperPeriod1, autoPilotSetupCreeperPeriod2, autoPilotSetupCreeperPeriod3, autoPilotSetupWalkerPeriod, autoPilotSetupWalkerFreshCrossOnly, autoPilotProfileSetupType, usePeppyLimitPopDelayedEntry, usePeppyLimitPopToPullback, usePeppyLimitPopAlignedCreeper, usePeppyLimitPopAlignedRushLine, useSleepyLimitPopDelayedEntry, useSleepyLimitPopToPullback, useSleepyLimitPopCounterCreeper, useSleepyLimitPopCounterRushLine, autoPositionCloseType, useAutoCloseMinProfit, autoCloseMinProfitDollarsPerVolume, useAutoCloseAlert, autoCloseAndTrailOffsetTicks, autoCloseAndTrailMA1Period, autoCloseAndTrailMA2Period, autoCloseAndTrailMA3Period, autoCloseAndTrailMA4Period, autoCloseAndTrailZL1Period, autoCloseAndTrailZL2Period, autoCloseAndTrailRLPeriod, autoCloseAndTrailDL1Period, autoCloseAndTrailDL2Period, autoCloseAndTrailDL3Period, autoCloseAndTrailDL4Period, autoCloseAndTrailR1Period, autoCloseAndTrailR5Period, autoCloseAndTrailKLine1Period, autoCloseAndTrailKLine1Multiplier, autoCloseAndTrailKLine2Period, autoCloseAndTrailKLine2Multiplier, bogeyTargetStartWithFullPnL, bogeyTargetBaseDollars, bogeyTargetDailyBaseDollars, showBogeyTargetDailyBreakEvenLine, showBogeyTargetDaily1Line, showBogeyTargetDaily2Line, showBogeyTargetDaily3Line, showBogeyTargetDaily4Line, showBogeyTargetDaily5Line, eCATargetDollars, eCATargetDollarsPerOtherVolume, eCATargetDollarsPerMNQVolume, eCATargetDollarsPerNQVolume, eCATargetDollarsPerM2KVolume, eCATargetDollarsPerRTYVolume, eCATargetDollarsPerMESVolume, eCATargetDollarsPerESVolume, eCATargetDollarsPerMYMVolume, eCATargetDollarsPerYMVolume, eCATargetATRMultiplierPerVolume, autoAddOnMaxDollars, useDayOverMaxLossTrailing, dayOverMaxLossDollars, dayOverMaxLossBTBaseRatio, dayOverMaxAccountPnLPeakDollars, dayOverAccountBalanceFloorDollars, eCAMaxDDInDollars, excessIntradayMarginMinDollars, showButtonAutoBreakEven, showButtonReverse, showButtonClose, showButtonAutoClose, showButtonProfitTarget, showButtonTPPlus, showButtonBEPlus, showButtonSLPlus, showButtonBuyMarket, showButtonSellMarket, showButtonPopPlus, showButtonPopMinus, showButtonDropMinus, showButtonDropPlus, showButtonAutoAddOn, showButtonTradeSignal, showButtonAutoPilotProfile, showButtonAutoPilot, showButtonVolumeMax, showButtonVolume, useBlendedInstruments, showAveragePriceLine, showAveragePriceLineQuantity, showAveragePriceLineQuantityInMicros, otherCommissionPerSide, otherIntradayMarginDollars, otherPositionMaxVolume, mNQCommissionPerSide, mNQIntradayMarginDollars, mNQPositionMaxVolume, nQCommissionPerSide, nQIntradayMarginDollars, nQPositionMaxVolume, mESCommissionPerSide, mESIntradayMarginDollars, mESPositionMaxVolume, eSCommissionPerSide, eSIntradayMarginDollars, eSPositionMaxVolume, mYMCommissionPerSide, mYMIntradayMarginDollars, mYMPositionMaxVolume, yMCommissionPerSide, yMIntradayMarginDollars, yMPositionMaxVolume, m2KCommissionPerSide, m2KIntradayMarginDollars, m2KPositionMaxVolume, rTYCommissionPerSide, rTYIntradayMarginDollars, rTYPositionMaxVolume, ignoreInstrumentServerSupport, snapOffsetTicks, snapPowerBoxPeriod, snapPowerBoxAutoAdjustPeriodsOnM1, aTRPeriod, refreshTPSLOffsetTicks, refreshTPSLOrderDelaySeconds, singleOrderChunkMaxQuantity, singleOrderChunkMinQuantity, singleOrderChunkDelayMilliseconds, realTimePipeLineThrottleMilliseconds, usePositionProfitLogging, debugLogLevel, orderWaitOutputThrottleSeconds, useAccountInfoLogging, accountInfoLoggingPath);
		}
	}
}

#endregion
